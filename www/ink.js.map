{"version":3,"file":"ink.js","sources":["../src/engine/Path.ts","../src/engine/Debug.ts","../src/engine/Value.ts","../src/engine/PushPop.ts","../src/engine/Error.ts","../src/engine/TypeAssertion.ts","../src/engine/NullException.ts","../src/engine/Object.ts","../src/engine/StringBuilder.ts","../src/engine/InkList.ts","../src/engine/StoryException.ts","../src/engine/TryGetResult.ts","../src/engine/SearchResult.ts","../src/engine/Container.ts","../src/engine/Glue.ts","../src/engine/ControlCommand.ts","../src/engine/Pointer.ts","../src/engine/Divert.ts","../src/engine/ChoicePoint.ts","../src/engine/VariableReference.ts","../src/engine/VariableAssignment.ts","../src/engine/Void.ts","../src/engine/NativeFunctionCall.ts","../src/engine/Tag.ts","../src/engine/Choice.ts","../src/engine/ListDefinition.ts","../src/engine/ListDefinitionsOrigin.ts","../src/engine/JsonSerialisation.ts","../src/engine/CallStack.ts","../src/engine/VariablesState.ts","../src/engine/PRNG.ts","../src/engine/StatePatch.ts","../src/engine/SimpleJson.ts","../src/engine/Flow.ts","../src/engine/StoryState.ts","../src/engine/StopWatch.ts","../src/engine/Story.ts"],"sourcesContent":["export class Path {\n  public static parentId = \"^\";\n\n  public _isRelative: boolean;\n  public _components: Path.Component[];\n  public _componentsString: string | null;\n\n  constructor();\n  constructor(componentsString: string);\n  constructor(head: Path.Component, tail: Path);\n  constructor(head: Path.Component[], relative?: boolean);\n  constructor() {\n    this._components = [];\n    this._componentsString = null;\n    this._isRelative = false;\n\n    if (typeof arguments[0] == \"string\") {\n      let componentsString = arguments[0] as string;\n      this.componentsString = componentsString;\n    } else if (\n      arguments[0] instanceof Path.Component &&\n      arguments[1] instanceof Path\n    ) {\n      let head = arguments[0] as Path.Component;\n      let tail = arguments[1] as Path;\n      this._components.push(head);\n      this._components = this._components.concat(tail._components);\n    } else if (arguments[0] instanceof Array) {\n      let head = arguments[0] as Path.Component[];\n      let relative = !!arguments[1] as boolean;\n      this._components = this._components.concat(head);\n      this._isRelative = relative;\n    }\n  }\n  get isRelative() {\n    return this._isRelative;\n  }\n  get componentCount(): number {\n    return this._components.length;\n  }\n  get head(): Path.Component | null {\n    if (this._components.length > 0) {\n      return this._components[0];\n    } else {\n      return null;\n    }\n  }\n  get tail(): Path {\n    if (this._components.length >= 2) {\n      // careful, the original code uses length-1 here. This is because the second argument of\n      // List.GetRange is a number of elements to extract, wherease Array.slice uses an index\n      let tailComps = this._components.slice(1, this._components.length);\n      return new Path(tailComps);\n    } else {\n      return Path.self;\n    }\n  }\n  get length(): number {\n    return this._components.length;\n  }\n  get lastComponent(): Path.Component | null {\n    let lastComponentIdx = this._components.length - 1;\n    if (lastComponentIdx >= 0) {\n      return this._components[lastComponentIdx];\n    } else {\n      return null;\n    }\n  }\n  get containsNamedComponent(): boolean {\n    for (let i = 0, l = this._components.length; i < l; i++) {\n      if (!this._components[i].isIndex) {\n        return true;\n      }\n    }\n    return false;\n  }\n  static get self(): Path {\n    let path = new Path();\n    path._isRelative = true;\n    return path;\n  }\n\n  public GetComponent(index: number): Path.Component {\n    return this._components[index];\n  }\n  public PathByAppendingPath(pathToAppend: Path): Path {\n    let p = new Path();\n\n    let upwardMoves = 0;\n    for (let i = 0; i < pathToAppend._components.length; ++i) {\n      if (pathToAppend._components[i].isParent) {\n        upwardMoves++;\n      } else {\n        break;\n      }\n    }\n\n    for (let i = 0; i < this._components.length - upwardMoves; ++i) {\n      p._components.push(this._components[i]);\n    }\n\n    for (let i = upwardMoves; i < pathToAppend._components.length; ++i) {\n      p._components.push(pathToAppend._components[i]);\n    }\n\n    return p;\n  }\n  get componentsString(): string {\n    if (this._componentsString == null) {\n      this._componentsString = this._components.join(\".\");\n      if (this.isRelative)\n        this._componentsString = \".\" + this._componentsString;\n    }\n\n    return this._componentsString;\n  }\n  set componentsString(value: string) {\n    this._components.length = 0;\n\n    this._componentsString = value;\n\n    if (this._componentsString == null || this._componentsString == \"\") return;\n\n    if (this._componentsString[0] == \".\") {\n      this._isRelative = true;\n      this._componentsString = this._componentsString.substring(1);\n    }\n\n    let componentStrings = this._componentsString.split(\".\");\n    for (let str of componentStrings) {\n      // we need to distinguish between named components that start with a number, eg \"42somewhere\", and indexed components\n      // the normal parseInt won't do for the detection because it's too relaxed.\n      // see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/parseInt\n      if (/^(\\-|\\+)?([0-9]+|Infinity)$/.test(str)) {\n        this._components.push(new Path.Component(parseInt(str)));\n      } else {\n        this._components.push(new Path.Component(str));\n      }\n    }\n  }\n  public toString(): string {\n    return this.componentsString;\n  }\n  public Equals(otherPath: Path | null): boolean {\n    if (otherPath == null) return false;\n\n    if (otherPath._components.length != this._components.length) return false;\n\n    if (otherPath.isRelative != this.isRelative) return false;\n\n    // the original code uses SequenceEqual here, so we need to iterate over the components manually.\n    for (let i = 0, l = otherPath._components.length; i < l; i++) {\n      // it's not quite clear whether this test should use Equals or a simple == operator,\n      // see https://github.com/y-lohse/inkjs/issues/22\n      if (!otherPath._components[i].Equals(this._components[i])) return false;\n    }\n\n    return true;\n  }\n  public PathByAppendingComponent(c: Path.Component): Path {\n    let p = new Path();\n    p._components.push(...this._components);\n    p._components.push(c);\n    return p;\n  }\n}\n\nexport namespace Path {\n  export class Component {\n    public readonly index: number;\n    public readonly name: string | null;\n\n    constructor(indexOrName: string | number) {\n      this.index = -1;\n      this.name = null;\n      if (typeof indexOrName == \"string\") {\n        this.name = indexOrName;\n      } else {\n        this.index = indexOrName;\n      }\n    }\n    get isIndex(): boolean {\n      return this.index >= 0;\n    }\n    get isParent(): boolean {\n      return this.name == Path.parentId;\n    }\n\n    public static ToParent(): Component {\n      return new Component(Path.parentId);\n    }\n    public toString(): string | null {\n      if (this.isIndex) {\n        return this.index.toString();\n      } else {\n        return this.name;\n      }\n    }\n    public Equals(otherComp: Component): boolean {\n      if (otherComp != null && otherComp.isIndex == this.isIndex) {\n        if (this.isIndex) {\n          return this.index == otherComp.index;\n        } else {\n          return this.name == otherComp.name;\n        }\n      }\n\n      return false;\n    }\n  }\n}\n","export namespace Debug {\n  export function AssertType<T>(\n    variable: any,\n    type: new () => T,\n    message: string\n  ): void | never {\n    Assert(variable instanceof type, message);\n  }\n\n  export function Assert(condition: boolean, message?: string): void | never {\n    if (!condition) {\n      if (typeof message !== \"undefined\") {\n        console.warn(message);\n      }\n\n      if (console.trace) {\n        console.trace();\n      }\n\n      throw new Error(\"\");\n    }\n  }\n}\n","import { InkObject } from \"./Object\";\nimport { Path } from \"./Path\";\nimport { InkList, InkListItem } from \"./InkList\";\nimport { StoryException } from \"./StoryException\";\nimport { asOrNull, asOrThrows } from \"./TypeAssertion\";\nimport { tryParseInt, tryParseFloat } from \"./TryGetResult\";\nimport { throwNullException } from \"./NullException\";\n\nexport abstract class AbstractValue extends InkObject {\n  public abstract get valueType(): ValueType;\n  public abstract get isTruthy(): boolean;\n  public abstract get valueObject(): any;\n\n  public abstract Cast(newType: ValueType): Value<any>;\n\n  public static Create(\n    val: any,\n    preferredNumberType?: ValueType\n  ): Value<any> | null {\n    // This code doesn't exist in upstream and is simply here to enforce\n    // the creation of the proper number value.\n    // If `preferredNumberType` is not provided or if value doesn't match\n    // `preferredNumberType`, this conditional does nothing.\n    if (preferredNumberType) {\n      if (\n        preferredNumberType === (ValueType.Int as ValueType) &&\n        Number.isInteger(Number(val))\n      ) {\n        return new IntValue(Number(val));\n      } else if (\n        preferredNumberType === (ValueType.Float as ValueType) &&\n        !isNaN(val)\n      ) {\n        return new FloatValue(Number(val));\n      }\n    }\n\n    if (typeof val === \"boolean\") {\n      return new BoolValue(Boolean(val));\n    }\n\n    // https://github.com/y-lohse/inkjs/issues/425\n    // Changed condition sequence, because Number('') is\n    // parsed to 0, which made setting string to empty\n    // impossible\n    if (typeof val === \"string\") {\n      return new StringValue(String(val));\n    } else if (Number.isInteger(Number(val))) {\n      return new IntValue(Number(val));\n    } else if (!isNaN(val)) {\n      return new FloatValue(Number(val));\n    } else if (val instanceof Path) {\n      return new DivertTargetValue(asOrThrows(val, Path));\n    } else if (val instanceof InkList) {\n      return new ListValue(asOrThrows(val, InkList));\n    }\n\n    return null;\n  }\n  public Copy() {\n    return asOrThrows(AbstractValue.Create(this.valueObject), InkObject);\n  }\n  public BadCastException(targetType: ValueType) {\n    return new StoryException(\n      \"Can't cast \" +\n        this.valueObject +\n        \" from \" +\n        this.valueType +\n        \" to \" +\n        targetType\n    );\n  }\n}\n\nexport abstract class Value<\n  T extends { toString: () => string }\n> extends AbstractValue {\n  public value: T | null;\n\n  constructor(val: T | null) {\n    super();\n    this.value = val;\n  }\n  public get valueObject() {\n    return this.value;\n  }\n  public toString() {\n    if (this.value === null) return throwNullException(\"Value.value\");\n    return this.value.toString();\n  }\n}\n\nexport class BoolValue extends Value<boolean> {\n  constructor(val: boolean) {\n    super(val || false);\n  }\n  public get isTruthy() {\n    return Boolean(this.value);\n  }\n  public get valueType() {\n    return ValueType.Bool;\n  }\n\n  public Cast(newType: ValueType): Value<any> {\n    if (this.value === null) return throwNullException(\"Value.value\");\n\n    if (newType == this.valueType) {\n      return this;\n    }\n\n    if (newType == ValueType.Int) {\n      return new IntValue(this.value ? 1 : 0);\n    }\n\n    if (newType == ValueType.Float) {\n      return new FloatValue(this.value ? 1.0 : 0.0);\n    }\n\n    if (newType == ValueType.String) {\n      return new StringValue(this.value ? \"true\" : \"false\");\n    }\n\n    throw this.BadCastException(newType);\n  }\n\n  public toString() {\n    return this.value ? \"true\" : \"false\";\n  }\n}\n\nexport class IntValue extends Value<number> {\n  constructor(val: number) {\n    super(val || 0);\n  }\n  public get isTruthy() {\n    return this.value != 0;\n  }\n  public get valueType() {\n    return ValueType.Int;\n  }\n\n  public Cast(newType: ValueType): Value<any> {\n    if (this.value === null) return throwNullException(\"Value.value\");\n\n    if (newType == this.valueType) {\n      return this;\n    }\n\n    if (newType == ValueType.Bool) {\n      return new BoolValue(this.value === 0 ? false : true);\n    }\n\n    if (newType == ValueType.Float) {\n      return new FloatValue(this.value);\n    }\n\n    if (newType == ValueType.String) {\n      return new StringValue(\"\" + this.value);\n    }\n\n    throw this.BadCastException(newType);\n  }\n}\n\nexport class FloatValue extends Value<number> {\n  constructor(val: number) {\n    super(val || 0.0);\n  }\n  public get isTruthy() {\n    return this.value != 0.0;\n  }\n  public get valueType() {\n    return ValueType.Float;\n  }\n\n  public Cast(newType: ValueType): Value<any> {\n    if (this.value === null) return throwNullException(\"Value.value\");\n\n    if (newType == this.valueType) {\n      return this;\n    }\n\n    if (newType == ValueType.Bool) {\n      return new BoolValue(this.value === 0.0 ? false : true);\n    }\n\n    if (newType == ValueType.Int) {\n      return new IntValue(this.value);\n    }\n\n    if (newType == ValueType.String) {\n      return new StringValue(\"\" + this.value);\n    }\n\n    throw this.BadCastException(newType);\n  }\n}\n\nexport class StringValue extends Value<string> {\n  public _isNewline: boolean;\n  public _isInlineWhitespace: boolean;\n\n  constructor(val: string) {\n    super(val || \"\");\n\n    this._isNewline = this.value == \"\\n\";\n    this._isInlineWhitespace = true;\n\n    if (this.value === null) return throwNullException(\"Value.value\");\n\n    if (this.value.length > 0) {\n      this.value.split(\"\").every((c) => {\n        if (c != \" \" && c != \"\\t\") {\n          this._isInlineWhitespace = false;\n          return false;\n        }\n\n        return true;\n      });\n    }\n  }\n  public get valueType() {\n    return ValueType.String;\n  }\n  public get isTruthy() {\n    if (this.value === null) return throwNullException(\"Value.value\");\n    return this.value.length > 0;\n  }\n  public get isNewline() {\n    return this._isNewline;\n  }\n  public get isInlineWhitespace() {\n    return this._isInlineWhitespace;\n  }\n  public get isNonWhitespace() {\n    return !this.isNewline && !this.isInlineWhitespace;\n  }\n\n  public Cast(newType: ValueType): Value<any> {\n    if (newType == this.valueType) {\n      return this;\n    }\n\n    if (newType == ValueType.Int) {\n      let parsedInt = tryParseInt(this.value);\n      if (parsedInt.exists) {\n        return new IntValue(parsedInt.result);\n      } else {\n        throw this.BadCastException(newType);\n      }\n    }\n\n    if (newType == ValueType.Float) {\n      let parsedFloat = tryParseFloat(this.value);\n      if (parsedFloat.exists) {\n        return new FloatValue(parsedFloat.result);\n      } else {\n        throw this.BadCastException(newType);\n      }\n    }\n\n    throw this.BadCastException(newType);\n  }\n}\n\nexport class DivertTargetValue extends Value<Path> {\n  constructor(targetPath: Path | null = null) {\n    super(targetPath);\n  }\n  public get valueType() {\n    return ValueType.DivertTarget;\n  }\n  public get targetPath() {\n    if (this.value === null) return throwNullException(\"Value.value\");\n    return this.value;\n  }\n  public set targetPath(value: Path) {\n    this.value = value;\n  }\n  public get isTruthy(): never {\n    throw new Error(\"Shouldn't be checking the truthiness of a divert target\");\n  }\n\n  public Cast(newType: ValueType): Value<any> {\n    if (newType == this.valueType) return this;\n\n    throw this.BadCastException(newType);\n  }\n  public toString() {\n    return \"DivertTargetValue(\" + this.targetPath + \")\";\n  }\n}\n\nexport class VariablePointerValue extends Value<string> {\n  public _contextIndex: number;\n\n  constructor(variableName: string, contextIndex: number = -1) {\n    super(variableName);\n\n    this._contextIndex = contextIndex;\n  }\n\n  public get contextIndex() {\n    return this._contextIndex;\n  }\n  public set contextIndex(value: number) {\n    this._contextIndex = value;\n  }\n  public get variableName() {\n    if (this.value === null) return throwNullException(\"Value.value\");\n    return this.value;\n  }\n  public set variableName(value: string) {\n    this.value = value;\n  }\n  public get valueType() {\n    return ValueType.VariablePointer;\n  }\n\n  public get isTruthy(): never {\n    throw new Error(\n      \"Shouldn't be checking the truthiness of a variable pointer\"\n    );\n  }\n\n  public Cast(newType: ValueType): Value<any> {\n    if (newType == this.valueType) return this;\n\n    throw this.BadCastException(newType);\n  }\n  public toString() {\n    return \"VariablePointerValue(\" + this.variableName + \")\";\n  }\n  public Copy() {\n    return new VariablePointerValue(this.variableName, this.contextIndex);\n  }\n}\n\nexport class ListValue extends Value<InkList> {\n  public get isTruthy() {\n    if (this.value === null) {\n      return throwNullException(\"this.value\");\n    }\n    return this.value.Count > 0;\n  }\n  public get valueType() {\n    return ValueType.List;\n  }\n  public Cast(newType: ValueType): Value<any> {\n    if (this.value === null) return throwNullException(\"Value.value\");\n\n    if (newType == ValueType.Int) {\n      let max = this.value.maxItem;\n      if (max.Key.isNull) return new IntValue(0);\n      else return new IntValue(max.Value);\n    } else if (newType == ValueType.Float) {\n      let max = this.value.maxItem;\n      if (max.Key.isNull) return new FloatValue(0.0);\n      else return new FloatValue(max.Value);\n    } else if (newType == ValueType.String) {\n      let max = this.value.maxItem;\n      if (max.Key.isNull) return new StringValue(\"\");\n      else {\n        return new StringValue(max.Key.toString());\n      }\n    }\n\n    if (newType == this.valueType) return this;\n\n    throw this.BadCastException(newType);\n  }\n  constructor();\n  constructor(list: InkList);\n  constructor(listOrSingleItem: InkListItem, singleValue: number);\n  constructor(listOrSingleItem?: InkListItem | InkList, singleValue?: number) {\n    super(null);\n\n    if (!listOrSingleItem && !singleValue) {\n      this.value = new InkList();\n    } else if (listOrSingleItem instanceof InkList) {\n      this.value = new InkList(listOrSingleItem);\n    } else if (\n      listOrSingleItem instanceof InkListItem &&\n      typeof singleValue === \"number\"\n    ) {\n      this.value = new InkList({\n        Key: listOrSingleItem,\n        Value: singleValue,\n      });\n    }\n  }\n  public static RetainListOriginsForAssignment(\n    oldValue: InkObject | null,\n    newValue: InkObject\n  ) {\n    let oldList = asOrNull(oldValue, ListValue);\n    let newList = asOrNull(newValue, ListValue);\n\n    if (newList && newList.value === null)\n      return throwNullException(\"newList.value\");\n    if (oldList && oldList.value === null)\n      return throwNullException(\"oldList.value\");\n\n    // When assigning the empty list, try to retain any initial origin names\n    if (oldList && newList && newList.value!.Count == 0)\n      newList.value!.SetInitialOriginNames(oldList.value!.originNames);\n  }\n}\n\nexport enum ValueType {\n  Bool = -1,\n  Int = 0,\n  Float = 1,\n  List = 2,\n  String = 3,\n  DivertTarget = 4,\n  VariablePointer = 5,\n}\n","export enum PushPopType {\n  Tunnel = 0,\n  Function = 1,\n  FunctionEvaluationFromGame = 2,\n}\n","// TODO: Unify with Compiler.\n\nexport type ErrorHandler = (message: string, type: ErrorType) => void;\n\nexport enum ErrorType {\n  Author,\n  Warning,\n  Error,\n}\n","import { INamedContent } from \"./INamedContent\";\n\nexport function asOrNull<T>(\n  obj: any,\n  type: (new (...arg: any[]) => T) | (Function & { prototype: T })\n): T | null {\n  if (obj instanceof type) {\n    return unsafeTypeAssertion(obj, type);\n  } else {\n    return null;\n  }\n}\n\nexport function asOrThrows<T>(\n  obj: any,\n  type: (new (...arg: any[]) => T) | (Function & { prototype: T })\n): T | never {\n  if (obj instanceof type) {\n    return unsafeTypeAssertion(obj, type);\n  } else {\n    throw new Error(`${obj} is not of type ${type}`);\n  }\n}\n\nexport function asNumberOrThrows(obj: any) {\n  if (typeof obj === \"number\") {\n    return obj as number;\n  } else {\n    throw new Error(`${obj} is not a number`);\n  }\n}\n\nexport function asBooleanOrThrows(obj: any) {\n  if (typeof obj === \"boolean\") {\n    return obj as boolean;\n  } else {\n    throw new Error(`${obj} is not a boolean`);\n  }\n}\n\n// So here, in the reference implementation, contentObj is casted to an INamedContent\n// but here we use js-style duck typing: if it implements the same props as the interface,\n// we treat it as valid.\nexport function asINamedContentOrNull(obj: any): INamedContent | null {\n  if (obj.hasValidName && obj.name) {\n    return obj as INamedContent;\n  }\n\n  return null;\n}\n\nexport function nullIfUndefined<T>(obj: T | undefined): T | null {\n  if (typeof obj === \"undefined\") {\n    return null;\n  }\n\n  return obj;\n}\n\nexport function isEquatable(type: any) {\n  return typeof type === \"object\" && typeof type.Equals === \"function\";\n}\n\nfunction unsafeTypeAssertion<T>(\n  obj: any,\n  type: (new () => T) | (Function & { prototype: T })\n) {\n  return obj as T;\n}\n\nexport function filterUndef<T>(element: T | undefined): element is T {\n  return element != undefined;\n}\n","/**\n * In the original C# code, a SystemException would be thrown when passing\n * null to methods expected a valid instance. Javascript has no such\n * concept, but TypeScript will not allow `null` to be passed to methods\n * explicitely requiring a valid type.\n *\n * Whenever TypeScript complain about the possibility of a `null` value,\n * check the offending value and it it's null, throw this exception using\n * `throwNullException(name: string)`.\n */\nexport class NullException extends Error {}\n\n/**\n * Throw a NullException.\n *\n * @param name a short description of the offending value (often its name within the code).\n */\nexport function throwNullException(name: string): never {\n  throw new NullException(`${name} is null or undefined`);\n}\n","import { Path } from \"./Path\";\nimport { Container } from \"./Container\";\nimport { Debug } from \"./Debug\";\nimport { asOrNull, asINamedContentOrNull } from \"./TypeAssertion\";\nimport { throwNullException } from \"./NullException\";\nimport { SearchResult } from \"./SearchResult\";\nimport { DebugMetadata } from \"./DebugMetadata\";\n\nexport class InkObject {\n  public parent: InkObject | null = null;\n\n  get debugMetadata(): DebugMetadata | null {\n    if (this._debugMetadata === null) {\n      if (this.parent) {\n        return this.parent.debugMetadata;\n      }\n    }\n\n    return this._debugMetadata;\n  }\n\n  set debugMetadata(value) {\n    this._debugMetadata = value;\n  }\n\n  get ownDebugMetadata() {\n    return this._debugMetadata;\n  }\n\n  private _debugMetadata: DebugMetadata | null = null;\n\n  public DebugLineNumberOfPath(path: Path) {\n    if (path === null) return null;\n\n    // Try to get a line number from debug metadata\n    let root = this.rootContentContainer;\n    if (root) {\n      let targetContent = root.ContentAtPath(path).obj;\n      if (targetContent) {\n        let dm = targetContent.debugMetadata;\n        if (dm !== null) {\n          return dm.startLineNumber;\n        }\n      }\n    }\n\n    return null;\n  }\n\n  get path() {\n    if (this._path == null) {\n      if (this.parent == null) {\n        this._path = new Path();\n      } else {\n        let comps: Path.Component[] = [];\n\n        let child: InkObject = this;\n        let container = asOrNull(child.parent, Container);\n\n        while (container !== null) {\n          let namedChild = asINamedContentOrNull(child);\n          if (namedChild != null && namedChild.hasValidName) {\n            if (namedChild.name === null)\n              return throwNullException(\"namedChild.name\");\n            comps.unshift(new Path.Component(namedChild.name!));\n          } else {\n            comps.unshift(new Path.Component(container.content.indexOf(child)));\n          }\n\n          child = container;\n          container = asOrNull(container.parent, Container);\n        }\n\n        this._path = new Path(comps);\n      }\n    }\n\n    return this._path;\n  }\n  private _path: Path | null = null;\n\n  public ResolvePath(path: Path | null): SearchResult {\n    if (path === null) return throwNullException(\"path\");\n    if (path.isRelative) {\n      let nearestContainer = asOrNull(this, Container);\n\n      if (nearestContainer === null) {\n        Debug.Assert(\n          this.parent !== null,\n          \"Can't resolve relative path because we don't have a parent\"\n        );\n        nearestContainer = asOrNull(this.parent, Container);\n        Debug.Assert(\n          nearestContainer !== null,\n          \"Expected parent to be a container\"\n        );\n        Debug.Assert(path.GetComponent(0).isParent);\n        path = path.tail;\n      }\n\n      if (nearestContainer === null) {\n        return throwNullException(\"nearestContainer\");\n      }\n      return nearestContainer.ContentAtPath(path);\n    } else {\n      let contentContainer = this.rootContentContainer;\n      if (contentContainer === null) {\n        return throwNullException(\"contentContainer\");\n      }\n      return contentContainer.ContentAtPath(path);\n    }\n  }\n\n  public ConvertPathToRelative(globalPath: Path) {\n    let ownPath = this.path;\n\n    let minPathLength = Math.min(globalPath.length, ownPath.length);\n    let lastSharedPathCompIndex = -1;\n\n    for (let i = 0; i < minPathLength; ++i) {\n      let ownComp = ownPath.GetComponent(i);\n      let otherComp = globalPath.GetComponent(i);\n\n      if (ownComp.Equals(otherComp)) {\n        lastSharedPathCompIndex = i;\n      } else {\n        break;\n      }\n    }\n\n    // No shared path components, so just use global path\n    if (lastSharedPathCompIndex == -1) return globalPath;\n\n    let numUpwardsMoves = ownPath.componentCount - 1 - lastSharedPathCompIndex;\n\n    let newPathComps: Path.Component[] = [];\n\n    for (let up = 0; up < numUpwardsMoves; ++up)\n      newPathComps.push(Path.Component.ToParent());\n\n    for (\n      let down = lastSharedPathCompIndex + 1;\n      down < globalPath.componentCount;\n      ++down\n    )\n      newPathComps.push(globalPath.GetComponent(down));\n\n    let relativePath = new Path(newPathComps, true);\n    return relativePath;\n  }\n\n  public CompactPathString(otherPath: Path) {\n    let globalPathStr = null;\n    let relativePathStr = null;\n\n    if (otherPath.isRelative) {\n      relativePathStr = otherPath.componentsString;\n      globalPathStr = this.path.PathByAppendingPath(otherPath).componentsString;\n    } else {\n      let relativePath = this.ConvertPathToRelative(otherPath);\n      relativePathStr = relativePath.componentsString;\n      globalPathStr = otherPath.componentsString;\n    }\n\n    if (relativePathStr.length < globalPathStr.length) return relativePathStr;\n    else return globalPathStr;\n  }\n\n  get rootContentContainer() {\n    let ancestor: InkObject = this;\n    while (ancestor.parent) {\n      ancestor = ancestor.parent;\n    }\n    return asOrNull(ancestor, Container);\n  }\n\n  public Copy(): InkObject {\n    throw Error(\"Not Implemented: Doesn't support copying\");\n  }\n  // SetChild works slightly diferently in the js implementation.\n  // Since we can't pass an objets property by reference, we instead pass\n  // the object and the property string.\n  // TODO: This method can probably be rewritten with type-safety in mind.\n  public SetChild(obj: any, prop: any, value: any) {\n    if (obj[prop]) obj[prop] = null;\n\n    obj[prop] = value;\n\n    if (obj[prop]) obj[prop].parent = this;\n  }\n\n  public Equals(obj: any) {\n    return obj === this;\n  }\n}\n","export class StringBuilder {\n  private string: string;\n\n  constructor(str?: string) {\n    str = typeof str !== \"undefined\" ? str.toString() : \"\";\n    this.string = str;\n  }\n  get Length(): number {\n    return this.string.length;\n  }\n  public Append(str: string | null) {\n    if (str !== null) {\n      this.string += str;\n    }\n  }\n  public AppendLine(str?: string) {\n    if (typeof str !== \"undefined\") this.Append(str);\n    this.string += \"\\n\";\n  }\n  public AppendFormat(format: string, ...args: any[]) {\n    // taken from http://stackoverflow.com/questions/610406/javascript-equivalent-to-printf-string-format\n    this.string += format.replace(/{(\\d+)}/g, (match: string, num: number) =>\n      typeof args[num] != \"undefined\" ? args[num] : match\n    );\n  }\n  public toString(): string {\n    return this.string;\n  }\n\n  public Clear() {\n    this.string = \"\";\n  }\n}\n","import { throwNullException } from \"./NullException\";\nimport { StringBuilder } from \"./StringBuilder\";\nimport { ListDefinition } from \"./ListDefinition\";\nimport { Story } from \"./Story\";\n\nexport class InkListItem implements IInkListItem {\n  // InkListItem is a struct\n\n  public readonly originName: string | null = null;\n  public readonly itemName: string | null = null;\n\n  constructor(originName: string | null, itemName: string | null);\n  constructor(fullName: string | null);\n  constructor() {\n    if (typeof arguments[1] !== \"undefined\") {\n      let originName = arguments[0] as string | null;\n      let itemName = arguments[1] as string | null;\n\n      this.originName = originName;\n      this.itemName = itemName;\n    } else if (arguments[0]) {\n      let fullName = arguments[0] as string;\n\n      let nameParts = fullName.toString().split(\".\");\n      this.originName = nameParts[0];\n      this.itemName = nameParts[1];\n    }\n  }\n  public static get Null() {\n    return new InkListItem(null, null);\n  }\n  public get isNull() {\n    return this.originName == null && this.itemName == null;\n  }\n  get fullName() {\n    return (\n      (this.originName !== null ? this.originName : \"?\") + \".\" + this.itemName\n    );\n  }\n  public toString(): string {\n    return this.fullName;\n  }\n  public Equals(obj: InkListItem) {\n    if (obj instanceof InkListItem) {\n      let otherItem = obj;\n      return (\n        otherItem.itemName == this.itemName &&\n        otherItem.originName == this.originName\n      );\n    }\n\n    return false;\n  }\n\n  // These methods did not exist in the original C# code. Their purpose is to\n  // make `InkListItem` mimics the value-type semantics of the original\n  // struct. Please refer to the end of this file, for a more in-depth\n  // explanation.\n\n  /**\n   * Returns a shallow clone of the current instance.\n   */\n  public copy() {\n    return new InkListItem(this.originName, this.itemName);\n  }\n  /**\n   * Returns a `SerializedInkListItem` representing the current\n   * instance. The result is intended to be used as a key inside a Map.\n   */\n  public serialized(): SerializedInkListItem {\n    // We are simply using a JSON representation as a value-typed key.\n    return JSON.stringify({\n      originName: this.originName,\n      itemName: this.itemName,\n    });\n  }\n\n  /**\n   * Reconstructs a `InkListItem` from the given SerializedInkListItem.\n   */\n  public static fromSerializedKey(key: SerializedInkListItem): InkListItem {\n    let obj = JSON.parse(key);\n    if (!InkListItem.isLikeInkListItem(obj)) return InkListItem.Null;\n\n    let inkListItem = obj as IInkListItem;\n\n    return new InkListItem(inkListItem.originName, inkListItem.itemName);\n  }\n\n  /**\n   * Determines whether the given item is sufficiently `InkListItem`-like\n   * to be used as a template when reconstructing the InkListItem.\n   */\n  private static isLikeInkListItem(item: any) {\n    if (typeof item !== \"object\") return false;\n    if (!item.hasOwnProperty(\"originName\") || !item.hasOwnProperty(\"itemName\"))\n      return false;\n    if (typeof item.originName !== \"string\" && typeof item.originName !== null)\n      return false;\n    if (typeof item.itemName !== \"string\" && typeof item.itemName !== null)\n      return false;\n\n    return true;\n  }\n}\n\nexport class InkList extends Map<SerializedInkListItem, number> {\n  public origins: ListDefinition[] | null = null;\n  public _originNames: string[] | null = [];\n\n  constructor();\n  constructor(otherList: InkList);\n  constructor(singleOriginListName: string, originStory: Story);\n  constructor(singleElement: KeyValuePair<InkListItem, number>);\n  constructor() {\n    // Trying to be smart here, this emulates the constructor inheritance found\n    // in the original code, but only if otherList is an InkList. IIFE FTW.\n    super(\n      (() => {\n        if (arguments[0] instanceof InkList) {\n          return arguments[0];\n        } else {\n          return [];\n        }\n      })()\n    );\n\n    if (arguments[0] instanceof InkList) {\n      let otherList = arguments[0] as InkList;\n\n      let otherOriginNames = otherList.originNames as string[];\n      if (otherOriginNames !== null)\n        this._originNames = otherOriginNames.slice();\n      if (otherList.origins !== null) {\n        this.origins = otherList.origins.slice();\n      }\n    } else if (typeof arguments[0] === \"string\") {\n      let singleOriginListName = arguments[0] as string;\n      let originStory = arguments[1] as Story;\n      this.SetInitialOriginName(singleOriginListName);\n\n      if (originStory.listDefinitions === null) {\n        return throwNullException(\"originStory.listDefinitions\");\n      }\n      let def = originStory.listDefinitions.TryListGetDefinition(\n        singleOriginListName,\n        null\n      );\n      if (def.exists) {\n        // Throwing now, because if the value is `null` it will\n        // eventually throw down the line.\n        if (def.result === null) {\n          return throwNullException(\"def.result\");\n        }\n        this.origins = [def.result];\n      } else {\n        throw new Error(\n          \"InkList origin could not be found in story when constructing new list: \" +\n            singleOriginListName\n        );\n      }\n    } else if (\n      typeof arguments[0] === \"object\" &&\n      arguments[0].hasOwnProperty(\"Key\") &&\n      arguments[0].hasOwnProperty(\"Value\")\n    ) {\n      let singleElement = arguments[0] as KeyValuePair<InkListItem, number>;\n      this.Add(singleElement.Key, singleElement.Value);\n    }\n  }\n\n  public static FromString(myListItem: string, originStory: Story) {\n    let listValue =\n      originStory.listDefinitions?.FindSingleItemListWithName(myListItem);\n    if (listValue) {\n      if (listValue.value === null) {\n        return throwNullException(\"listValue.value\");\n      }\n      return new InkList(listValue.value);\n    } else {\n      throw new Error(\n        \"Could not find the InkListItem from the string '\" +\n          myListItem +\n          \"' to create an InkList because it doesn't exist in the original list definition in ink.\"\n      );\n    }\n  }\n\n  public AddItem(itemOrItemName: InkListItem | string | null) {\n    if (itemOrItemName instanceof InkListItem) {\n      let item = itemOrItemName;\n\n      if (item.originName == null) {\n        this.AddItem(item.itemName);\n        return;\n      }\n\n      if (this.origins === null) return throwNullException(\"this.origins\");\n\n      for (let origin of this.origins) {\n        if (origin.name == item.originName) {\n          let intVal = origin.TryGetValueForItem(item, 0);\n          if (intVal.exists) {\n            this.Add(item, intVal.result);\n            return;\n          } else {\n            throw new Error(\n              \"Could not add the item \" +\n                item +\n                \" to this list because it doesn't exist in the original list definition in ink.\"\n            );\n          }\n        }\n      }\n\n      throw new Error(\n        \"Failed to add item to list because the item was from a new list definition that wasn't previously known to this list. Only items from previously known lists can be used, so that the int value can be found.\"\n      );\n    } else {\n      let itemName = itemOrItemName as string | null;\n\n      let foundListDef: ListDefinition | null = null;\n\n      if (this.origins === null) return throwNullException(\"this.origins\");\n\n      for (let origin of this.origins) {\n        if (itemName === null) return throwNullException(\"itemName\");\n\n        if (origin.ContainsItemWithName(itemName)) {\n          if (foundListDef != null) {\n            throw new Error(\n              \"Could not add the item \" +\n                itemName +\n                \" to this list because it could come from either \" +\n                origin.name +\n                \" or \" +\n                foundListDef.name\n            );\n          } else {\n            foundListDef = origin;\n          }\n        }\n      }\n\n      if (foundListDef == null)\n        throw new Error(\n          \"Could not add the item \" +\n            itemName +\n            \" to this list because it isn't known to any list definitions previously associated with this list.\"\n        );\n\n      let item = new InkListItem(foundListDef.name, itemName);\n      let itemVal = foundListDef.ValueForItem(item);\n      this.Add(item, itemVal);\n    }\n  }\n  public ContainsItemNamed(itemName: string | null) {\n    for (let [key] of this) {\n      let item = InkListItem.fromSerializedKey(key);\n      if (item.itemName == itemName) return true;\n    }\n\n    return false;\n  }\n  public ContainsKey(key: InkListItem) {\n    return this.has(key.serialized());\n  }\n  public Add(key: InkListItem, value: number) {\n    let serializedKey = key.serialized();\n    if (this.has(serializedKey)) {\n      // Throw an exception to match the C# behavior.\n      throw new Error(`The Map already contains an entry for ${key}`);\n    }\n    this.set(serializedKey, value);\n  }\n  public Remove(key: InkListItem) {\n    return this.delete(key.serialized());\n  }\n  get Count() {\n    return this.size;\n  }\n  get originOfMaxItem(): ListDefinition | null {\n    if (this.origins == null) return null;\n\n    let maxOriginName = this.maxItem.Key.originName;\n    let result = null;\n    this.origins.every((origin) => {\n      if (origin.name == maxOriginName) {\n        result = origin;\n        return false;\n      } else return true;\n    });\n\n    return result;\n  }\n  get originNames(): string[] {\n    if (this.Count > 0) {\n      if (this._originNames == null && this.Count > 0) this._originNames = [];\n      else {\n        if (!this._originNames) this._originNames = [];\n        this._originNames.length = 0;\n      }\n\n      for (let [key] of this) {\n        let item = InkListItem.fromSerializedKey(key);\n        if (item.originName === null)\n          return throwNullException(\"item.originName\");\n        this._originNames.push(item.originName);\n      }\n    }\n\n    return this._originNames as string[];\n  }\n  public SetInitialOriginName(initialOriginName: string) {\n    this._originNames = [initialOriginName];\n  }\n  public SetInitialOriginNames(initialOriginNames: string[]) {\n    if (initialOriginNames == null) this._originNames = null;\n    else this._originNames = initialOriginNames.slice(); // store a copy\n  }\n  get maxItem() {\n    let max: KeyValuePair<InkListItem, number> = {\n      Key: InkListItem.Null,\n      Value: 0,\n    };\n    for (let [key, value] of this) {\n      let item = InkListItem.fromSerializedKey(key);\n      if (max.Key.isNull || value > max.Value)\n        max = { Key: item, Value: value };\n    }\n\n    return max;\n  }\n  get minItem() {\n    let min: KeyValuePair<InkListItem, number> = {\n      Key: InkListItem.Null,\n      Value: 0,\n    };\n    for (let [key, value] of this) {\n      let item = InkListItem.fromSerializedKey(key);\n      if (min.Key.isNull || value < min.Value) {\n        min = { Key: item, Value: value };\n      }\n    }\n    return min;\n  }\n  get inverse() {\n    let list = new InkList();\n    if (this.origins != null) {\n      for (let origin of this.origins) {\n        for (let [key, value] of origin.items) {\n          let item = InkListItem.fromSerializedKey(key);\n          if (!this.ContainsKey(item)) list.Add(item, value);\n        }\n      }\n    }\n    return list;\n  }\n  get all() {\n    let list = new InkList();\n    if (this.origins != null) {\n      for (let origin of this.origins) {\n        for (let [key, value] of origin.items) {\n          let item = InkListItem.fromSerializedKey(key);\n          list.set(item.serialized(), value);\n        }\n      }\n    }\n    return list;\n  }\n  public Union(otherList: InkList) {\n    let union = new InkList(this);\n    for (let [key, value] of otherList) {\n      union.set(key, value);\n    }\n    return union;\n  }\n  public Intersect(otherList: InkList) {\n    let intersection = new InkList();\n    for (let [key, value] of this) {\n      if (otherList.has(key)) intersection.set(key, value);\n    }\n\n    return intersection;\n  }\n  public HasIntersection(otherList: InkList): boolean {\n    for (let [key] of this) {\n      if (otherList.has(key)) return true;\n    }\n    return false;\n  }\n  public Without(listToRemove: InkList) {\n    let result = new InkList(this);\n    for (let [key] of listToRemove) {\n      result.delete(key);\n    }\n\n    return result;\n  }\n\n  public Contains(key: string): boolean;\n  public Contains(otherList: InkList): boolean;\n  public Contains(what: string | InkList): boolean {\n    if (typeof what == \"string\") return this.ContainsItemNamed(what);\n    const otherList = what;\n    if (otherList.size == 0 || this.size == 0) return false;\n    for (let [key] of otherList) {\n      if (!this.has(key)) return false;\n    }\n\n    return true;\n  }\n  public GreaterThan(otherList: InkList) {\n    if (this.Count == 0) return false;\n    if (otherList.Count == 0) return true;\n\n    return this.minItem.Value > otherList.maxItem.Value;\n  }\n  public GreaterThanOrEquals(otherList: InkList) {\n    if (this.Count == 0) return false;\n    if (otherList.Count == 0) return true;\n\n    return (\n      this.minItem.Value >= otherList.minItem.Value &&\n      this.maxItem.Value >= otherList.maxItem.Value\n    );\n  }\n  public LessThan(otherList: InkList) {\n    if (otherList.Count == 0) return false;\n    if (this.Count == 0) return true;\n\n    return this.maxItem.Value < otherList.minItem.Value;\n  }\n  public LessThanOrEquals(otherList: InkList) {\n    if (otherList.Count == 0) return false;\n    if (this.Count == 0) return true;\n\n    return (\n      this.maxItem.Value <= otherList.maxItem.Value &&\n      this.minItem.Value <= otherList.minItem.Value\n    );\n  }\n  public MaxAsList() {\n    if (this.Count > 0) return new InkList(this.maxItem);\n    else return new InkList();\n  }\n  public MinAsList() {\n    if (this.Count > 0) return new InkList(this.minItem);\n    else return new InkList();\n  }\n  public ListWithSubRange(minBound: any, maxBound: any) {\n    if (this.Count == 0) return new InkList();\n\n    let ordered = this.orderedItems;\n\n    let minValue = 0;\n    let maxValue = Number.MAX_SAFE_INTEGER;\n\n    if (Number.isInteger(minBound)) {\n      minValue = minBound;\n    } else {\n      if (minBound instanceof InkList && minBound.Count > 0)\n        minValue = minBound.minItem.Value;\n    }\n\n    if (Number.isInteger(maxBound)) {\n      maxValue = maxBound;\n    } else {\n      if (maxBound instanceof InkList && maxBound.Count > 0)\n        maxValue = maxBound.maxItem.Value;\n    }\n\n    let subList = new InkList();\n    subList.SetInitialOriginNames(this.originNames);\n    for (let item of ordered) {\n      if (item.Value >= minValue && item.Value <= maxValue) {\n        subList.Add(item.Key, item.Value);\n      }\n    }\n\n    return subList;\n  }\n  public Equals(otherInkList: InkList) {\n    if (otherInkList instanceof InkList === false) return false;\n    if (otherInkList.Count != this.Count) return false;\n\n    for (let [key] of this) {\n      if (!otherInkList.has(key)) return false;\n    }\n\n    return true;\n  }\n  // GetHashCode not implemented\n  get orderedItems() {\n    // List<KeyValuePair<InkListItem, int>>\n    let ordered = new Array<KeyValuePair<InkListItem, number>>();\n\n    for (let [key, value] of this) {\n      let item = InkListItem.fromSerializedKey(key);\n      ordered.push({ Key: item, Value: value });\n    }\n\n    ordered.sort((x, y) => {\n      if (x.Key.originName === null) {\n        return throwNullException(\"x.Key.originName\");\n      }\n      if (y.Key.originName === null) {\n        return throwNullException(\"y.Key.originName\");\n      }\n\n      if (x.Value == y.Value) {\n        return x.Key.originName.localeCompare(y.Key.originName);\n      } else {\n        // TODO: refactor this bit into a numberCompareTo method?\n        if (x.Value < y.Value) return -1;\n        return x.Value > y.Value ? 1 : 0;\n      }\n    });\n\n    return ordered;\n  }\n  public toString() {\n    let ordered = this.orderedItems;\n\n    let sb = new StringBuilder();\n    for (let i = 0; i < ordered.length; i++) {\n      if (i > 0) sb.Append(\", \");\n\n      let item = ordered[i].Key;\n      if (item.itemName === null) return throwNullException(\"item.itemName\");\n      sb.Append(item.itemName);\n    }\n\n    return sb.toString();\n  }\n  // casting a InkList to a Number, for somereason, actually gives a number.\n  // This messes up the type detection when creating a Value from a InkList.\n  // Returning NaN here prevents that.\n  public valueOf() {\n    return NaN;\n  }\n}\n\n/**\n * In the original C# code, `InkListItem` was defined as value type, meaning\n * that two `InkListItem` would be considered equal as long as they held the\n * same values. This doesn't hold true in Javascript, as `InkListItem` is a\n * reference type (Javascript doesn't allow the creation of custom value types).\n *\n * The key equality of Map objects is based on the \"SameValueZero\" algorithm;\n * since `InkListItem` is a value type, two keys will only be considered\n * equal if they are, in fact, the same object. As we are trying to emulate\n * the original behavior as close as possible, this will lead to unforeseen\n * side effects.\n *\n * In order to have a key equality based on value semantics, we'll convert\n * `InkListItem` to a valid string representation and use this representation\n * as a key (strings are value types in Javascript). Rather than using the\n * type `string` directly, we'll alias it to `SerializedInkListItem` and use\n * this type as the key for our Map-based `InkList`.\n *\n * Reducing `InkListItem` to a JSON representation would not be bulletproof\n * in the general case, but for our needs it works well. The major downside of\n * this method is that we will have to to reconstruct the original `InkListItem`\n * every time we'll need to access its properties.\n */\nexport type SerializedInkListItem = string;\n\n/**\n * An interface inherited by `InkListItem`, defining exposed\n * properties. It's mainly used when deserializing a `InkListItem` from its\n * key (`SerializedInkListItem`)\n */\ninterface IInkListItem {\n  readonly originName: string | null;\n  readonly itemName: string | null;\n}\nexport interface KeyValuePair<K, V> {\n  Key: K;\n  Value: V;\n}\n","export class StoryException extends Error {\n  public useEndLineNumber: boolean;\n  public message: string;\n  public name: string;\n\n  constructor(message: string) {\n    super(message);\n    this.useEndLineNumber = false;\n    this.message = message;\n    this.name = \"StoryException\";\n  }\n}\n","/**\n * This interface normalize the `TryGet` behavior found in the original\n * C# project. Any `TryGet` method will return a object conforming to this\n * interface.\n *\n * The original function returns a boolean and has a second parameter called\n * item that is an `out`. Both are needed and we can't just return the item\n * because it'll always be truthy. Instead, we return an object containing\n * whether the result exists (`exists`) and the result itself (`result`).\n *\n * For instance a `TryGet` prototype would look like this:\n```\nTryGetItemWithValue(val: number, item: InkListItem): TryGetResult<InkListItem>{\n```\n *\n * On the other hand, dealing with the result can be done in the following way:\n```\nvar item = item.TryGetItemWithValue(intVal, InkListItem.Null);\nif (item.exists) {\n\tconsole.log(item.result)\n}\n```\n *\n */\nexport interface TryGetResult<T> {\n  result: T;\n  exists: boolean;\n}\n\nexport function tryGetValueFromMap<K, V>(\n  map: Map<K, V> | null,\n  key: K,\n  /* out */ value: V\n): TryGetResult<V> {\n  if (map === null) {\n    return { result: value, exists: false };\n  }\n\n  let val = map.get(key);\n\n  if (typeof val === \"undefined\") {\n    return { result: value, exists: false };\n  } else {\n    return { result: val, exists: true };\n  }\n}\n\nexport function tryParseInt(\n  value: any,\n  /* out */ defaultValue: number = 0\n): TryGetResult<number> {\n  let val = parseInt(value);\n\n  if (!Number.isNaN(val)) {\n    return { result: val, exists: true };\n  } else {\n    return { result: defaultValue, exists: false };\n  }\n}\n\nexport function tryParseFloat(\n  value: any,\n  /* out */ defaultValue: number = 0\n): TryGetResult<number> {\n  let val = parseFloat(value);\n\n  if (!Number.isNaN(val)) {\n    return { result: val, exists: true };\n  } else {\n    return { result: defaultValue, exists: false };\n  }\n}\n","import { InkObject } from \"./Object\";\nimport { Container } from \"./Container\";\n\nexport class SearchResult {\n  public obj: InkObject | null = null;\n  public approximate: boolean = false;\n\n  get correctObj() {\n    return this.approximate ? null : this.obj;\n  }\n\n  get container() {\n    return this.obj instanceof Container ? this.obj : null;\n  }\n\n  public copy() {\n    let searchResult = new SearchResult();\n    searchResult.obj = this.obj;\n    searchResult.approximate = this.approximate;\n\n    return searchResult;\n  }\n}\n","import { StringValue } from \"./Value\";\nimport { throwNullException } from \"./NullException\";\nimport { StringBuilder } from \"./StringBuilder\";\nimport { INamedContent } from \"./INamedContent\";\nimport { InkObject } from \"./Object\";\nimport { SearchResult } from \"./SearchResult\";\nimport { Path } from \"./Path\";\nimport { Debug } from \"./Debug\";\nimport { tryGetValueFromMap } from \"./TryGetResult\";\nimport { asINamedContentOrNull, asOrNull, asOrThrows } from \"./TypeAssertion\";\n\nexport class Container extends InkObject implements INamedContent {\n  public name: string | null = null;\n\n  public _content: InkObject[] = [];\n  public namedContent: Map<string, INamedContent> = new Map();\n\n  public visitsShouldBeCounted: boolean = false;\n  public turnIndexShouldBeCounted: boolean = false;\n  public countingAtStartOnly: boolean = false;\n\n  public _pathToFirstLeafContent: Path | null = null;\n\n  get hasValidName() {\n    return this.name != null && this.name.length > 0;\n  }\n  get content() {\n    return this._content;\n  }\n  set content(value: InkObject[]) {\n    this.AddContent(value);\n  }\n  get namedOnlyContent() {\n    let namedOnlyContentDict: Map<string, InkObject> | null = new Map();\n\n    for (let [key, value] of this.namedContent) {\n      let inkObject = asOrThrows(value, InkObject);\n      namedOnlyContentDict.set(key, inkObject);\n    }\n\n    for (let c of this.content) {\n      let named = asINamedContentOrNull(c);\n      if (named != null && named.hasValidName) {\n        namedOnlyContentDict.delete(named.name!);\n      }\n    }\n\n    if (namedOnlyContentDict.size == 0) namedOnlyContentDict = null;\n\n    return namedOnlyContentDict;\n  }\n  set namedOnlyContent(value: Map<string, InkObject> | null) {\n    let existingNamedOnly = this.namedOnlyContent;\n    if (existingNamedOnly != null) {\n      for (let [key] of existingNamedOnly) {\n        this.namedContent.delete(key);\n      }\n    }\n\n    if (value == null) return;\n\n    for (let [, val] of value) {\n      let named = asINamedContentOrNull(val);\n      if (named != null) this.AddToNamedContentOnly(named);\n    }\n  }\n  get countFlags(): number {\n    let flags: Container.CountFlags = 0;\n    if (this.visitsShouldBeCounted) flags |= Container.CountFlags.Visits;\n    if (this.turnIndexShouldBeCounted) flags |= Container.CountFlags.Turns;\n    if (this.countingAtStartOnly) flags |= Container.CountFlags.CountStartOnly;\n\n    if (flags == Container.CountFlags.CountStartOnly) {\n      flags = 0;\n    }\n\n    return flags;\n  }\n  set countFlags(value: number) {\n    let flag: Container.CountFlags = value;\n    if ((flag & Container.CountFlags.Visits) > 0)\n      this.visitsShouldBeCounted = true;\n    if ((flag & Container.CountFlags.Turns) > 0)\n      this.turnIndexShouldBeCounted = true;\n    if ((flag & Container.CountFlags.CountStartOnly) > 0)\n      this.countingAtStartOnly = true;\n  }\n  get pathToFirstLeafContent() {\n    if (this._pathToFirstLeafContent == null)\n      this._pathToFirstLeafContent = this.path.PathByAppendingPath(\n        this.internalPathToFirstLeafContent\n      );\n\n    return this._pathToFirstLeafContent;\n  }\n  get internalPathToFirstLeafContent() {\n    let components: Path.Component[] = [];\n    let container: Container = this;\n    while (container instanceof Container) {\n      if (container.content.length > 0) {\n        components.push(new Path.Component(0));\n        container = container.content[0] as Container;\n      }\n    }\n    return new Path(components);\n  }\n\n  public AddContent(contentObjOrList: InkObject | InkObject[]) {\n    if (contentObjOrList instanceof Array) {\n      let contentList = contentObjOrList as InkObject[];\n\n      for (let c of contentList) {\n        this.AddContent(c);\n      }\n    } else {\n      let contentObj = contentObjOrList as InkObject;\n\n      this._content.push(contentObj);\n\n      if (contentObj.parent) {\n        throw new Error(\"content is already in \" + contentObj.parent);\n      }\n\n      contentObj.parent = this;\n\n      this.TryAddNamedContent(contentObj);\n    }\n  }\n  public TryAddNamedContent(contentObj: InkObject) {\n    let namedContentObj = asINamedContentOrNull(contentObj);\n    if (namedContentObj != null && namedContentObj.hasValidName) {\n      this.AddToNamedContentOnly(namedContentObj);\n    }\n  }\n  public AddToNamedContentOnly(namedContentObj: INamedContent) {\n    Debug.AssertType(\n      namedContentObj,\n      InkObject,\n      \"Can only add Runtime.Objects to a Runtime.Container\"\n    );\n    let runtimeObj = asOrThrows(namedContentObj, InkObject);\n    runtimeObj.parent = this;\n\n    if (namedContentObj.name === null)\n      return throwNullException(\"namedContentObj.name\");\n    this.namedContent.set(namedContentObj.name!, namedContentObj);\n  }\n  public ContentAtPath(\n    path: Path,\n    partialPathStart: number = 0,\n    partialPathLength: number = -1\n  ) {\n    if (partialPathLength == -1) partialPathLength = path.length;\n\n    let result = new SearchResult();\n    result.approximate = false;\n\n    let currentContainer: Container | null = this;\n    let currentObj: InkObject = this;\n\n    for (let i = partialPathStart; i < partialPathLength; ++i) {\n      let comp = path.GetComponent(i);\n      if (currentContainer == null) {\n        result.approximate = true;\n        break;\n      }\n\n      let foundObj: InkObject | null =\n        currentContainer.ContentWithPathComponent(comp);\n\n      if (foundObj == null) {\n        result.approximate = true;\n        break;\n      }\n\n      currentObj = foundObj;\n      currentContainer = asOrNull(foundObj, Container);\n    }\n\n    result.obj = currentObj;\n\n    return result;\n  }\n  public InsertContent(contentObj: InkObject, index: number) {\n    this.content.splice(index, 0, contentObj);\n\n    if (contentObj.parent) {\n      throw new Error(\"content is already in \" + contentObj.parent);\n    }\n\n    contentObj.parent = this;\n\n    this.TryAddNamedContent(contentObj);\n  }\n  public AddContentsOfContainer(otherContainer: Container) {\n    this.content.push(...otherContainer.content);\n\n    for (let obj of otherContainer.content) {\n      obj.parent = this;\n      this.TryAddNamedContent(obj);\n    }\n  }\n  public ContentWithPathComponent(component: Path.Component): InkObject | null {\n    if (component.isIndex) {\n      if (component.index >= 0 && component.index < this.content.length) {\n        return this.content[component.index];\n      } else {\n        return null;\n      }\n    } else if (component.isParent) {\n      return this.parent;\n    } else {\n      if (component.name === null) {\n        return throwNullException(\"component.name\");\n      }\n      let foundContent = tryGetValueFromMap(\n        this.namedContent,\n        component.name,\n        null\n      );\n      if (foundContent.exists) {\n        return asOrThrows(foundContent.result, InkObject);\n      } else {\n        return null;\n      }\n    }\n  }\n  public BuildStringOfHierarchy(): string;\n  public BuildStringOfHierarchy(\n    sb: StringBuilder,\n    indentation: number,\n    pointedObj: InkObject | null\n  ): string;\n  public BuildStringOfHierarchy() {\n    let sb: StringBuilder;\n    if (arguments.length == 0) {\n      sb = new StringBuilder();\n      this.BuildStringOfHierarchy(sb, 0, null);\n      return sb.toString();\n    }\n\n    sb = arguments[0] as StringBuilder;\n    let indentation = arguments[1] as number;\n    let pointedObj = arguments[2] as InkObject | null;\n\n    function appendIndentation() {\n      const spacesPerIndent = 4; // Truly const in the original code\n      for (let i = 0; i < spacesPerIndent * indentation; ++i) {\n        sb.Append(\" \");\n      }\n    }\n\n    appendIndentation();\n    sb.Append(\"[\");\n\n    if (this.hasValidName) {\n      sb.AppendFormat(\" ({0})\", this.name);\n    }\n\n    if (this == pointedObj) {\n      sb.Append(\"  <---\");\n    }\n\n    sb.AppendLine();\n\n    indentation++;\n\n    for (let i = 0; i < this.content.length; ++i) {\n      let obj = this.content[i];\n\n      if (obj instanceof Container) {\n        let container = obj as Container;\n\n        container.BuildStringOfHierarchy(sb, indentation, pointedObj);\n      } else {\n        appendIndentation();\n        if (obj instanceof StringValue) {\n          sb.Append('\"');\n          sb.Append(obj.toString().replace(\"\\n\", \"\\\\n\"));\n          sb.Append('\"');\n        } else {\n          sb.Append(obj.toString());\n        }\n      }\n\n      if (i != this.content.length - 1) {\n        sb.Append(\",\");\n      }\n\n      if (!(obj instanceof Container) && obj == pointedObj) {\n        sb.Append(\"  <---\");\n      }\n\n      sb.AppendLine();\n    }\n\n    let onlyNamed: Map<string, INamedContent> = new Map();\n\n    for (let [key, value] of this.namedContent) {\n      if (this.content.indexOf(asOrThrows(value, InkObject)) >= 0) {\n        continue;\n      } else {\n        onlyNamed.set(key, value);\n      }\n    }\n\n    if (onlyNamed.size > 0) {\n      appendIndentation();\n      sb.AppendLine(\"-- named: --\");\n\n      for (let [, value] of onlyNamed) {\n        Debug.AssertType(\n          value,\n          Container,\n          \"Can only print out named Containers\"\n        );\n        let container = value as Container;\n        container.BuildStringOfHierarchy(sb, indentation, pointedObj);\n        sb.AppendLine();\n      }\n    }\n\n    indentation--;\n\n    appendIndentation();\n    sb.Append(\"]\");\n  }\n}\n\nexport namespace Container {\n  export enum CountFlags {\n    Start = 0,\n    Visits = 1,\n    Turns = 2,\n    CountStartOnly = 4,\n  }\n}\n","import { InkObject } from \"./Object\";\n\nexport class Glue extends InkObject {\n  public toString() {\n    return \"Glue\";\n  }\n}\n","import { InkObject } from \"./Object\";\n\nexport class ControlCommand extends InkObject {\n  private _commandType: ControlCommand.CommandType;\n\n  get commandType(): ControlCommand.CommandType {\n    return this._commandType;\n  }\n\n  constructor(\n    commandType: ControlCommand.CommandType = ControlCommand.CommandType.NotSet\n  ) {\n    super();\n    this._commandType = commandType;\n  }\n\n  public Copy() {\n    return new ControlCommand(this.commandType);\n  }\n  public static EvalStart() {\n    return new ControlCommand(ControlCommand.CommandType.EvalStart);\n  }\n  public static EvalOutput() {\n    return new ControlCommand(ControlCommand.CommandType.EvalOutput);\n  }\n  public static EvalEnd() {\n    return new ControlCommand(ControlCommand.CommandType.EvalEnd);\n  }\n  public static Duplicate() {\n    return new ControlCommand(ControlCommand.CommandType.Duplicate);\n  }\n  public static PopEvaluatedValue() {\n    return new ControlCommand(ControlCommand.CommandType.PopEvaluatedValue);\n  }\n  public static PopFunction() {\n    return new ControlCommand(ControlCommand.CommandType.PopFunction);\n  }\n  public static PopTunnel() {\n    return new ControlCommand(ControlCommand.CommandType.PopTunnel);\n  }\n  public static BeginString() {\n    return new ControlCommand(ControlCommand.CommandType.BeginString);\n  }\n  public static EndString() {\n    return new ControlCommand(ControlCommand.CommandType.EndString);\n  }\n  public static NoOp() {\n    return new ControlCommand(ControlCommand.CommandType.NoOp);\n  }\n  public static ChoiceCount() {\n    return new ControlCommand(ControlCommand.CommandType.ChoiceCount);\n  }\n  public static Turns() {\n    return new ControlCommand(ControlCommand.CommandType.Turns);\n  }\n  public static TurnsSince() {\n    return new ControlCommand(ControlCommand.CommandType.TurnsSince);\n  }\n  public static ReadCount() {\n    return new ControlCommand(ControlCommand.CommandType.ReadCount);\n  }\n  public static Random() {\n    return new ControlCommand(ControlCommand.CommandType.Random);\n  }\n  public static SeedRandom() {\n    return new ControlCommand(ControlCommand.CommandType.SeedRandom);\n  }\n  public static VisitIndex() {\n    return new ControlCommand(ControlCommand.CommandType.VisitIndex);\n  }\n  public static SequenceShuffleIndex() {\n    return new ControlCommand(ControlCommand.CommandType.SequenceShuffleIndex);\n  }\n  public static StartThread() {\n    return new ControlCommand(ControlCommand.CommandType.StartThread);\n  }\n  public static Done() {\n    return new ControlCommand(ControlCommand.CommandType.Done);\n  }\n  public static End() {\n    return new ControlCommand(ControlCommand.CommandType.End);\n  }\n  public static ListFromInt() {\n    return new ControlCommand(ControlCommand.CommandType.ListFromInt);\n  }\n  public static ListRange() {\n    return new ControlCommand(ControlCommand.CommandType.ListRange);\n  }\n  public static ListRandom() {\n    return new ControlCommand(ControlCommand.CommandType.ListRandom);\n  }\n  public static BeginTag() {\n    return new ControlCommand(ControlCommand.CommandType.BeginTag);\n  }\n  public static EndTag() {\n    return new ControlCommand(ControlCommand.CommandType.EndTag);\n  }\n  public toString() {\n    return \"ControlCommand \" + this.commandType.toString();\n  }\n}\n\nexport namespace ControlCommand {\n  export enum CommandType {\n    NotSet = -1,\n    EvalStart, // 0\n    EvalOutput, // 1\n    EvalEnd, // 2\n    Duplicate, // 3\n    PopEvaluatedValue, // 4\n    PopFunction, // 5\n    PopTunnel, // 6\n    BeginString, // 7\n    EndString, // 8\n    NoOp, // 9\n    ChoiceCount, // 10\n    Turns, // 11\n    TurnsSince, // 12\n    ReadCount, // 13\n    Random, // 14\n    SeedRandom, // 15\n    VisitIndex, // 16\n    SequenceShuffleIndex, // 17\n    StartThread, // 18\n    Done, // 19\n    End, // 20\n    ListFromInt, // 21\n    ListRange, // 22\n    ListRandom, // 23\n    BeginTag, // 24\n    EndTag, // 25\n\n    TOTAL_VALUES,\n  }\n}\n","import { Path } from \"./Path\";\nimport { Container } from \"./Container\";\nimport { InkObject } from \"./Object\";\n\nexport class Pointer {\n  public container: Container | null = null;\n  public index: number = -1;\n\n  constructor();\n  constructor(container: Container | null, index: number);\n  constructor() {\n    if (arguments.length === 2) {\n      this.container = arguments[0];\n      this.index = arguments[1];\n    }\n  }\n\n  public Resolve(): InkObject | null {\n    if (this.index < 0) return this.container;\n    if (this.container == null) return null;\n    if (this.container.content.length == 0) return this.container;\n    if (this.index >= this.container.content.length) return null;\n\n    return this.container.content[this.index];\n  }\n\n  get isNull(): boolean {\n    return this.container == null;\n  }\n\n  get path(): Path | null {\n    if (this.isNull) return null;\n\n    if (this.index >= 0)\n      return this.container!.path.PathByAppendingComponent(\n        new Path.Component(this.index)\n      );\n    else return this.container!.path;\n  }\n\n  public toString(): string {\n    if (!this.container) return \"Ink Pointer (null)\";\n\n    return (\n      \"Ink Pointer -> \" +\n      this.container.path.toString() +\n      \" -- index \" +\n      this.index\n    );\n  }\n\n  // This method does not exist in the original C# code, but is here to maintain the\n  // value semantics of Pointer.\n  public copy(): Pointer {\n    return new Pointer(this.container, this.index);\n  }\n\n  public static StartOf(container: Container | null): Pointer {\n    return new Pointer(container, 0);\n  }\n\n  public static get Null(): Pointer {\n    return new Pointer(null, -1);\n  }\n}\n","import { Path } from \"./Path\";\nimport { PushPopType } from \"./PushPop\";\nimport { StringBuilder } from \"./StringBuilder\";\nimport { InkObject } from \"./Object\";\nimport { Pointer } from \"./Pointer\";\nimport { Container } from \"./Container\";\nimport { throwNullException } from \"./NullException\";\n\nexport class Divert extends InkObject {\n  get targetPath() {\n    if (this._targetPath != null && this._targetPath.isRelative) {\n      let targetObj = this.targetPointer.Resolve();\n      if (targetObj) {\n        this._targetPath = targetObj.path;\n      }\n    }\n\n    return this._targetPath;\n  }\n  set targetPath(value: Path | null) {\n    this._targetPath = value;\n    this._targetPointer = Pointer.Null;\n  }\n\n  public _targetPath: Path | null = null;\n\n  get targetPointer() {\n    if (this._targetPointer.isNull) {\n      let targetObj = this.ResolvePath(this._targetPath).obj;\n\n      if (this._targetPath === null)\n        return throwNullException(\"this._targetPath\");\n      if (this._targetPath.lastComponent === null)\n        return throwNullException(\"this._targetPath.lastComponent\");\n\n      if (this._targetPath.lastComponent.isIndex) {\n        if (targetObj === null) return throwNullException(\"targetObj\");\n        this._targetPointer.container =\n          targetObj.parent instanceof Container ? targetObj.parent : null;\n        this._targetPointer.index = this._targetPath.lastComponent.index;\n      } else {\n        this._targetPointer = Pointer.StartOf(\n          targetObj instanceof Container ? targetObj : null\n        );\n      }\n    }\n\n    return this._targetPointer.copy();\n  }\n\n  public _targetPointer: Pointer = Pointer.Null;\n\n  get targetPathString() {\n    if (this.targetPath == null) return null;\n\n    return this.CompactPathString(this.targetPath);\n  }\n  set targetPathString(value: string | null) {\n    if (value == null) {\n      this.targetPath = null;\n    } else {\n      this.targetPath = new Path(value);\n    }\n  }\n\n  public variableDivertName: string | null = null;\n  get hasVariableTarget() {\n    return this.variableDivertName != null;\n  }\n\n  public pushesToStack: boolean = false;\n  public stackPushType: PushPopType = 0;\n\n  public isExternal: boolean = false;\n  public externalArgs: number = 0;\n\n  public isConditional: boolean = false;\n\n  constructor(stackPushType?: PushPopType) {\n    super();\n    this.pushesToStack = false;\n\n    if (typeof stackPushType !== \"undefined\") {\n      this.pushesToStack = true;\n      this.stackPushType = stackPushType;\n    }\n  }\n\n  public Equals(obj: Divert | null) {\n    let otherDivert = obj;\n    if (otherDivert instanceof Divert) {\n      if (this.hasVariableTarget == otherDivert.hasVariableTarget) {\n        if (this.hasVariableTarget) {\n          return this.variableDivertName == otherDivert.variableDivertName;\n        } else {\n          if (this.targetPath === null)\n            return throwNullException(\"this.targetPath\");\n          return this.targetPath.Equals(otherDivert.targetPath);\n        }\n      }\n    }\n    return false;\n  }\n\n  public toString() {\n    if (this.hasVariableTarget) {\n      return \"Divert(variable: \" + this.variableDivertName + \")\";\n    } else if (this.targetPath == null) {\n      return \"Divert(null)\";\n    } else {\n      let sb = new StringBuilder();\n\n      let targetStr = this.targetPath.toString();\n      // int? targetLineNum = DebugLineNumberOfPath (targetPath);\n      let targetLineNum = null;\n      if (targetLineNum != null) {\n        targetStr = \"line \" + targetLineNum;\n      }\n\n      sb.Append(\"Divert\");\n\n      if (this.isConditional) sb.Append(\"?\");\n\n      if (this.pushesToStack) {\n        if (this.stackPushType == PushPopType.Function) {\n          sb.Append(\" function\");\n        } else {\n          sb.Append(\" tunnel\");\n        }\n      }\n\n      sb.Append(\" -> \");\n      sb.Append(this.targetPathString);\n\n      sb.Append(\" (\");\n      sb.Append(targetStr);\n      sb.Append(\")\");\n\n      return sb.toString();\n    }\n  }\n}\n","import { InkObject } from \"./Object\";\nimport { Path } from \"./Path\";\nimport { Container } from \"./Container\";\nimport { throwNullException } from \"./NullException\";\n\nexport class ChoicePoint extends InkObject {\n  public _pathOnChoice: Path | null = null;\n  public hasCondition: boolean = false;\n  public hasStartContent: boolean = false;\n  public hasChoiceOnlyContent: boolean = false;\n  public isInvisibleDefault: boolean = false;\n  public onceOnly: boolean = true;\n\n  constructor(onceOnly: boolean = true) {\n    super();\n    this.onceOnly = onceOnly;\n  }\n  get pathOnChoice(): Path | null {\n    if (this._pathOnChoice != null && this._pathOnChoice.isRelative) {\n      let choiceTargetObj = this.choiceTarget;\n      if (choiceTargetObj) {\n        this._pathOnChoice = choiceTargetObj.path;\n      }\n    }\n    return this._pathOnChoice;\n  }\n  set pathOnChoice(value: Path | null) {\n    this._pathOnChoice = value;\n  }\n  get choiceTarget(): Container | null {\n    if (this._pathOnChoice === null)\n      return throwNullException(\"ChoicePoint._pathOnChoice\");\n    return this.ResolvePath(this._pathOnChoice).container;\n  }\n  get pathStringOnChoice(): string {\n    if (this.pathOnChoice === null)\n      return throwNullException(\"ChoicePoint.pathOnChoice\");\n    return this.CompactPathString(this.pathOnChoice);\n  }\n  set pathStringOnChoice(value: string) {\n    this.pathOnChoice = new Path(value);\n  }\n  get flags(): number {\n    let flags = 0;\n    if (this.hasCondition) flags |= 1;\n    if (this.hasStartContent) flags |= 2;\n    if (this.hasChoiceOnlyContent) flags |= 4;\n    if (this.isInvisibleDefault) flags |= 8;\n    if (this.onceOnly) flags |= 16;\n    return flags;\n  }\n  set flags(value: number) {\n    this.hasCondition = (value & 1) > 0;\n    this.hasStartContent = (value & 2) > 0;\n    this.hasChoiceOnlyContent = (value & 4) > 0;\n    this.isInvisibleDefault = (value & 8) > 0;\n    this.onceOnly = (value & 16) > 0;\n  }\n  public toString(): string {\n    if (this.pathOnChoice === null)\n      return throwNullException(\"ChoicePoint.pathOnChoice\");\n    // int? targetLineNum = DebugLineNumberOfPath (pathOnChoice);\n    let targetLineNum = null;\n    let targetString = this.pathOnChoice.toString();\n\n    if (targetLineNum != null) {\n      targetString = \" line \" + targetLineNum + \"(\" + targetString + \")\";\n    }\n\n    return \"Choice: -> \" + targetString;\n  }\n}\n","import { InkObject } from \"./Object\";\nimport { Path } from \"./Path\";\n\nexport class VariableReference extends InkObject {\n  public name: string | null;\n  public pathForCount: Path | null = null;\n\n  get containerForCount() {\n    if (this.pathForCount === null) return null;\n    return this.ResolvePath(this.pathForCount).container;\n  }\n  get pathStringForCount() {\n    if (this.pathForCount === null) return null;\n\n    return this.CompactPathString(this.pathForCount);\n  }\n  set pathStringForCount(value: string | null) {\n    if (value === null) this.pathForCount = null;\n    else this.pathForCount = new Path(value);\n  }\n\n  constructor(name: string | null = null) {\n    super();\n    this.name = name;\n  }\n\n  public toString() {\n    if (this.name != null) {\n      return \"var(\" + this.name + \")\";\n    } else {\n      let pathStr = this.pathStringForCount;\n      return \"read_count(\" + pathStr + \")\";\n    }\n  }\n}\n","import { InkObject } from \"./Object\";\n\nexport class VariableAssignment extends InkObject {\n  public readonly variableName: string | null;\n  public readonly isNewDeclaration: boolean;\n  public isGlobal: boolean;\n\n  constructor(variableName: string | null, isNewDeclaration: boolean) {\n    super();\n    this.variableName = variableName || null;\n    this.isNewDeclaration = !!isNewDeclaration;\n    this.isGlobal = false;\n  }\n\n  public toString(): string {\n    return \"VarAssign to \" + this.variableName;\n  }\n}\n","import { InkObject } from \"./Object\";\n\nexport class Void extends InkObject {\n  public toString() {\n    return \"Void\";\n  }\n}\n","import { Value, ValueType, IntValue, ListValue, BoolValue } from \"./Value\";\nimport { StoryException } from \"./StoryException\";\nimport { Void } from \"./Void\";\nimport { Path } from \"./Path\";\nimport { InkList, InkListItem } from \"./InkList\";\nimport { InkObject } from \"./Object\";\nimport { asOrNull, asOrThrows, asBooleanOrThrows } from \"./TypeAssertion\";\nimport { throwNullException } from \"./NullException\";\n\ntype BinaryOp<T> = (left: T, right: T) => any;\ntype UnaryOp<T> = (val: T) => any;\n\nexport class NativeFunctionCall extends InkObject {\n  public static readonly Add: string = \"+\";\n  public static readonly Subtract: string = \"-\";\n  public static readonly Divide: string = \"/\";\n  public static readonly Multiply: string = \"*\";\n  public static readonly Mod: string = \"%\";\n  public static readonly Negate: string = \"_\";\n  public static readonly Equal: string = \"==\";\n  public static readonly Greater: string = \">\";\n  public static readonly Less: string = \"<\";\n  public static readonly GreaterThanOrEquals: string = \">=\";\n  public static readonly LessThanOrEquals: string = \"<=\";\n  public static readonly NotEquals: string = \"!=\";\n  public static readonly Not: string = \"!\";\n  public static readonly And: string = \"&&\";\n  public static readonly Or: string = \"||\";\n  public static readonly Min: string = \"MIN\";\n  public static readonly Max: string = \"MAX\";\n  public static readonly Pow: string = \"POW\";\n  public static readonly Floor: string = \"FLOOR\";\n  public static readonly Ceiling: string = \"CEILING\";\n  public static readonly Int: string = \"INT\";\n  public static readonly Float: string = \"FLOAT\";\n  public static readonly Has: string = \"?\";\n  public static readonly Hasnt: string = \"!?\";\n  public static readonly Intersect: string = \"^\";\n  public static readonly ListMin: string = \"LIST_MIN\";\n  public static readonly ListMax: string = \"LIST_MAX\";\n  public static readonly All: string = \"LIST_ALL\";\n  public static readonly Count: string = \"LIST_COUNT\";\n  public static readonly ValueOfList: string = \"LIST_VALUE\";\n  public static readonly Invert: string = \"LIST_INVERT\";\n\n  public static CallWithName(functionName: string) {\n    return new NativeFunctionCall(functionName);\n  }\n\n  public static CallExistsWithName(functionName: string) {\n    this.GenerateNativeFunctionsIfNecessary();\n    return this._nativeFunctions!.get(functionName);\n  }\n\n  get name() {\n    if (this._name === null)\n      return throwNullException(\"NativeFunctionCall._name\");\n    return this._name;\n  }\n  set name(value: string) {\n    this._name = value;\n    if (!this._isPrototype) {\n      if (NativeFunctionCall._nativeFunctions === null)\n        throwNullException(\"NativeFunctionCall._nativeFunctions\");\n      else\n        this._prototype =\n          NativeFunctionCall._nativeFunctions.get(this._name) || null;\n    }\n  }\n  public _name: string | null = null;\n\n  get numberOfParameters() {\n    if (this._prototype) {\n      return this._prototype.numberOfParameters;\n    } else {\n      return this._numberOfParameters;\n    }\n  }\n  set numberOfParameters(value: number) {\n    this._numberOfParameters = value;\n  }\n  public _numberOfParameters: number = 0;\n\n  public Call(parameters: InkObject[]): InkObject | null {\n    if (this._prototype) {\n      return this._prototype.Call(parameters);\n    }\n\n    if (this.numberOfParameters != parameters.length) {\n      throw new Error(\"Unexpected number of parameters\");\n    }\n\n    let hasList = false;\n    for (let p of parameters) {\n      if (p instanceof Void)\n        throw new StoryException(\n          'Attempting to perform operation on a void value. Did you forget to \"return\" a value from a function you called here?'\n        );\n      if (p instanceof ListValue) hasList = true;\n    }\n\n    if (parameters.length == 2 && hasList) {\n      return this.CallBinaryListOperation(parameters);\n    }\n\n    let coercedParams = this.CoerceValuesToSingleType(parameters);\n    let coercedType = coercedParams[0].valueType;\n\n    if (coercedType == ValueType.Int) {\n      return this.CallType<number>(coercedParams);\n    } else if (coercedType == ValueType.Float) {\n      return this.CallType<number>(coercedParams);\n    } else if (coercedType == ValueType.String) {\n      return this.CallType<string>(coercedParams);\n    } else if (coercedType == ValueType.DivertTarget) {\n      return this.CallType<Path>(coercedParams);\n    } else if (coercedType == ValueType.List) {\n      return this.CallType<InkList>(coercedParams);\n    }\n\n    return null;\n  }\n\n  public CallType<T extends { toString: () => string }>(\n    parametersOfSingleType: Array<Value<T>>\n  ) {\n    let param1 = asOrThrows(parametersOfSingleType[0], Value);\n    let valType = param1.valueType;\n\n    let val1 = param1 as Value<T>;\n\n    let paramCount = parametersOfSingleType.length;\n\n    if (paramCount == 2 || paramCount == 1) {\n      if (this._operationFuncs === null)\n        return throwNullException(\"NativeFunctionCall._operationFuncs\");\n      let opForTypeObj = this._operationFuncs.get(valType);\n      if (!opForTypeObj) {\n        const key = ValueType[valType];\n        throw new StoryException(\n          \"Cannot perform operation \" + this.name + \" on \" + key\n        );\n      }\n\n      if (paramCount == 2) {\n        let param2 = asOrThrows(parametersOfSingleType[1], Value);\n\n        let val2 = param2 as Value<T>;\n\n        let opForType = opForTypeObj as BinaryOp<T>;\n\n        if (val1.value === null || val2.value === null)\n          return throwNullException(\"NativeFunctionCall.Call BinaryOp values\");\n        let resultVal = opForType(val1.value, val2.value);\n\n        return Value.Create(resultVal);\n      } else {\n        let opForType = opForTypeObj as UnaryOp<T>;\n\n        if (val1.value === null)\n          return throwNullException(\"NativeFunctionCall.Call UnaryOp value\");\n        let resultVal = opForType(val1.value);\n\n        // This code is different from upstream. Since JavaScript treats\n        // integers and floats as the same numbers, it's impossible\n        // to force an number to be either an integer or a float.\n        //\n        // It can be useful to force a specific number type\n        // (especially for divisions), so the result of INT() & FLOAT()\n        // is coerced to the the proper value type.\n        //\n        // Note that we also force all other unary operation to\n        // return the same value type, although this is only\n        // meaningful for numbers. See `Value.Create`.\n        if (this.name === NativeFunctionCall.Int) {\n          return Value.Create(resultVal, ValueType.Int);\n        } else if (this.name === NativeFunctionCall.Float) {\n          return Value.Create(resultVal, ValueType.Float);\n        } else {\n          return Value.Create(resultVal, param1.valueType);\n        }\n      }\n    } else {\n      throw new Error(\n        \"Unexpected number of parameters to NativeFunctionCall: \" +\n          parametersOfSingleType.length\n      );\n    }\n  }\n\n  public CallBinaryListOperation(parameters: InkObject[]) {\n    if (\n      (this.name == \"+\" || this.name == \"-\") &&\n      parameters[0] instanceof ListValue &&\n      parameters[1] instanceof IntValue\n    )\n      return this.CallListIncrementOperation(parameters);\n\n    let v1 = asOrThrows(parameters[0], Value);\n    let v2 = asOrThrows(parameters[1], Value);\n\n    if (\n      (this.name == \"&&\" || this.name == \"||\") &&\n      (v1.valueType != ValueType.List || v2.valueType != ValueType.List)\n    ) {\n      if (this._operationFuncs === null)\n        return throwNullException(\"NativeFunctionCall._operationFuncs\");\n      let op = this._operationFuncs.get(ValueType.Int) as BinaryOp<number>;\n      if (op === null)\n        return throwNullException(\n          \"NativeFunctionCall.CallBinaryListOperation op\"\n        );\n      let result = asBooleanOrThrows(\n        op(v1.isTruthy ? 1 : 0, v2.isTruthy ? 1 : 0)\n      );\n      return new BoolValue(result);\n    }\n\n    if (v1.valueType == ValueType.List && v2.valueType == ValueType.List)\n      return this.CallType<InkList>([v1, v2]);\n\n    throw new StoryException(\n      \"Can not call use \" +\n        this.name +\n        \" operation on \" +\n        ValueType[v1.valueType] +\n        \" and \" +\n        ValueType[v2.valueType]\n    );\n  }\n\n  public CallListIncrementOperation(listIntParams: InkObject[]) {\n    let listVal = asOrThrows(listIntParams[0], ListValue);\n    let intVal = asOrThrows(listIntParams[1], IntValue);\n\n    let resultInkList = new InkList();\n\n    if (listVal.value === null)\n      return throwNullException(\n        \"NativeFunctionCall.CallListIncrementOperation listVal.value\"\n      );\n    for (let [listItemKey, listItemValue] of listVal.value) {\n      let listItem = InkListItem.fromSerializedKey(listItemKey);\n\n      if (this._operationFuncs === null)\n        return throwNullException(\"NativeFunctionCall._operationFuncs\");\n      let intOp = this._operationFuncs.get(ValueType.Int) as BinaryOp<number>;\n\n      if (intVal.value === null)\n        return throwNullException(\n          \"NativeFunctionCall.CallListIncrementOperation intVal.value\"\n        );\n      let targetInt = intOp(listItemValue, intVal.value);\n\n      let itemOrigin = null;\n      if (listVal.value.origins === null)\n        return throwNullException(\n          \"NativeFunctionCall.CallListIncrementOperation listVal.value.origins\"\n        );\n      for (let origin of listVal.value.origins) {\n        if (origin.name == listItem.originName) {\n          itemOrigin = origin;\n          break;\n        }\n      }\n      if (itemOrigin != null) {\n        let incrementedItem = itemOrigin.TryGetItemWithValue(\n          targetInt,\n          InkListItem.Null\n        );\n        if (incrementedItem.exists)\n          resultInkList.Add(incrementedItem.result, targetInt);\n      }\n    }\n\n    return new ListValue(resultInkList);\n  }\n\n  public CoerceValuesToSingleType(parametersIn: InkObject[]) {\n    let valType = ValueType.Int;\n\n    let specialCaseList: null | ListValue = null;\n\n    for (let obj of parametersIn) {\n      let val = asOrThrows(obj, Value);\n      if (val.valueType > valType) {\n        valType = val.valueType;\n      }\n\n      if (val.valueType == ValueType.List) {\n        specialCaseList = asOrNull(val, ListValue);\n      }\n    }\n\n    let parametersOut = [];\n\n    if (ValueType[valType] == ValueType[ValueType.List]) {\n      for (let inkObjectVal of parametersIn) {\n        let val = asOrThrows(inkObjectVal, Value);\n        if (val.valueType == ValueType.List) {\n          parametersOut.push(val);\n        } else if (val.valueType == ValueType.Int) {\n          let intVal = parseInt(val.valueObject);\n\n          specialCaseList = asOrThrows(specialCaseList, ListValue);\n          if (specialCaseList.value === null)\n            return throwNullException(\n              \"NativeFunctionCall.CoerceValuesToSingleType specialCaseList.value\"\n            );\n          let list = specialCaseList.value.originOfMaxItem;\n\n          if (list === null)\n            return throwNullException(\n              \"NativeFunctionCall.CoerceValuesToSingleType list\"\n            );\n          let item = list.TryGetItemWithValue(intVal, InkListItem.Null);\n          if (item.exists) {\n            let castedValue = new ListValue(item.result, intVal);\n            parametersOut.push(castedValue);\n          } else\n            throw new StoryException(\n              \"Could not find List item with the value \" +\n                intVal +\n                \" in \" +\n                list.name\n            );\n        } else {\n          const key = ValueType[val.valueType];\n          throw new StoryException(\n            \"Cannot mix Lists and \" + key + \" values in this operation\"\n          );\n        }\n      }\n    } else {\n      for (let inkObjectVal of parametersIn) {\n        let val = asOrThrows(inkObjectVal, Value);\n        let castedValue = val.Cast(valType);\n        parametersOut.push(castedValue);\n      }\n    }\n\n    return parametersOut;\n  }\n\n  constructor(name: string);\n  constructor(name: string, numberOfParameters: number);\n  constructor();\n  constructor() {\n    super();\n\n    if (arguments.length === 0) {\n      NativeFunctionCall.GenerateNativeFunctionsIfNecessary();\n    } else if (arguments.length === 1) {\n      let name = arguments[0];\n      NativeFunctionCall.GenerateNativeFunctionsIfNecessary();\n      this.name = name;\n    } else if (arguments.length === 2) {\n      let name = arguments[0];\n      let numberOfParameters = arguments[1];\n\n      this._isPrototype = true;\n      this.name = name;\n      this.numberOfParameters = numberOfParameters;\n    }\n  }\n\n  public static Identity<T>(t: T): any {\n    return t;\n  }\n\n  public static GenerateNativeFunctionsIfNecessary() {\n    if (this._nativeFunctions == null) {\n      this._nativeFunctions = new Map();\n\n      // Int operations\n      this.AddIntBinaryOp(this.Add, (x, y) => x + y);\n      this.AddIntBinaryOp(this.Subtract, (x, y) => x - y);\n      this.AddIntBinaryOp(this.Multiply, (x, y) => x * y);\n      this.AddIntBinaryOp(this.Divide, (x, y) => Math.floor(x / y));\n      this.AddIntBinaryOp(this.Mod, (x, y) => x % y);\n      this.AddIntUnaryOp(this.Negate, (x) => -x);\n\n      this.AddIntBinaryOp(this.Equal, (x, y) => x == y);\n      this.AddIntBinaryOp(this.Greater, (x, y) => x > y);\n      this.AddIntBinaryOp(this.Less, (x, y) => x < y);\n      this.AddIntBinaryOp(this.GreaterThanOrEquals, (x, y) => x >= y);\n      this.AddIntBinaryOp(this.LessThanOrEquals, (x, y) => x <= y);\n      this.AddIntBinaryOp(this.NotEquals, (x, y) => x != y);\n      this.AddIntUnaryOp(this.Not, (x) => x == 0);\n\n      this.AddIntBinaryOp(this.And, (x, y) => x != 0 && y != 0);\n      this.AddIntBinaryOp(this.Or, (x, y) => x != 0 || y != 0);\n\n      this.AddIntBinaryOp(this.Max, (x, y) => Math.max(x, y));\n      this.AddIntBinaryOp(this.Min, (x, y) => Math.min(x, y));\n\n      this.AddIntBinaryOp(this.Pow, (x, y) => Math.pow(x, y));\n      this.AddIntUnaryOp(this.Floor, NativeFunctionCall.Identity);\n      this.AddIntUnaryOp(this.Ceiling, NativeFunctionCall.Identity);\n      this.AddIntUnaryOp(this.Int, NativeFunctionCall.Identity);\n      this.AddIntUnaryOp(this.Float, (x) => x);\n\n      // Float operations\n      this.AddFloatBinaryOp(this.Add, (x, y) => x + y);\n      this.AddFloatBinaryOp(this.Subtract, (x, y) => x - y);\n      this.AddFloatBinaryOp(this.Multiply, (x, y) => x * y);\n      this.AddFloatBinaryOp(this.Divide, (x, y) => x / y);\n      this.AddFloatBinaryOp(this.Mod, (x, y) => x % y);\n      this.AddFloatUnaryOp(this.Negate, (x) => -x);\n\n      this.AddFloatBinaryOp(this.Equal, (x, y) => x == y);\n      this.AddFloatBinaryOp(this.Greater, (x, y) => x > y);\n      this.AddFloatBinaryOp(this.Less, (x, y) => x < y);\n      this.AddFloatBinaryOp(this.GreaterThanOrEquals, (x, y) => x >= y);\n      this.AddFloatBinaryOp(this.LessThanOrEquals, (x, y) => x <= y);\n      this.AddFloatBinaryOp(this.NotEquals, (x, y) => x != y);\n      this.AddFloatUnaryOp(this.Not, (x) => x == 0.0);\n\n      this.AddFloatBinaryOp(this.And, (x, y) => x != 0.0 && y != 0.0);\n      this.AddFloatBinaryOp(this.Or, (x, y) => x != 0.0 || y != 0.0);\n\n      this.AddFloatBinaryOp(this.Max, (x, y) => Math.max(x, y));\n      this.AddFloatBinaryOp(this.Min, (x, y) => Math.min(x, y));\n\n      this.AddFloatBinaryOp(this.Pow, (x, y) => Math.pow(x, y));\n      this.AddFloatUnaryOp(this.Floor, (x) => Math.floor(x));\n      this.AddFloatUnaryOp(this.Ceiling, (x) => Math.ceil(x));\n      this.AddFloatUnaryOp(this.Int, (x) => Math.floor(x));\n      this.AddFloatUnaryOp(this.Float, NativeFunctionCall.Identity);\n\n      // String operations\n      this.AddStringBinaryOp(this.Add, (x, y) => x + y); // concat\n      this.AddStringBinaryOp(this.Equal, (x, y) => x === y);\n      this.AddStringBinaryOp(this.NotEquals, (x, y) => !(x === y));\n      this.AddStringBinaryOp(this.Has, (x, y) => x.includes(y));\n      this.AddStringBinaryOp(this.Hasnt, (x, y) => !x.includes(y));\n\n      this.AddListBinaryOp(this.Add, (x, y) => x.Union(y));\n      this.AddListBinaryOp(this.Subtract, (x, y) => x.Without(y));\n      this.AddListBinaryOp(this.Has, (x, y) => x.Contains(y));\n      this.AddListBinaryOp(this.Hasnt, (x, y) => !x.Contains(y));\n      this.AddListBinaryOp(this.Intersect, (x, y) => x.Intersect(y));\n\n      this.AddListBinaryOp(this.Equal, (x, y) => x.Equals(y));\n      this.AddListBinaryOp(this.Greater, (x, y) => x.GreaterThan(y));\n      this.AddListBinaryOp(this.Less, (x, y) => x.LessThan(y));\n      this.AddListBinaryOp(this.GreaterThanOrEquals, (x, y) =>\n        x.GreaterThanOrEquals(y)\n      );\n      this.AddListBinaryOp(this.LessThanOrEquals, (x, y) =>\n        x.LessThanOrEquals(y)\n      );\n      this.AddListBinaryOp(this.NotEquals, (x, y) => !x.Equals(y));\n\n      this.AddListBinaryOp(this.And, (x, y) => x.Count > 0 && y.Count > 0);\n      this.AddListBinaryOp(this.Or, (x, y) => x.Count > 0 || y.Count > 0);\n\n      this.AddListUnaryOp(this.Not, (x) => (x.Count == 0 ? 1 : 0));\n\n      this.AddListUnaryOp(this.Invert, (x) => x.inverse);\n      this.AddListUnaryOp(this.All, (x) => x.all);\n      this.AddListUnaryOp(this.ListMin, (x) => x.MinAsList());\n      this.AddListUnaryOp(this.ListMax, (x) => x.MaxAsList());\n      this.AddListUnaryOp(this.Count, (x) => x.Count);\n      this.AddListUnaryOp(this.ValueOfList, (x) => x.maxItem.Value);\n\n      let divertTargetsEqual = (d1: Path, d2: Path) => d1.Equals(d2);\n      let divertTargetsNotEqual = (d1: Path, d2: Path) => !d1.Equals(d2);\n      this.AddOpToNativeFunc(\n        this.Equal,\n        2,\n        ValueType.DivertTarget,\n        divertTargetsEqual\n      );\n      this.AddOpToNativeFunc(\n        this.NotEquals,\n        2,\n        ValueType.DivertTarget,\n        divertTargetsNotEqual\n      );\n    }\n  }\n\n  public AddOpFuncForType(\n    valType: ValueType,\n    op: UnaryOp<number | InkList> | BinaryOp<number | string | InkList | Path>\n  ): void {\n    if (this._operationFuncs == null) {\n      this._operationFuncs = new Map();\n    }\n\n    this._operationFuncs.set(valType, op);\n  }\n\n  public static AddOpToNativeFunc(\n    name: string,\n    args: number,\n    valType: ValueType,\n    op: UnaryOp<any> | BinaryOp<any>\n  ): void {\n    if (this._nativeFunctions === null)\n      return throwNullException(\"NativeFunctionCall._nativeFunctions\");\n    let nativeFunc = this._nativeFunctions.get(name);\n    if (!nativeFunc) {\n      nativeFunc = new NativeFunctionCall(name, args);\n      this._nativeFunctions.set(name, nativeFunc);\n    }\n\n    nativeFunc.AddOpFuncForType(valType, op);\n  }\n\n  public static AddIntBinaryOp(name: string, op: BinaryOp<number>) {\n    this.AddOpToNativeFunc(name, 2, ValueType.Int, op);\n  }\n  public static AddIntUnaryOp(name: string, op: UnaryOp<number>) {\n    this.AddOpToNativeFunc(name, 1, ValueType.Int, op);\n  }\n\n  public static AddFloatBinaryOp(name: string, op: BinaryOp<number>) {\n    this.AddOpToNativeFunc(name, 2, ValueType.Float, op);\n  }\n  public static AddFloatUnaryOp(name: string, op: UnaryOp<number>) {\n    this.AddOpToNativeFunc(name, 1, ValueType.Float, op);\n  }\n\n  public static AddStringBinaryOp(name: string, op: BinaryOp<string>) {\n    this.AddOpToNativeFunc(name, 2, ValueType.String, op);\n  }\n\n  public static AddListBinaryOp(name: string, op: BinaryOp<InkList>) {\n    this.AddOpToNativeFunc(name, 2, ValueType.List, op);\n  }\n  public static AddListUnaryOp(name: string, op: UnaryOp<InkList>) {\n    this.AddOpToNativeFunc(name, 1, ValueType.List, op);\n  }\n\n  public toString() {\n    return 'Native \"' + this.name + '\"';\n  }\n\n  public _prototype: NativeFunctionCall | null = null;\n  public _isPrototype: boolean = false;\n  public _operationFuncs: Map<ValueType, BinaryOp<any> | UnaryOp<any>> | null =\n    null;\n  public static _nativeFunctions: Map<string, NativeFunctionCall> | null = null;\n}\n","import { InkObject } from \"./Object\";\n\n// New version of tags is dynamic - it constructs the tags\n// at runtime based on BeginTag and EndTag control commands.\n// Plain text that's in the output stream is turned into tags\n// when you do story.currentTags.\n// The only place this is used is when flattening tags down\n// to string in advance, during dynamic string generation if\n// there's a tag embedded in it. See how ControlCommand.EndString\n// is implemented in Story.cs for more details + comment\nexport class Tag extends InkObject {\n  public readonly text: string;\n\n  constructor(tagText: string) {\n    super();\n    this.text = tagText.toString() || \"\";\n  }\n\n  public toString(): string {\n    return \"# \" + this.text;\n  }\n}\n","import { Path } from \"./Path\";\nimport { CallStack } from \"./CallStack\";\nimport { throwNullException } from \"./NullException\";\nimport { InkObject } from \"./Object\";\n\nexport class Choice extends InkObject {\n  public text: string = \"\";\n  public index: number = 0;\n  public threadAtGeneration: CallStack.Thread | null = null;\n  public sourcePath: string = \"\";\n  public targetPath: Path | null = null;\n  public isInvisibleDefault: boolean = false;\n  public tags: string[] | null = null;\n  public originalThreadIndex: number = 0;\n\n  get pathStringOnChoice(): string {\n    if (this.targetPath === null)\n      return throwNullException(\"Choice.targetPath\");\n    return this.targetPath.toString();\n  }\n  set pathStringOnChoice(value: string) {\n    this.targetPath = new Path(value);\n  }\n}\n","import { InkListItem, SerializedInkListItem } from \"./InkList\";\nimport { TryGetResult } from \"./TryGetResult\";\n\nexport class ListDefinition {\n  public _name: string;\n  public _items: Map<SerializedInkListItem, number> | null;\n  public _itemNameToValues: Map<string, number>;\n\n  constructor(name: string, items: Map<string, number> | null) {\n    this._name = name || \"\";\n    this._items = null;\n    this._itemNameToValues = items || new Map();\n  }\n  get name() {\n    return this._name;\n  }\n  get items() {\n    if (this._items == null) {\n      this._items = new Map();\n      for (let [key, value] of this._itemNameToValues) {\n        let item = new InkListItem(this.name, key);\n        this._items.set(item.serialized(), value);\n      }\n    }\n\n    return this._items;\n  }\n\n  public ValueForItem(item: InkListItem) {\n    if (!item.itemName) return 0;\n\n    let intVal = this._itemNameToValues.get(item.itemName);\n    if (typeof intVal !== \"undefined\") return intVal;\n    else return 0;\n  }\n  public ContainsItem(item: InkListItem) {\n    if (!item.itemName) return false;\n    if (item.originName != this.name) return false;\n\n    return this._itemNameToValues.has(item.itemName);\n  }\n  public ContainsItemWithName(itemName: string) {\n    return this._itemNameToValues.has(itemName);\n  }\n  public TryGetItemWithValue(\n    val: number,\n    /* out */ item: InkListItem\n  ): TryGetResult<InkListItem> {\n    for (let [key, value] of this._itemNameToValues) {\n      if (value == val) {\n        item = new InkListItem(this.name, key);\n        return { result: item, exists: true };\n      }\n    }\n\n    item = InkListItem.Null;\n    return { result: item, exists: false };\n  }\n  public TryGetValueForItem(\n    item: InkListItem,\n    /* out */ intVal: number\n  ): TryGetResult<number> {\n    if (!item.itemName) return { result: 0, exists: false };\n    let value = this._itemNameToValues.get(item.itemName);\n\n    if (!value) return { result: 0, exists: false };\n    return { result: value, exists: true };\n  }\n}\n","import { InkListItem } from \"./InkList\";\nimport { ListValue } from \"./Value\";\nimport { ListDefinition } from \"./ListDefinition\";\nimport { TryGetResult } from \"./TryGetResult\";\nimport { throwNullException } from \"./NullException\";\n\nexport class ListDefinitionsOrigin {\n  protected _lists: Map<string, ListDefinition>;\n  protected _allUnambiguousListValueCache: Map<string, ListValue>;\n\n  constructor(lists: ListDefinition[]) {\n    this._lists = new Map();\n    this._allUnambiguousListValueCache = new Map();\n\n    for (let list of lists) {\n      this._lists.set(list.name, list);\n\n      for (let [key, val] of list.items) {\n        let item = InkListItem.fromSerializedKey(key);\n        let listValue = new ListValue(item, val);\n\n        if (!item.itemName) {\n          throw new Error(\"item.itemName is null or undefined.\");\n        }\n\n        this._allUnambiguousListValueCache.set(item.itemName, listValue);\n        this._allUnambiguousListValueCache.set(item.fullName, listValue);\n      }\n    }\n  }\n  get lists(): ListDefinition[] {\n    let listOfLists: ListDefinition[] = [];\n\n    for (let [, value] of this._lists) {\n      listOfLists.push(value);\n    }\n\n    return listOfLists;\n  }\n  public TryListGetDefinition(\n    name: string | null,\n    /* out */ def: ListDefinition | null\n  ): TryGetResult<ListDefinition | null> {\n    if (name === null) {\n      return { result: def, exists: false };\n    }\n    // initially, this function returns a boolean and the second parameter is an out.\n    let definition = this._lists.get(name);\n    if (!definition) return { result: def, exists: false };\n\n    return { result: definition, exists: true };\n  }\n  public FindSingleItemListWithName(name: string | null) {\n    if (name === null) {\n      return throwNullException(\"name\");\n    }\n    let val = this._allUnambiguousListValueCache.get(name);\n\n    if (typeof val !== \"undefined\") {\n      return val;\n    }\n\n    return null;\n  }\n}\n","import { Container } from \"./Container\";\nimport {\n  Value,\n  IntValue,\n  FloatValue,\n  StringValue,\n  DivertTargetValue,\n  VariablePointerValue,\n  ListValue,\n  BoolValue,\n} from \"./Value\";\nimport { Glue } from \"./Glue\";\nimport { ControlCommand } from \"./ControlCommand\";\nimport { PushPopType } from \"./PushPop\";\nimport { Divert } from \"./Divert\";\nimport { ChoicePoint } from \"./ChoicePoint\";\nimport { VariableReference } from \"./VariableReference\";\nimport { VariableAssignment } from \"./VariableAssignment\";\nimport { NativeFunctionCall } from \"./NativeFunctionCall\";\nimport { Void } from \"./Void\";\nimport { Tag } from \"./Tag\";\nimport { Path } from \"./Path\";\nimport { Choice } from \"./Choice\";\nimport { ListDefinition } from \"./ListDefinition\";\nimport { ListDefinitionsOrigin } from \"./ListDefinitionsOrigin\";\nimport { InkListItem, InkList } from \"./InkList\";\nimport { InkObject } from \"./Object\";\nimport { asOrNull } from \"./TypeAssertion\";\nimport { throwNullException } from \"./NullException\";\nimport { SimpleJson } from \"./SimpleJson\";\n\nexport class JsonSerialisation {\n  public static JArrayToRuntimeObjList(\n    jArray: any[],\n    skipLast: boolean = false\n  ) {\n    let count = jArray.length;\n    if (skipLast) count--;\n\n    let list: InkObject[] = [];\n\n    for (let i = 0; i < count; i++) {\n      let jTok = jArray[i];\n      let runtimeObj = this.JTokenToRuntimeObject(jTok);\n      if (runtimeObj === null) {\n        return throwNullException(\"runtimeObj\");\n      }\n      list.push(runtimeObj);\n    }\n\n    return list;\n  }\n\n  public static WriteDictionaryRuntimeObjs(\n    writer: SimpleJson.Writer,\n    dictionary: Map<string, InkObject>\n  ) {\n    writer.WriteObjectStart();\n    for (let [key, value] of dictionary) {\n      writer.WritePropertyStart(key);\n      this.WriteRuntimeObject(writer, value);\n      writer.WritePropertyEnd();\n    }\n    writer.WriteObjectEnd();\n  }\n\n  public static WriteListRuntimeObjs(\n    writer: SimpleJson.Writer,\n    list: InkObject[]\n  ) {\n    writer.WriteArrayStart();\n    for (let value of list) {\n      this.WriteRuntimeObject(writer, value);\n    }\n    writer.WriteArrayEnd();\n  }\n\n  public static WriteIntDictionary(\n    writer: SimpleJson.Writer,\n    dict: Map<string, number>\n  ) {\n    writer.WriteObjectStart();\n    for (let [key, value] of dict) {\n      writer.WriteIntProperty(key, value);\n    }\n    writer.WriteObjectEnd();\n  }\n\n  public static WriteRuntimeObject(\n    writer: SimpleJson.Writer,\n    obj: InkObject\n  ): void {\n    let container = asOrNull(obj, Container);\n    if (container) {\n      this.WriteRuntimeContainer(writer, container);\n      return;\n    }\n\n    let divert = asOrNull(obj, Divert);\n    if (divert) {\n      let divTypeKey = \"->\";\n      if (divert.isExternal) {\n        divTypeKey = \"x()\";\n      } else if (divert.pushesToStack) {\n        if (divert.stackPushType == PushPopType.Function) {\n          divTypeKey = \"f()\";\n        } else if (divert.stackPushType == PushPopType.Tunnel) {\n          divTypeKey = \"->t->\";\n        }\n      }\n\n      let targetStr;\n      if (divert.hasVariableTarget) {\n        targetStr = divert.variableDivertName;\n      } else {\n        targetStr = divert.targetPathString;\n      }\n\n      writer.WriteObjectStart();\n      writer.WriteProperty(divTypeKey, targetStr);\n\n      if (divert.hasVariableTarget) {\n        writer.WriteProperty(\"var\", true);\n      }\n\n      if (divert.isConditional) {\n        writer.WriteProperty(\"c\", true);\n      }\n\n      if (divert.externalArgs > 0) {\n        writer.WriteIntProperty(\"exArgs\", divert.externalArgs);\n      }\n\n      writer.WriteObjectEnd();\n      return;\n    }\n\n    let choicePoint = asOrNull(obj, ChoicePoint);\n    if (choicePoint) {\n      writer.WriteObjectStart();\n      writer.WriteProperty(\"*\", choicePoint.pathStringOnChoice);\n      writer.WriteIntProperty(\"flg\", choicePoint.flags);\n      writer.WriteObjectEnd();\n      return;\n    }\n\n    let boolVal = asOrNull(obj, BoolValue);\n    if (boolVal) {\n      writer.WriteBool(boolVal.value);\n      return;\n    }\n\n    let intVal = asOrNull(obj, IntValue);\n    if (intVal) {\n      writer.WriteInt(intVal.value);\n      return;\n    }\n\n    let floatVal = asOrNull(obj, FloatValue);\n    if (floatVal) {\n      writer.WriteFloat(floatVal.value);\n      return;\n    }\n\n    let strVal = asOrNull(obj, StringValue);\n    if (strVal) {\n      if (strVal.isNewline) {\n        writer.Write(\"\\n\", false);\n      } else {\n        writer.WriteStringStart();\n        writer.WriteStringInner(\"^\");\n        writer.WriteStringInner(strVal.value);\n        writer.WriteStringEnd();\n      }\n      return;\n    }\n\n    let listVal = asOrNull(obj, ListValue);\n    if (listVal) {\n      this.WriteInkList(writer, listVal);\n      return;\n    }\n\n    let divTargetVal = asOrNull(obj, DivertTargetValue);\n    if (divTargetVal) {\n      writer.WriteObjectStart();\n      if (divTargetVal.value === null) {\n        return throwNullException(\"divTargetVal.value\");\n      }\n      writer.WriteProperty(\"^->\", divTargetVal.value.componentsString);\n      writer.WriteObjectEnd();\n\n      return;\n    }\n\n    let varPtrVal = asOrNull(obj, VariablePointerValue);\n    if (varPtrVal) {\n      writer.WriteObjectStart();\n      writer.WriteProperty(\"^var\", varPtrVal.value);\n      writer.WriteIntProperty(\"ci\", varPtrVal.contextIndex);\n      writer.WriteObjectEnd();\n      return;\n    }\n\n    let glue = asOrNull(obj, Glue);\n    if (glue) {\n      writer.Write(\"<>\");\n      return;\n    }\n\n    let controlCmd = asOrNull(obj, ControlCommand);\n    if (controlCmd) {\n      writer.Write(\n        JsonSerialisation._controlCommandNames[controlCmd.commandType]\n      );\n      return;\n    }\n\n    let nativeFunc = asOrNull(obj, NativeFunctionCall);\n    if (nativeFunc) {\n      let name = nativeFunc.name;\n\n      if (name == \"^\") name = \"L^\";\n\n      writer.Write(name);\n      return;\n    }\n\n    let varRef = asOrNull(obj, VariableReference);\n    if (varRef) {\n      writer.WriteObjectStart();\n      let readCountPath = varRef.pathStringForCount;\n      if (readCountPath != null) {\n        writer.WriteProperty(\"CNT?\", readCountPath);\n      } else {\n        writer.WriteProperty(\"VAR?\", varRef.name);\n      }\n\n      writer.WriteObjectEnd();\n      return;\n    }\n\n    let varAss = asOrNull(obj, VariableAssignment);\n    if (varAss) {\n      writer.WriteObjectStart();\n\n      let key = varAss.isGlobal ? \"VAR=\" : \"temp=\";\n      writer.WriteProperty(key, varAss.variableName);\n\n      // Reassignment?\n      if (!varAss.isNewDeclaration) writer.WriteProperty(\"re\", true);\n\n      writer.WriteObjectEnd();\n\n      return;\n    }\n\n    let voidObj = asOrNull(obj, Void);\n    if (voidObj) {\n      writer.Write(\"void\");\n      return;\n    }\n\n    let tag = asOrNull(obj, Tag);\n    if (tag) {\n      writer.WriteObjectStart();\n      writer.WriteProperty(\"#\", tag.text);\n      writer.WriteObjectEnd();\n      return;\n    }\n\n    let choice = asOrNull(obj, Choice);\n    if (choice) {\n      this.WriteChoice(writer, choice);\n      return;\n    }\n\n    throw new Error(\"Failed to convert runtime object to Json token: \" + obj);\n  }\n\n  public static JObjectToDictionaryRuntimeObjs(jObject: Record<string, any>) {\n    let dict: Map<string, InkObject> = new Map();\n\n    for (let key in jObject) {\n      if (jObject.hasOwnProperty(key)) {\n        let inkObject = this.JTokenToRuntimeObject(jObject[key]);\n        if (inkObject === null) {\n          return throwNullException(\"inkObject\");\n        }\n        dict.set(key, inkObject);\n      }\n    }\n\n    return dict;\n  }\n\n  public static JObjectToIntDictionary(jObject: Record<string, any>) {\n    let dict: Map<string, number> = new Map();\n    for (let key in jObject) {\n      if (jObject.hasOwnProperty(key)) {\n        dict.set(key, parseInt(jObject[key]));\n      }\n    }\n    return dict;\n  }\n\n  public static JTokenToRuntimeObject(token: any): InkObject | null {\n    if (\n      (typeof token === \"number\" && !isNaN(token)) ||\n      typeof token === \"boolean\"\n    ) {\n      return Value.Create(token);\n    }\n\n    if (typeof token === \"string\") {\n      let str = token.toString();\n\n      // String value\n      let firstChar = str[0];\n      if (firstChar == \"^\") return new StringValue(str.substring(1));\n      else if (firstChar == \"\\n\" && str.length == 1)\n        return new StringValue(\"\\n\");\n\n      // Glue\n      if (str == \"<>\") return new Glue();\n\n      // Control commands (would looking up in a hash set be faster?)\n      for (let i = 0; i < JsonSerialisation._controlCommandNames.length; ++i) {\n        let cmdName = JsonSerialisation._controlCommandNames[i];\n        if (str == cmdName) {\n          return new ControlCommand(i);\n        }\n      }\n\n      // Native functions\n      if (str == \"L^\") str = \"^\";\n      if (NativeFunctionCall.CallExistsWithName(str))\n        return NativeFunctionCall.CallWithName(str);\n\n      // Pop\n      if (str == \"->->\") return ControlCommand.PopTunnel();\n      else if (str == \"~ret\") return ControlCommand.PopFunction();\n\n      // Void\n      if (str == \"void\") return new Void();\n    }\n\n    if (typeof token === \"object\" && !Array.isArray(token)) {\n      let obj = token as Record<string, any>;\n      let propValue;\n\n      // Divert target value to path\n      if (obj[\"^->\"]) {\n        propValue = obj[\"^->\"];\n        return new DivertTargetValue(new Path(propValue.toString()));\n      }\n\n      // VariablePointerValue\n      if (obj[\"^var\"]) {\n        propValue = obj[\"^var\"];\n        let varPtr = new VariablePointerValue(propValue.toString());\n        if (\"ci\" in obj) {\n          propValue = obj[\"ci\"];\n          varPtr.contextIndex = parseInt(propValue);\n        }\n        return varPtr;\n      }\n\n      // Divert\n      let isDivert = false;\n      let pushesToStack = false;\n      let divPushType = PushPopType.Function;\n      let external = false;\n      if ((propValue = obj[\"->\"])) {\n        isDivert = true;\n      } else if ((propValue = obj[\"f()\"])) {\n        isDivert = true;\n        pushesToStack = true;\n        divPushType = PushPopType.Function;\n      } else if ((propValue = obj[\"->t->\"])) {\n        isDivert = true;\n        pushesToStack = true;\n        divPushType = PushPopType.Tunnel;\n      } else if ((propValue = obj[\"x()\"])) {\n        isDivert = true;\n        external = true;\n        pushesToStack = false;\n        divPushType = PushPopType.Function;\n      }\n\n      if (isDivert) {\n        let divert = new Divert();\n        divert.pushesToStack = pushesToStack;\n        divert.stackPushType = divPushType;\n        divert.isExternal = external;\n\n        let target = propValue.toString();\n\n        if ((propValue = obj[\"var\"])) divert.variableDivertName = target;\n        else divert.targetPathString = target;\n\n        divert.isConditional = !!obj[\"c\"];\n\n        if (external) {\n          if ((propValue = obj[\"exArgs\"]))\n            divert.externalArgs = parseInt(propValue);\n        }\n\n        return divert;\n      }\n\n      // Choice\n      if ((propValue = obj[\"*\"])) {\n        let choice = new ChoicePoint();\n        choice.pathStringOnChoice = propValue.toString();\n\n        if ((propValue = obj[\"flg\"])) choice.flags = parseInt(propValue);\n\n        return choice;\n      }\n\n      // Variable reference\n      if ((propValue = obj[\"VAR?\"])) {\n        return new VariableReference(propValue.toString());\n      } else if ((propValue = obj[\"CNT?\"])) {\n        let readCountVarRef = new VariableReference();\n        readCountVarRef.pathStringForCount = propValue.toString();\n        return readCountVarRef;\n      }\n\n      // Variable assignment\n      let isVarAss = false;\n      let isGlobalVar = false;\n      if ((propValue = obj[\"VAR=\"])) {\n        isVarAss = true;\n        isGlobalVar = true;\n      } else if ((propValue = obj[\"temp=\"])) {\n        isVarAss = true;\n        isGlobalVar = false;\n      }\n      if (isVarAss) {\n        let varName = propValue.toString();\n        let isNewDecl = !obj[\"re\"];\n        let varAss = new VariableAssignment(varName, isNewDecl);\n        varAss.isGlobal = isGlobalVar;\n        return varAss;\n      }\n      if (obj[\"#\"] !== undefined) {\n        propValue = obj[\"#\"];\n        return new Tag(propValue.toString());\n      }\n\n      // List value\n      if ((propValue = obj[\"list\"])) {\n        // var listContent = (Dictionary<string, object>)propValue;\n        let listContent = propValue as Record<string, any>;\n        let rawList = new InkList();\n        if ((propValue = obj[\"origins\"])) {\n          // var namesAsObjs = (List<object>)propValue;\n          let namesAsObjs = propValue as string[];\n          // rawList.SetInitialOriginNames(namesAsObjs.Cast<string>().ToList());\n          rawList.SetInitialOriginNames(namesAsObjs);\n        }\n\n        for (let key in listContent) {\n          if (listContent.hasOwnProperty(key)) {\n            let nameToVal = listContent[key];\n            let item = new InkListItem(key);\n            let val = parseInt(nameToVal);\n            rawList.Add(item, val);\n          }\n        }\n\n        return new ListValue(rawList);\n      }\n\n      if (obj[\"originalChoicePath\"] != null) return this.JObjectToChoice(obj);\n    }\n\n    // Array is always a Runtime.Container\n    if (Array.isArray(token)) {\n      return this.JArrayToContainer(token);\n    }\n\n    if (token === null || token === undefined) return null;\n\n    throw new Error(\n      \"Failed to convert token to runtime object: \" +\n        this.toJson(token, [\"parent\"])\n    );\n  }\n\n  public static toJson<T>(\n    me: T,\n    removes?: (keyof T)[],\n    space?: number\n  ): string {\n    return JSON.stringify(\n      me,\n      (k, v) => (removes?.some((r) => r === k) ? undefined : v),\n      space\n    );\n  }\n\n  public static WriteRuntimeContainer(\n    writer: SimpleJson.Writer,\n    container: Container | null,\n    withoutName: boolean = false\n  ) {\n    writer.WriteArrayStart();\n    if (container === null) {\n      return throwNullException(\"container\");\n    }\n    for (let c of container.content) this.WriteRuntimeObject(writer, c);\n\n    let namedOnlyContent = container.namedOnlyContent;\n    let countFlags = container.countFlags;\n    let hasNameProperty = container.name != null && !withoutName;\n\n    let hasTerminator =\n      namedOnlyContent != null || countFlags > 0 || hasNameProperty;\n    if (hasTerminator) {\n      writer.WriteObjectStart();\n    }\n\n    if (namedOnlyContent != null) {\n      for (let [key, value] of namedOnlyContent) {\n        let name = key;\n        let namedContainer = asOrNull(value, Container);\n        writer.WritePropertyStart(name);\n        this.WriteRuntimeContainer(writer, namedContainer, true);\n        writer.WritePropertyEnd();\n      }\n    }\n\n    if (countFlags > 0) writer.WriteIntProperty(\"#f\", countFlags);\n\n    if (hasNameProperty) writer.WriteProperty(\"#n\", container.name);\n\n    if (hasTerminator) writer.WriteObjectEnd();\n    else writer.WriteNull();\n\n    writer.WriteArrayEnd();\n  }\n\n  public static JArrayToContainer(jArray: any[]) {\n    let container = new Container();\n    container.content = this.JArrayToRuntimeObjList(jArray, true);\n\n    let terminatingObj = jArray[jArray.length - 1] as Record<string, any>;\n    if (terminatingObj != null) {\n      let namedOnlyContent = new Map();\n\n      for (let key in terminatingObj) {\n        if (key == \"#f\") {\n          container.countFlags = parseInt(terminatingObj[key]);\n        } else if (key == \"#n\") {\n          container.name = terminatingObj[key].toString();\n        } else {\n          let namedContentItem = this.JTokenToRuntimeObject(\n            terminatingObj[key]\n          );\n          // var namedSubContainer = namedContentItem as Container;\n          let namedSubContainer = asOrNull(namedContentItem, Container);\n          if (namedSubContainer) namedSubContainer.name = key;\n          namedOnlyContent.set(key, namedContentItem);\n        }\n      }\n\n      container.namedOnlyContent = namedOnlyContent;\n    }\n\n    return container;\n  }\n\n  public static JObjectToChoice(jObj: Record<string, any>) {\n    let choice = new Choice();\n    choice.text = jObj[\"text\"].toString();\n    choice.index = parseInt(jObj[\"index\"]);\n    choice.sourcePath = jObj[\"originalChoicePath\"].toString();\n    choice.originalThreadIndex = parseInt(jObj[\"originalThreadIndex\"]);\n    choice.pathStringOnChoice = jObj[\"targetPath\"].toString();\n    if (jObj[\"tags\"]) {\n      choice.tags = jObj[\"tags\"];\n    }\n    return choice;\n  }\n\n  public static WriteChoice(writer: SimpleJson.Writer, choice: Choice) {\n    writer.WriteObjectStart();\n    writer.WriteProperty(\"text\", choice.text);\n    writer.WriteIntProperty(\"index\", choice.index);\n    writer.WriteProperty(\"originalChoicePath\", choice.sourcePath);\n    writer.WriteIntProperty(\"originalThreadIndex\", choice.originalThreadIndex);\n    writer.WriteProperty(\"targetPath\", choice.pathStringOnChoice);\n    if (choice.tags) {\n      writer.WriteProperty(\"tags\", (w) => {\n        w.WriteArrayStart();\n        for (const tag of choice.tags!) {\n          w.WriteStringStart();\n          w.WriteStringInner(tag);\n          w.WriteStringEnd();\n        }\n        w.WriteArrayEnd();\n      });\n    }\n    writer.WriteObjectEnd();\n  }\n\n  public static WriteInkList(writer: SimpleJson.Writer, listVal: ListValue) {\n    let rawList = listVal.value;\n    if (rawList === null) {\n      return throwNullException(\"rawList\");\n    }\n\n    writer.WriteObjectStart();\n    writer.WritePropertyStart(\"list\");\n    writer.WriteObjectStart();\n\n    for (let [key, val] of rawList) {\n      let item = InkListItem.fromSerializedKey(key);\n      let itemVal = val;\n\n      if (item.itemName === null) {\n        return throwNullException(\"item.itemName\");\n      }\n\n      writer.WritePropertyNameStart();\n      writer.WritePropertyNameInner(item.originName ? item.originName : \"?\");\n      writer.WritePropertyNameInner(\".\");\n      writer.WritePropertyNameInner(item.itemName);\n      writer.WritePropertyNameEnd();\n\n      writer.Write(itemVal);\n\n      writer.WritePropertyEnd();\n    }\n\n    writer.WriteObjectEnd();\n\n    writer.WritePropertyEnd();\n\n    if (\n      rawList.Count == 0 &&\n      rawList.originNames != null &&\n      rawList.originNames.length > 0\n    ) {\n      writer.WritePropertyStart(\"origins\");\n      writer.WriteArrayStart();\n      for (let name of rawList.originNames) writer.Write(name);\n      writer.WriteArrayEnd();\n      writer.WritePropertyEnd();\n    }\n\n    writer.WriteObjectEnd();\n  }\n\n  public static ListDefinitionsToJToken(origin: ListDefinitionsOrigin) {\n    let result: Record<string, any> = {};\n\n    for (let def of origin.lists) {\n      let listDefJson: Record<string, any> = {};\n\n      for (let [key, val] of def.items) {\n        let item = InkListItem.fromSerializedKey(key);\n        if (item.itemName === null) {\n          return throwNullException(\"item.itemName\");\n        }\n        listDefJson[item.itemName] = val;\n      }\n\n      result[def.name] = listDefJson;\n    }\n\n    return result;\n  }\n\n  public static JTokenToListDefinitions(obj: Record<string, any>) {\n    // var defsObj = (Dictionary<string, object>)obj;\n    let defsObj = obj;\n\n    let allDefs: ListDefinition[] = [];\n\n    for (let key in defsObj) {\n      if (defsObj.hasOwnProperty(key)) {\n        let name = key.toString();\n        // var listDefJson = (Dictionary<string, object>)kv.Value;\n        let listDefJson = defsObj[key] as Record<string, any>;\n\n        // Cast (string, object) to (string, int) for items\n        let items: Map<string, number> = new Map();\n\n        for (let nameValueKey in listDefJson) {\n          if (defsObj.hasOwnProperty(key)) {\n            let nameValue = listDefJson[nameValueKey];\n            items.set(nameValueKey, parseInt(nameValue));\n          }\n        }\n\n        let def = new ListDefinition(name, items);\n        allDefs.push(def);\n      }\n    }\n\n    return new ListDefinitionsOrigin(allDefs);\n  }\n\n  private static _controlCommandNames = (() => {\n    let _controlCommandNames: string[] = [];\n\n    _controlCommandNames[ControlCommand.CommandType.EvalStart] = \"ev\";\n    _controlCommandNames[ControlCommand.CommandType.EvalOutput] = \"out\";\n    _controlCommandNames[ControlCommand.CommandType.EvalEnd] = \"/ev\";\n    _controlCommandNames[ControlCommand.CommandType.Duplicate] = \"du\";\n    _controlCommandNames[ControlCommand.CommandType.PopEvaluatedValue] = \"pop\";\n    _controlCommandNames[ControlCommand.CommandType.PopFunction] = \"~ret\";\n    _controlCommandNames[ControlCommand.CommandType.PopTunnel] = \"->->\";\n    _controlCommandNames[ControlCommand.CommandType.BeginString] = \"str\";\n    _controlCommandNames[ControlCommand.CommandType.EndString] = \"/str\";\n    _controlCommandNames[ControlCommand.CommandType.NoOp] = \"nop\";\n    _controlCommandNames[ControlCommand.CommandType.ChoiceCount] = \"choiceCnt\";\n    _controlCommandNames[ControlCommand.CommandType.Turns] = \"turn\";\n    _controlCommandNames[ControlCommand.CommandType.TurnsSince] = \"turns\";\n    _controlCommandNames[ControlCommand.CommandType.ReadCount] = \"readc\";\n    _controlCommandNames[ControlCommand.CommandType.Random] = \"rnd\";\n    _controlCommandNames[ControlCommand.CommandType.SeedRandom] = \"srnd\";\n    _controlCommandNames[ControlCommand.CommandType.VisitIndex] = \"visit\";\n    _controlCommandNames[ControlCommand.CommandType.SequenceShuffleIndex] =\n      \"seq\";\n    _controlCommandNames[ControlCommand.CommandType.StartThread] = \"thread\";\n    _controlCommandNames[ControlCommand.CommandType.Done] = \"done\";\n    _controlCommandNames[ControlCommand.CommandType.End] = \"end\";\n    _controlCommandNames[ControlCommand.CommandType.ListFromInt] = \"listInt\";\n    _controlCommandNames[ControlCommand.CommandType.ListRange] = \"range\";\n    _controlCommandNames[ControlCommand.CommandType.ListRandom] = \"lrnd\";\n    _controlCommandNames[ControlCommand.CommandType.BeginTag] = \"#\";\n    _controlCommandNames[ControlCommand.CommandType.EndTag] = \"/#\";\n\n    for (let i = 0; i < ControlCommand.CommandType.TOTAL_VALUES; ++i) {\n      if (_controlCommandNames[i] == null)\n        throw new Error(\"Control command not accounted for in serialisation\");\n    }\n\n    return _controlCommandNames;\n  })();\n}\n","import { PushPopType } from \"./PushPop\";\nimport { Path } from \"./Path\";\nimport { Story } from \"./Story\";\nimport { JsonSerialisation } from \"./JsonSerialisation\";\nimport { ListValue } from \"./Value\";\nimport { StringBuilder } from \"./StringBuilder\";\nimport { Pointer } from \"./Pointer\";\nimport { InkObject } from \"./Object\";\nimport { Debug } from \"./Debug\";\nimport { tryGetValueFromMap } from \"./TryGetResult\";\nimport { throwNullException } from \"./NullException\";\nimport { SimpleJson } from \"./SimpleJson\";\n\nexport class CallStack {\n  get elements() {\n    return this.callStack;\n  }\n\n  get depth() {\n    return this.elements.length;\n  }\n\n  get currentElement() {\n    let thread = this._threads[this._threads.length - 1];\n    let cs = thread.callstack;\n    return cs[cs.length - 1];\n  }\n\n  get currentElementIndex() {\n    return this.callStack.length - 1;\n  }\n\n  get currentThread(): CallStack.Thread {\n    return this._threads[this._threads.length - 1];\n  }\n  set currentThread(value: CallStack.Thread) {\n    Debug.Assert(\n      this._threads.length == 1,\n      \"Shouldn't be directly setting the current thread when we have a stack of them\"\n    );\n\n    this._threads.length = 0;\n    this._threads.push(value);\n  }\n\n  get canPop() {\n    return this.callStack.length > 1;\n  }\n\n  constructor(storyContext: Story);\n  constructor(toCopy: CallStack);\n  constructor() {\n    if (arguments[0] instanceof Story) {\n      let storyContext = arguments[0] as Story;\n\n      this._startOfRoot = Pointer.StartOf(storyContext.rootContentContainer);\n      this.Reset();\n    } else {\n      let toCopy = arguments[0] as CallStack;\n\n      this._threads = [];\n      for (let otherThread of toCopy._threads) {\n        this._threads.push(otherThread.Copy());\n      }\n      this._threadCounter = toCopy._threadCounter;\n      this._startOfRoot = toCopy._startOfRoot.copy();\n    }\n  }\n\n  public Reset() {\n    this._threads = [];\n    this._threads.push(new CallStack.Thread());\n\n    this._threads[0].callstack.push(\n      new CallStack.Element(PushPopType.Tunnel, this._startOfRoot)\n    );\n  }\n\n  public SetJsonToken(jObject: Record<string, any>, storyContext: Story) {\n    this._threads.length = 0;\n\n    // TODO: (List<object>) jObject [\"threads\"];\n    let jThreads: any[] = jObject[\"threads\"];\n\n    for (let jThreadTok of jThreads) {\n      // TODO: var jThreadObj = (Dictionary<string, object>)jThreadTok;\n      let jThreadObj = jThreadTok;\n      let thread = new CallStack.Thread(jThreadObj, storyContext);\n      this._threads.push(thread);\n    }\n\n    // TODO: (int)jObject [\"threadCounter\"];\n    this._threadCounter = parseInt(jObject[\"threadCounter\"]);\n    this._startOfRoot = Pointer.StartOf(storyContext.rootContentContainer);\n  }\n  public WriteJson(w: SimpleJson.Writer) {\n    w.WriteObject((writer) => {\n      writer.WritePropertyStart(\"threads\");\n      writer.WriteArrayStart();\n\n      for (let thread of this._threads) {\n        thread.WriteJson(writer);\n      }\n\n      writer.WriteArrayEnd();\n      writer.WritePropertyEnd();\n\n      writer.WritePropertyStart(\"threadCounter\");\n      writer.WriteInt(this._threadCounter);\n      writer.WritePropertyEnd();\n    });\n  }\n\n  public PushThread() {\n    let newThread = this.currentThread.Copy();\n    this._threadCounter++;\n    newThread.threadIndex = this._threadCounter;\n    this._threads.push(newThread);\n  }\n\n  public ForkThread() {\n    let forkedThread = this.currentThread.Copy();\n    this._threadCounter++;\n    forkedThread.threadIndex = this._threadCounter;\n    return forkedThread;\n  }\n\n  public PopThread() {\n    if (this.canPopThread) {\n      this._threads.splice(this._threads.indexOf(this.currentThread), 1); // should be equivalent to a pop()\n    } else {\n      throw new Error(\"Can't pop thread\");\n    }\n  }\n\n  get canPopThread() {\n    return this._threads.length > 1 && !this.elementIsEvaluateFromGame;\n  }\n\n  get elementIsEvaluateFromGame() {\n    return this.currentElement.type == PushPopType.FunctionEvaluationFromGame;\n  }\n\n  public Push(\n    type: PushPopType,\n    externalEvaluationStackHeight: number = 0,\n    outputStreamLengthWithPushed: number = 0\n  ) {\n    let element = new CallStack.Element(\n      type,\n      this.currentElement.currentPointer,\n      false\n    );\n\n    element.evaluationStackHeightWhenPushed = externalEvaluationStackHeight;\n    element.functionStartInOutputStream = outputStreamLengthWithPushed;\n\n    this.callStack.push(element);\n  }\n\n  public CanPop(type: PushPopType | null = null) {\n    if (!this.canPop) return false;\n\n    if (type == null) return true;\n\n    return this.currentElement.type == type;\n  }\n\n  public Pop(type: PushPopType | null = null) {\n    if (this.CanPop(type)) {\n      this.callStack.pop();\n      return;\n    } else {\n      throw new Error(\"Mismatched push/pop in Callstack\");\n    }\n  }\n\n  public GetTemporaryVariableWithName(\n    name: string | null,\n    contextIndex: number = -1\n  ) {\n    if (contextIndex == -1) contextIndex = this.currentElementIndex + 1;\n\n    let contextElement = this.callStack[contextIndex - 1];\n\n    let varValue = tryGetValueFromMap(\n      contextElement.temporaryVariables,\n      name,\n      null\n    );\n    if (varValue.exists) {\n      return varValue.result;\n    } else {\n      return null;\n    }\n  }\n\n  public SetTemporaryVariable(\n    name: string,\n    value: any,\n    declareNew: boolean,\n    contextIndex: number = -1\n  ) {\n    if (contextIndex == -1) contextIndex = this.currentElementIndex + 1;\n\n    let contextElement = this.callStack[contextIndex - 1];\n\n    if (!declareNew && !contextElement.temporaryVariables.get(name)) {\n      throw new Error(\"Could not find temporary variable to set: \" + name);\n    }\n\n    let oldValue = tryGetValueFromMap(\n      contextElement.temporaryVariables,\n      name,\n      null\n    );\n    if (oldValue.exists)\n      ListValue.RetainListOriginsForAssignment(oldValue.result, value);\n\n    contextElement.temporaryVariables.set(name, value);\n  }\n\n  public ContextForVariableNamed(name: string) {\n    if (this.currentElement.temporaryVariables.get(name)) {\n      return this.currentElementIndex + 1;\n    } else {\n      return 0;\n    }\n  }\n\n  public ThreadWithIndex(index: number) {\n    let filtered = this._threads.filter((t) => {\n      if (t.threadIndex == index) return t;\n    });\n\n    return filtered.length > 0 ? filtered[0] : null;\n  }\n\n  get callStack() {\n    return this.currentThread.callstack;\n  }\n\n  get callStackTrace() {\n    let sb = new StringBuilder();\n\n    for (let t = 0; t < this._threads.length; t++) {\n      let thread = this._threads[t];\n      let isCurrent = t == this._threads.length - 1;\n      sb.AppendFormat(\n        \"=== THREAD {0}/{1} {2}===\\n\",\n        t + 1,\n        this._threads.length,\n        isCurrent ? \"(current) \" : \"\"\n      );\n\n      for (let i = 0; i < thread.callstack.length; i++) {\n        if (thread.callstack[i].type == PushPopType.Function)\n          sb.Append(\"  [FUNCTION] \");\n        else sb.Append(\"  [TUNNEL] \");\n\n        let pointer = thread.callstack[i].currentPointer;\n        if (!pointer.isNull) {\n          sb.Append(\"<SOMEWHERE IN \");\n          if (pointer.container === null) {\n            return throwNullException(\"pointer.container\");\n          }\n          sb.Append(pointer.container.path.toString());\n          sb.AppendLine(\">\");\n        }\n      }\n    }\n\n    return sb.toString();\n  }\n\n  public _threads!: CallStack.Thread[]; // Banged because it's initialized in Reset().\n  public _threadCounter: number = 0;\n  public _startOfRoot: Pointer = Pointer.Null;\n}\n\nexport namespace CallStack {\n  export class Element {\n    public currentPointer: Pointer;\n    public inExpressionEvaluation: boolean;\n    public temporaryVariables: Map<string, InkObject>;\n    public type: PushPopType;\n\n    public evaluationStackHeightWhenPushed: number = 0;\n    public functionStartInOutputStream: number = 0;\n\n    constructor(\n      type: PushPopType,\n      pointer: Pointer,\n      inExpressionEvaluation: boolean = false\n    ) {\n      this.currentPointer = pointer.copy();\n      this.inExpressionEvaluation = inExpressionEvaluation;\n      this.temporaryVariables = new Map();\n      this.type = type;\n    }\n\n    public Copy() {\n      let copy = new Element(\n        this.type,\n        this.currentPointer,\n        this.inExpressionEvaluation\n      );\n      copy.temporaryVariables = new Map(this.temporaryVariables);\n      copy.evaluationStackHeightWhenPushed =\n        this.evaluationStackHeightWhenPushed;\n      copy.functionStartInOutputStream = this.functionStartInOutputStream;\n      return copy;\n    }\n  }\n\n  export class Thread {\n    public callstack: Element[];\n    public threadIndex: number = 0;\n    public previousPointer: Pointer = Pointer.Null;\n\n    constructor();\n    constructor(jThreadObj: any, storyContext: Story);\n    constructor() {\n      this.callstack = [];\n\n      if (arguments[0] && arguments[1]) {\n        let jThreadObj = arguments[0];\n        let storyContext = arguments[1];\n\n        // TODO: (int) jThreadObj['threadIndex'] can raise;\n        this.threadIndex = parseInt(jThreadObj[\"threadIndex\"]);\n\n        let jThreadCallstack = jThreadObj[\"callstack\"];\n\n        for (let jElTok of jThreadCallstack) {\n          let jElementObj = jElTok;\n\n          // TODO: (int) jElementObj['type'] can raise;\n          let pushPopType: PushPopType = parseInt(jElementObj[\"type\"]);\n\n          let pointer = Pointer.Null;\n\n          let currentContainerPathStr: string;\n          // TODO: jElementObj.TryGetValue (\"cPath\", out currentContainerPathStrToken);\n          let currentContainerPathStrToken = jElementObj[\"cPath\"];\n          if (typeof currentContainerPathStrToken !== \"undefined\") {\n            currentContainerPathStr = currentContainerPathStrToken.toString();\n\n            let threadPointerResult = storyContext.ContentAtPath(\n              new Path(currentContainerPathStr)\n            );\n            pointer.container = threadPointerResult.container;\n            pointer.index = parseInt(jElementObj[\"idx\"]);\n\n            if (threadPointerResult.obj == null)\n              throw new Error(\n                \"When loading state, internal story location couldn't be found: \" +\n                  currentContainerPathStr +\n                  \". Has the story changed since this save data was created?\"\n              );\n            else if (threadPointerResult.approximate) {\n              if (pointer.container === null) {\n                return throwNullException(\"pointer.container\");\n              }\n              storyContext.Warning(\n                \"When loading state, exact internal story location couldn't be found: '\" +\n                  currentContainerPathStr +\n                  \"', so it was approximated to '\" +\n                  pointer.container.path.toString() +\n                  \"' to recover. Has the story changed since this save data was created?\"\n              );\n            }\n          }\n\n          let inExpressionEvaluation = !!jElementObj[\"exp\"];\n\n          let el = new Element(pushPopType, pointer, inExpressionEvaluation);\n\n          let temps = jElementObj[\"temp\"];\n          if (typeof temps !== \"undefined\") {\n            el.temporaryVariables =\n              JsonSerialisation.JObjectToDictionaryRuntimeObjs(temps);\n          } else {\n            el.temporaryVariables.clear();\n          }\n\n          this.callstack.push(el);\n        }\n\n        let prevContentObjPath = jThreadObj[\"previousContentObject\"];\n        if (typeof prevContentObjPath !== \"undefined\") {\n          let prevPath = new Path(prevContentObjPath.toString());\n          this.previousPointer = storyContext.PointerAtPath(prevPath);\n        }\n      }\n    }\n\n    public Copy() {\n      let copy = new Thread();\n      copy.threadIndex = this.threadIndex;\n      for (let e of this.callstack) {\n        copy.callstack.push(e.Copy());\n      }\n      copy.previousPointer = this.previousPointer.copy();\n      return copy;\n    }\n\n    public WriteJson(writer: SimpleJson.Writer) {\n      writer.WriteObjectStart();\n\n      writer.WritePropertyStart(\"callstack\");\n      writer.WriteArrayStart();\n      for (let el of this.callstack) {\n        writer.WriteObjectStart();\n        if (!el.currentPointer.isNull) {\n          if (el.currentPointer.container === null) {\n            return throwNullException(\"el.currentPointer.container\");\n          }\n          writer.WriteProperty(\n            \"cPath\",\n            el.currentPointer.container.path.componentsString\n          );\n          writer.WriteIntProperty(\"idx\", el.currentPointer.index);\n        }\n\n        writer.WriteProperty(\"exp\", el.inExpressionEvaluation);\n        writer.WriteIntProperty(\"type\", el.type);\n\n        if (el.temporaryVariables.size > 0) {\n          writer.WritePropertyStart(\"temp\");\n          JsonSerialisation.WriteDictionaryRuntimeObjs(\n            writer,\n            el.temporaryVariables\n          );\n          writer.WritePropertyEnd();\n        }\n\n        writer.WriteObjectEnd();\n      }\n      writer.WriteArrayEnd();\n      writer.WritePropertyEnd();\n\n      writer.WriteIntProperty(\"threadIndex\", this.threadIndex);\n\n      if (!this.previousPointer.isNull) {\n        let resolvedPointer = this.previousPointer.Resolve();\n        if (resolvedPointer === null) {\n          return throwNullException(\"this.previousPointer.Resolve()\");\n        }\n        writer.WriteProperty(\n          \"previousContentObject\",\n          resolvedPointer.path.toString()\n        );\n      }\n\n      writer.WriteObjectEnd();\n    }\n  }\n}\n","import {\n  AbstractValue,\n  Value,\n  VariablePointerValue,\n  ListValue,\n  IntValue,\n  FloatValue,\n  BoolValue,\n} from \"./Value\";\nimport { VariableAssignment } from \"./VariableAssignment\";\nimport { InkObject } from \"./Object\";\nimport { ListDefinitionsOrigin } from \"./ListDefinitionsOrigin\";\nimport { StoryException } from \"./StoryException\";\nimport { JsonSerialisation } from \"./JsonSerialisation\";\nimport { asOrThrows, asOrNull, isEquatable } from \"./TypeAssertion\";\nimport { tryGetValueFromMap } from \"./TryGetResult\";\nimport { throwNullException } from \"./NullException\";\nimport { CallStack } from \"./CallStack\";\nimport { StatePatch } from \"./StatePatch\";\nimport { SimpleJson } from \"./SimpleJson\";\nimport { InkList } from \"./Story\";\nimport { Path } from \"./Path\";\n\n// Fake class wrapper around VariableState to have correct typing\n// when using the Proxy syntax in typescript\nfunction VariablesStateAccessor<T>(): new () => Pick<T, keyof T> {\n  return class {} as any;\n}\n\ntype VariableStateValue = boolean | string | number | InkList | Path | null;\n\nexport class VariablesState extends VariablesStateAccessor<\n  Record<string, any>\n>() {\n  // The way variableChangedEvent is a bit different than the reference implementation.\n  // Originally it uses the C# += operator to add delegates, but in js we need to maintain\n  // an actual collection of delegates (ie. callbacks) to register a new one, there is a\n  // special ObserveVariableChange method below.\n  public variableChangedEventCallbacks: Array<\n    (variableName: string, newValue: InkObject) => void\n  > = [];\n  public variableChangedEvent(variableName: string, newValue: InkObject): void {\n    for (let callback of this.variableChangedEventCallbacks) {\n      callback(variableName, newValue);\n    }\n  }\n\n  public patch: StatePatch | null = null;\n\n  get batchObservingVariableChanges() {\n    return this._batchObservingVariableChanges;\n  }\n  set batchObservingVariableChanges(value: boolean) {\n    this._batchObservingVariableChanges = value;\n    if (value) {\n      this._changedVariablesForBatchObs = new Set();\n    } else {\n      if (this._changedVariablesForBatchObs != null) {\n        for (let variableName of this._changedVariablesForBatchObs) {\n          let currentValue = this._globalVariables.get(variableName);\n          if (!currentValue) {\n            throwNullException(\"currentValue\");\n          } else {\n            this.variableChangedEvent(variableName, currentValue);\n          }\n        }\n\n        this._changedVariablesForBatchObs = null;\n      }\n    }\n  }\n\n  get callStack() {\n    return this._callStack;\n  }\n  set callStack(callStack) {\n    this._callStack = callStack;\n  }\n\n  private _batchObservingVariableChanges: boolean = false;\n\n  // the original code uses a magic getter and setter for global variables,\n  // allowing things like variableState['varname]. This is not quite possible\n  // in js without a Proxy, so it is replaced with this $ function.\n  public $(variableName: string): VariableStateValue;\n  public $(variableName: string, value: VariableStateValue): void;\n  public $(variableName: string, value?: any) {\n    if (typeof value === \"undefined\") {\n      let varContents = null;\n\n      if (this.patch !== null) {\n        varContents = this.patch.TryGetGlobal(variableName, null);\n        if (varContents.exists)\n          return (varContents.result as AbstractValue).valueObject;\n      }\n\n      varContents = this._globalVariables.get(variableName);\n\n      if (typeof varContents === \"undefined\") {\n        varContents = this._defaultGlobalVariables.get(variableName);\n      }\n\n      if (typeof varContents !== \"undefined\")\n        return (varContents as AbstractValue).valueObject;\n      else return null;\n    } else {\n      if (typeof this._defaultGlobalVariables.get(variableName) === \"undefined\")\n        throw new StoryException(\n          \"Cannot assign to a variable (\" +\n            variableName +\n            \") that hasn't been declared in the story\"\n        );\n\n      let val = Value.Create(value);\n      if (val == null) {\n        if (value == null) {\n          throw new Error(\"Cannot pass null to VariableState\");\n        } else {\n          throw new Error(\n            \"Invalid value passed to VariableState: \" + value.toString()\n          );\n        }\n      }\n\n      this.SetGlobal(variableName, val);\n    }\n  }\n\n  constructor(\n    callStack: CallStack,\n    listDefsOrigin: ListDefinitionsOrigin | null\n  ) {\n    super();\n    this._globalVariables = new Map();\n    this._callStack = callStack;\n    this._listDefsOrigin = listDefsOrigin;\n\n    // if es6 proxies are available, use them.\n    try {\n      // the proxy is used to allow direct manipulation of global variables.\n      // It first tries to access the objects own property, and if none is\n      // found it delegates the call to the $ method, defined below\n      let p = new Proxy(this, {\n        get(target: any, name) {\n          return name in target ? target[name] : target.$(name);\n        },\n        set(target: any, name, value) {\n          if (name in target) target[name] = value;\n          else target.$(name, value);\n          return true; // returning a falsy value make the trap fail\n        },\n      });\n\n      return p;\n    } catch (e) {\n      // the proxy object is not available in this context. we should warn the\n      // dev but writing to the console feels a bit intrusive.\n      // console.log(\"ES6 Proxy not available - direct manipulation of global variables can't work, use $() instead.\");\n    }\n  }\n\n  public ApplyPatch() {\n    if (this.patch === null) {\n      return throwNullException(\"this.patch\");\n    }\n\n    for (let [namedVarKey, namedVarValue] of this.patch.globals) {\n      this._globalVariables.set(namedVarKey, namedVarValue);\n    }\n\n    if (this._changedVariablesForBatchObs !== null) {\n      for (let name of this.patch.changedVariables) {\n        this._changedVariablesForBatchObs.add(name);\n      }\n    }\n\n    this.patch = null;\n  }\n\n  public SetJsonToken(jToken: Record<string, any>) {\n    this._globalVariables.clear();\n\n    for (let [varValKey, varValValue] of this._defaultGlobalVariables) {\n      let loadedToken = jToken[varValKey];\n      if (typeof loadedToken !== \"undefined\") {\n        let tokenInkObject =\n          JsonSerialisation.JTokenToRuntimeObject(loadedToken);\n        if (tokenInkObject === null) {\n          return throwNullException(\"tokenInkObject\");\n        }\n        this._globalVariables.set(varValKey, tokenInkObject);\n      } else {\n        this._globalVariables.set(varValKey, varValValue);\n      }\n    }\n  }\n\n  public static dontSaveDefaultValues: boolean = true;\n\n  public WriteJson(writer: SimpleJson.Writer) {\n    writer.WriteObjectStart();\n    for (let [keyValKey, keyValValue] of this._globalVariables) {\n      let name = keyValKey;\n      let val = keyValValue;\n\n      if (VariablesState.dontSaveDefaultValues) {\n        if (this._defaultGlobalVariables.has(name)) {\n          let defaultVal = this._defaultGlobalVariables.get(name)!;\n          if (this.RuntimeObjectsEqual(val, defaultVal)) continue;\n        }\n      }\n\n      writer.WritePropertyStart(name);\n      JsonSerialisation.WriteRuntimeObject(writer, val);\n      writer.WritePropertyEnd();\n    }\n    writer.WriteObjectEnd();\n  }\n\n  public RuntimeObjectsEqual(\n    obj1: InkObject | null,\n    obj2: InkObject | null\n  ): boolean {\n    if (obj1 === null) {\n      return throwNullException(\"obj1\");\n    }\n    if (obj2 === null) {\n      return throwNullException(\"obj2\");\n    }\n\n    if (obj1.constructor !== obj2.constructor) return false;\n\n    let boolVal = asOrNull(obj1, BoolValue);\n    if (boolVal !== null) {\n      return boolVal.value === asOrThrows(obj2, BoolValue).value;\n    }\n\n    let intVal = asOrNull(obj1, IntValue);\n    if (intVal !== null) {\n      return intVal.value === asOrThrows(obj2, IntValue).value;\n    }\n\n    let floatVal = asOrNull(obj1, FloatValue);\n    if (floatVal !== null) {\n      return floatVal.value === asOrThrows(obj2, FloatValue).value;\n    }\n\n    let val1 = asOrNull(obj1, Value);\n    let val2 = asOrNull(obj2, Value);\n    if (val1 !== null && val2 !== null) {\n      if (isEquatable(val1.valueObject) && isEquatable(val2.valueObject)) {\n        return val1.valueObject.Equals(val2.valueObject);\n      } else {\n        return val1.valueObject === val2.valueObject;\n      }\n    }\n\n    throw new Error(\n      \"FastRoughDefinitelyEquals: Unsupported runtime object type: \" +\n        obj1.constructor.name\n    );\n  }\n\n  public GetVariableWithName(\n    name: string | null,\n    contextIndex: number = -1\n  ): InkObject | null {\n    let varValue = this.GetRawVariableWithName(name, contextIndex);\n\n    // var varPointer = varValue as VariablePointerValue;\n    let varPointer = asOrNull(varValue, VariablePointerValue);\n    if (varPointer !== null) {\n      varValue = this.ValueAtVariablePointer(varPointer);\n    }\n\n    return varValue;\n  }\n\n  public TryGetDefaultVariableValue(name: string | null): InkObject | null {\n    let val = tryGetValueFromMap(this._defaultGlobalVariables, name, null);\n    return val.exists ? val.result : null;\n  }\n\n  public GlobalVariableExistsWithName(name: string) {\n    return (\n      this._globalVariables.has(name) ||\n      (this._defaultGlobalVariables !== null &&\n        this._defaultGlobalVariables.has(name))\n    );\n  }\n\n  public GetRawVariableWithName(name: string | null, contextIndex: number) {\n    let varValue: InkObject | null = null;\n\n    if (contextIndex == 0 || contextIndex == -1) {\n      let variableValue = null;\n      if (this.patch !== null) {\n        variableValue = this.patch.TryGetGlobal(name, null);\n        if (variableValue.exists) return variableValue.result!;\n      }\n\n      // this is a conditional assignment\n      variableValue = tryGetValueFromMap(this._globalVariables, name, null);\n      if (variableValue.exists) return variableValue.result;\n\n      if (this._defaultGlobalVariables !== null) {\n        variableValue = tryGetValueFromMap(\n          this._defaultGlobalVariables,\n          name,\n          null\n        );\n        if (variableValue.exists) return variableValue.result;\n      }\n\n      if (this._listDefsOrigin === null)\n        return throwNullException(\"VariablesState._listDefsOrigin\");\n      let listItemValue = this._listDefsOrigin.FindSingleItemListWithName(name);\n      if (listItemValue) return listItemValue;\n    }\n\n    varValue = this._callStack.GetTemporaryVariableWithName(name, contextIndex);\n\n    return varValue;\n  }\n\n  public ValueAtVariablePointer(pointer: VariablePointerValue) {\n    return this.GetVariableWithName(pointer.variableName, pointer.contextIndex);\n  }\n\n  public Assign(varAss: VariableAssignment, value: InkObject) {\n    let name = varAss.variableName;\n    if (name === null) {\n      return throwNullException(\"name\");\n    }\n    let contextIndex = -1;\n\n    let setGlobal = false;\n    if (varAss.isNewDeclaration) {\n      setGlobal = varAss.isGlobal;\n    } else {\n      setGlobal = this.GlobalVariableExistsWithName(name);\n    }\n\n    if (varAss.isNewDeclaration) {\n      // var varPointer = value as VariablePointerValue;\n      let varPointer = asOrNull(value, VariablePointerValue);\n      if (varPointer !== null) {\n        let fullyResolvedVariablePointer =\n          this.ResolveVariablePointer(varPointer);\n        value = fullyResolvedVariablePointer;\n      }\n    } else {\n      let existingPointer = null;\n      do {\n        // existingPointer = GetRawVariableWithName (name, contextIndex) as VariablePointerValue;\n        existingPointer = asOrNull(\n          this.GetRawVariableWithName(name, contextIndex),\n          VariablePointerValue\n        );\n        if (existingPointer != null) {\n          name = existingPointer.variableName;\n          contextIndex = existingPointer.contextIndex;\n          setGlobal = contextIndex == 0;\n        }\n      } while (existingPointer != null);\n    }\n\n    if (setGlobal) {\n      this.SetGlobal(name, value);\n    } else {\n      this._callStack.SetTemporaryVariable(\n        name,\n        value,\n        varAss.isNewDeclaration,\n        contextIndex\n      );\n    }\n  }\n\n  public SnapshotDefaultGlobals() {\n    this._defaultGlobalVariables = new Map(this._globalVariables);\n  }\n\n  public RetainListOriginsForAssignment(\n    oldValue: InkObject,\n    newValue: InkObject\n  ) {\n    let oldList = asOrThrows(oldValue, ListValue);\n    let newList = asOrThrows(newValue, ListValue);\n\n    if (oldList.value && newList.value && newList.value.Count == 0) {\n      newList.value.SetInitialOriginNames(oldList.value.originNames);\n    }\n  }\n\n  public SetGlobal(variableName: string | null, value: InkObject) {\n    let oldValue = null;\n\n    if (this.patch === null) {\n      oldValue = tryGetValueFromMap(this._globalVariables, variableName, null);\n    }\n\n    if (this.patch !== null) {\n      oldValue = this.patch.TryGetGlobal(variableName, null);\n      if (!oldValue.exists) {\n        oldValue = tryGetValueFromMap(\n          this._globalVariables,\n          variableName,\n          null\n        );\n      }\n    }\n\n    ListValue.RetainListOriginsForAssignment(oldValue!.result!, value);\n\n    if (variableName === null) {\n      return throwNullException(\"variableName\");\n    }\n\n    if (this.patch !== null) {\n      this.patch.SetGlobal(variableName, value);\n    } else {\n      this._globalVariables.set(variableName, value);\n    }\n\n    // TODO: Not sure !== is equivalent to !value.Equals(oldValue)\n    if (\n      this.variableChangedEvent !== null &&\n      oldValue !== null &&\n      value !== oldValue.result\n    ) {\n      if (this.batchObservingVariableChanges) {\n        if (this._changedVariablesForBatchObs === null) {\n          return throwNullException(\"this._changedVariablesForBatchObs\");\n        }\n\n        if (this.patch !== null) {\n          this.patch.AddChangedVariable(variableName);\n        } else if (this._changedVariablesForBatchObs !== null) {\n          this._changedVariablesForBatchObs.add(variableName);\n        }\n      } else {\n        this.variableChangedEvent(variableName, value);\n      }\n    }\n  }\n\n  public ResolveVariablePointer(varPointer: VariablePointerValue) {\n    let contextIndex = varPointer.contextIndex;\n\n    if (contextIndex == -1)\n      contextIndex = this.GetContextIndexOfVariableNamed(\n        varPointer.variableName\n      );\n\n    let valueOfVariablePointedTo = this.GetRawVariableWithName(\n      varPointer.variableName,\n      contextIndex\n    );\n\n    // var doubleRedirectionPointer = valueOfVariablePointedTo as VariablePointerValue;\n    let doubleRedirectionPointer = asOrNull(\n      valueOfVariablePointedTo,\n      VariablePointerValue\n    );\n    if (doubleRedirectionPointer != null) {\n      return doubleRedirectionPointer;\n    } else {\n      return new VariablePointerValue(varPointer.variableName, contextIndex);\n    }\n  }\n\n  public GetContextIndexOfVariableNamed(varName: string) {\n    if (this.GlobalVariableExistsWithName(varName)) return 0;\n\n    return this._callStack.currentElementIndex;\n  }\n\n  /**\n   * This function is specific to the js version of ink. It allows to register a\n   * callback that will be called when a variable changes. The original code uses\n   * `state.variableChangedEvent += callback` instead.\n   *\n   * @param {function} callback\n   */\n  public ObserveVariableChange(\n    callback: (variableName: string, newValue: InkObject) => void\n  ) {\n    this.variableChangedEventCallbacks.push(callback);\n  }\n\n  private _globalVariables: Map<string, InkObject>;\n  private _defaultGlobalVariables: Map<string, InkObject> = new Map();\n\n  private _callStack: CallStack;\n  private _changedVariablesForBatchObs: Set<string> | null = new Set();\n  private _listDefsOrigin: ListDefinitionsOrigin | null;\n}\n","// Taken from https://gist.github.com/blixt/f17b47c62508be59987b\n// Ink uses a seedable PRNG of which there is none in native javascript.\nexport class PRNG {\n  private seed: number;\n\n  constructor(seed: number) {\n    this.seed = seed % 2147483647;\n    if (this.seed <= 0) this.seed += 2147483646;\n  }\n  public next(): number {\n    return (this.seed = (this.seed * 48271) % 2147483647);\n  }\n  public nextFloat(): number {\n    return (this.next() - 1) / 2147483646;\n  }\n}\n","import { InkObject } from \"./Object\";\nimport { Container } from \"./Container\";\n\nexport class StatePatch {\n  get globals() {\n    return this._globals;\n  }\n  get changedVariables() {\n    return this._changedVariables;\n  }\n  get visitCounts() {\n    return this._visitCounts;\n  }\n  get turnIndices() {\n    return this._turnIndices;\n  }\n\n  constructor();\n  constructor(toCopy: StatePatch | null);\n  constructor() {\n    if (arguments.length === 1 && arguments[0] !== null) {\n      let toCopy = arguments[0] as StatePatch;\n      this._globals = new Map(toCopy._globals);\n      this._changedVariables = new Set(toCopy._changedVariables);\n      this._visitCounts = new Map(toCopy._visitCounts);\n      this._turnIndices = new Map(toCopy._turnIndices);\n    } else {\n      this._globals = new Map();\n      this._changedVariables = new Set();\n      this._visitCounts = new Map();\n      this._turnIndices = new Map();\n    }\n  }\n\n  public TryGetGlobal(name: string | null, /* out */ value: InkObject | null) {\n    if (name !== null && this._globals.has(name)) {\n      return { result: this._globals.get(name), exists: true };\n    }\n\n    return { result: value, exists: false };\n  }\n\n  public SetGlobal(name: string, value: InkObject) {\n    this._globals.set(name, value);\n  }\n\n  public AddChangedVariable(name: string) {\n    return this._changedVariables.add(name);\n  }\n\n  public TryGetVisitCount(container: Container, /* out */ count: number) {\n    if (this._visitCounts.has(container)) {\n      return { result: this._visitCounts.get(container), exists: true };\n    }\n\n    return { result: count, exists: false };\n  }\n\n  public SetVisitCount(container: Container, count: number) {\n    this._visitCounts.set(container, count);\n  }\n\n  public SetTurnIndex(container: Container, index: number) {\n    this._turnIndices.set(container, index);\n  }\n\n  public TryGetTurnIndex(container: Container, /* out */ index: number) {\n    if (this._turnIndices.has(container)) {\n      return { result: this._turnIndices.get(container), exists: true };\n    }\n\n    return { result: index, exists: false };\n  }\n\n  private _globals: Map<string, InkObject>;\n  private _changedVariables: Set<string> = new Set();\n  private _visitCounts: Map<Container, number> = new Map();\n  private _turnIndices: Map<Container, number> = new Map();\n}\n","export class SimpleJson {\n  public static TextToDictionary(text: string) {\n    return new SimpleJson.Reader(text).ToDictionary();\n  }\n\n  public static TextToArray(text: string) {\n    return new SimpleJson.Reader(text).ToArray();\n  }\n}\n\nexport namespace SimpleJson {\n  export class Reader {\n    constructor(text: string) {\n      this._rootObject = JSON.parse(text);\n    }\n\n    public ToDictionary() {\n      return this._rootObject as Record<string, any>;\n    }\n\n    public ToArray() {\n      return this._rootObject as any[];\n    }\n\n    private _rootObject: any[] | Record<string, any>;\n  }\n\n  // In C#, this class writes json tokens directly to a StringWriter or\n  // another stream. Here, a temporary hierarchy is created in the form\n  // of a javascript object, which is serialised in the `toString` method.\n  // See individual methods and properties for more information.\n  export class Writer {\n    public WriteObject(inner: (w: Writer) => void) {\n      this.WriteObjectStart();\n      inner(this);\n      this.WriteObjectEnd();\n    }\n\n    // Add a new object.\n    public WriteObjectStart() {\n      this.StartNewObject(true);\n\n      let newObject: Record<string, any> = {};\n\n      if (this.state === SimpleJson.Writer.State.Property) {\n        // This object is created as the value of a property,\n        // inside an other object.\n        this.Assert(this.currentCollection !== null);\n        this.Assert(this.currentPropertyName !== null);\n\n        let propertyName = this._propertyNameStack.pop();\n        this.currentCollection![propertyName!] = newObject;\n        this._collectionStack.push(newObject);\n      } else if (this.state === SimpleJson.Writer.State.Array) {\n        // This object is created as the child of an array.\n        this.Assert(this.currentCollection !== null);\n\n        this.currentCollection!.push(newObject);\n        this._collectionStack.push(newObject);\n      } else {\n        // This object is the root object.\n        this.Assert(this.state === SimpleJson.Writer.State.None);\n        this._jsonObject = newObject;\n        this._collectionStack.push(newObject);\n      }\n\n      this._stateStack.push(\n        new SimpleJson.Writer.StateElement(SimpleJson.Writer.State.Object)\n      );\n    }\n\n    public WriteObjectEnd() {\n      this.Assert(this.state === SimpleJson.Writer.State.Object);\n      this._collectionStack.pop();\n      this._stateStack.pop();\n    }\n\n    // Write a property name / value pair to the current object.\n    public WriteProperty(\n      name: any,\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      innerOrContent: ((w: Writer) => void) | string | boolean | null\n    ) {\n      this.WritePropertyStart(name);\n      if (arguments[1] instanceof Function) {\n        let inner = arguments[1];\n        inner(this);\n      } else {\n        let content: string | boolean | null = arguments[1];\n        this.Write(content);\n      }\n      this.WritePropertyEnd();\n    }\n\n    // Int and Float are separate calls, since there both are\n    // numbers in JavaScript, but need to be handled differently.\n\n    public WriteIntProperty(name: any, content: number) {\n      this.WritePropertyStart(name);\n      this.WriteInt(content);\n      this.WritePropertyEnd();\n    }\n\n    public WriteFloatProperty(name: any, content: number) {\n      this.WritePropertyStart(name);\n      this.WriteFloat(content);\n      this.WritePropertyEnd();\n    }\n\n    // Prepare a new property name, which will be use to add the\n    // new object when calling _addToCurrentObject() from a Write\n    // method.\n    public WritePropertyStart(name: any) {\n      this.Assert(this.state === SimpleJson.Writer.State.Object);\n      this._propertyNameStack.push(name);\n\n      this.IncrementChildCount();\n\n      this._stateStack.push(\n        new SimpleJson.Writer.StateElement(SimpleJson.Writer.State.Property)\n      );\n    }\n\n    public WritePropertyEnd() {\n      this.Assert(this.state === SimpleJson.Writer.State.Property);\n      this.Assert(this.childCount === 1);\n      this._stateStack.pop();\n    }\n\n    // Prepare a new property name, except this time, the property name\n    // will be created by concatenating all the strings passed to\n    // WritePropertyNameInner.\n    public WritePropertyNameStart() {\n      this.Assert(this.state === SimpleJson.Writer.State.Object);\n      this.IncrementChildCount();\n\n      this._currentPropertyName = \"\";\n\n      this._stateStack.push(\n        new SimpleJson.Writer.StateElement(SimpleJson.Writer.State.Property)\n      );\n      this._stateStack.push(\n        new SimpleJson.Writer.StateElement(SimpleJson.Writer.State.PropertyName)\n      );\n    }\n\n    public WritePropertyNameEnd() {\n      this.Assert(this.state === SimpleJson.Writer.State.PropertyName);\n      this.Assert(this._currentPropertyName !== null);\n      this._propertyNameStack.push(this._currentPropertyName!);\n      this._currentPropertyName = null;\n      this._stateStack.pop();\n    }\n\n    public WritePropertyNameInner(str: string) {\n      this.Assert(this.state === SimpleJson.Writer.State.PropertyName);\n      this.Assert(this._currentPropertyName !== null);\n      this._currentPropertyName += str;\n    }\n\n    // Add a new array.\n    public WriteArrayStart() {\n      this.StartNewObject(true);\n\n      let newObject: any[] = [];\n\n      if (this.state === SimpleJson.Writer.State.Property) {\n        // This array is created as the value of a property,\n        // inside an object.\n        this.Assert(this.currentCollection !== null);\n        this.Assert(this.currentPropertyName !== null);\n\n        let propertyName = this._propertyNameStack.pop();\n        this.currentCollection![propertyName!] = newObject;\n        this._collectionStack.push(newObject);\n      } else if (this.state === SimpleJson.Writer.State.Array) {\n        // This array is created as the child of another array.\n        this.Assert(this.currentCollection !== null);\n\n        this.currentCollection!.push(newObject);\n        this._collectionStack.push(newObject);\n      } else {\n        // This array is the root object.\n        this.Assert(this.state === SimpleJson.Writer.State.None);\n        this._jsonObject = newObject;\n        this._collectionStack.push(newObject);\n      }\n\n      this._stateStack.push(\n        new SimpleJson.Writer.StateElement(SimpleJson.Writer.State.Array)\n      );\n    }\n\n    public WriteArrayEnd() {\n      this.Assert(this.state === SimpleJson.Writer.State.Array);\n      this._collectionStack.pop();\n      this._stateStack.pop();\n    }\n\n    // Add the value to the appropriate collection (array / object), given the current\n    // context.\n    public Write(\n      value: number | string | boolean | null,\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      escape: boolean = true\n    ) {\n      if (value === null) {\n        console.error(\"Warning: trying to write a null value\");\n        return;\n      }\n\n      this.StartNewObject(false);\n      this._addToCurrentObject(value);\n    }\n\n    public WriteBool(value: boolean | null) {\n      if (value === null) {\n        return;\n      }\n\n      this.StartNewObject(false);\n      this._addToCurrentObject(value);\n    }\n\n    public WriteInt(value: number | null) {\n      if (value === null) {\n        return;\n      }\n\n      this.StartNewObject(false);\n\n      // Math.floor is used as a precaution:\n      //     1. to ensure that the value is written as an integer\n      //        (without a fractional part -> 1 instead of 1.0), even\n      //        though it should be the default behaviour of\n      //        JSON.serialize;\n      //     2. to ensure that if a floating number is passed\n      //        accidentally, it's converted to an integer.\n      //\n      // This guarantees savegame compatibility with the reference\n      // implementation.\n      this._addToCurrentObject(Math.floor(value));\n    }\n\n    // Since JSON doesn't support NaN and Infinity, these values\n    // are converted here.\n    public WriteFloat(value: number | null) {\n      if (value === null) {\n        return;\n      }\n\n      this.StartNewObject(false);\n      if (value == Number.POSITIVE_INFINITY) {\n        this._addToCurrentObject(3.4e38);\n      } else if (value == Number.NEGATIVE_INFINITY) {\n        this._addToCurrentObject(-3.4e38);\n      } else if (isNaN(value)) {\n        this._addToCurrentObject(0.0);\n      } else {\n        this._addToCurrentObject(value);\n      }\n    }\n\n    public WriteNull() {\n      this.StartNewObject(false);\n      this._addToCurrentObject(null);\n    }\n\n    // Prepare a string before adding it to the current collection in\n    // WriteStringEnd(). The string will be a concatenation of all the\n    // strings passed to WriteStringInner.\n    public WriteStringStart() {\n      this.StartNewObject(false);\n      this._currentString = \"\";\n      this._stateStack.push(\n        new SimpleJson.Writer.StateElement(SimpleJson.Writer.State.String)\n      );\n    }\n\n    public WriteStringEnd() {\n      this.Assert(this.state == SimpleJson.Writer.State.String);\n      this._stateStack.pop();\n      this._addToCurrentObject(this._currentString);\n      this._currentString = null;\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    public WriteStringInner(str: string | null, escape: boolean = true) {\n      this.Assert(this.state === SimpleJson.Writer.State.String);\n\n      if (str === null) {\n        console.error(\"Warning: trying to write a null string\");\n        return;\n      }\n\n      this._currentString += str;\n    }\n\n    // Serialise the root object into a JSON string.\n    public toString() {\n      if (this._jsonObject === null) {\n        return \"\";\n      }\n\n      return JSON.stringify(this._jsonObject);\n    }\n\n    // Prepare the state stack when adding new objects / values.\n    private StartNewObject(container: boolean) {\n      if (container) {\n        this.Assert(\n          this.state === SimpleJson.Writer.State.None ||\n            this.state === SimpleJson.Writer.State.Property ||\n            this.state === SimpleJson.Writer.State.Array\n        );\n      } else {\n        this.Assert(\n          this.state === SimpleJson.Writer.State.Property ||\n            this.state === SimpleJson.Writer.State.Array\n        );\n      }\n\n      if (this.state === SimpleJson.Writer.State.Property) {\n        this.Assert(this.childCount === 0);\n      }\n\n      if (\n        this.state === SimpleJson.Writer.State.Array ||\n        this.state === SimpleJson.Writer.State.Property\n      ) {\n        this.IncrementChildCount();\n      }\n    }\n\n    // These getters peek all the different stacks.\n\n    private get state() {\n      if (this._stateStack.length > 0) {\n        return this._stateStack[this._stateStack.length - 1].type;\n      } else {\n        return SimpleJson.Writer.State.None;\n      }\n    }\n\n    private get childCount() {\n      if (this._stateStack.length > 0) {\n        return this._stateStack[this._stateStack.length - 1].childCount;\n      } else {\n        return 0;\n      }\n    }\n\n    private get currentCollection() : Record<string, any> | null {\n      if (this._collectionStack.length > 0) {\n        return this._collectionStack[this._collectionStack.length - 1];\n      } else {\n        return null;\n      }\n    }\n\n    private get currentPropertyName() {\n      if (this._propertyNameStack.length > 0) {\n        return this._propertyNameStack[this._propertyNameStack.length - 1];\n      } else {\n        return null;\n      }\n    }\n\n    private IncrementChildCount() {\n      this.Assert(this._stateStack.length > 0);\n      let currEl = this._stateStack.pop()!;\n      currEl.childCount++;\n      this._stateStack.push(currEl);\n    }\n\n    private Assert(condition: boolean) {\n      if (!condition) throw Error(\"Assert failed while writing JSON\");\n    }\n\n    // This method did not exist in the original C# code. It adds\n    // the given value to the current collection (used by Write methods).\n    private _addToCurrentObject(value: number | string | boolean | null) {\n      this.Assert(this.currentCollection !== null);\n      if (this.state === SimpleJson.Writer.State.Array) {\n        this.Assert(Array.isArray(this.currentCollection));\n        (this.currentCollection as any[]).push(value);\n      } else if (this.state === SimpleJson.Writer.State.Property) {\n        this.Assert(!Array.isArray(this.currentCollection));\n        this.Assert(this.currentPropertyName !== null);\n        (this.currentCollection as Record<string, any>)[\n          this.currentPropertyName!\n        ] = value;\n        this._propertyNameStack.pop();\n      }\n    }\n\n    // In addition to `_stateStack` present in the original code,\n    // this implementation of SimpleJson use two other stacks and two\n    // temporary variables holding the current context.\n\n    // Used to keep track of the current property name being built\n    // with `WritePropertyNameStart`, `WritePropertyNameInner` and\n    // `WritePropertyNameEnd`.\n    private _currentPropertyName: string | null = null;\n\n    // Used to keep track of the current string value being built\n    // with `WriteStringStart`, `WriteStringInner` and\n    // `WriteStringEnd`.\n    private _currentString: string | null = null;\n\n    private _stateStack: SimpleJson.Writer.StateElement[] = [];\n\n    // Keep track of the current collection being built (either an array\n    // or an object). For instance, at the '?' step during the hiarchy\n    // creation, this hierarchy:\n    // [3, {a: [b, ?]}] will have this corresponding stack:\n    // (bottom) [Array, Object, Array] (top)\n    private _collectionStack: Array<any[] | Record<string, any>> = [];\n\n    // Keep track of the current property being assigned. For instance, at\n    // the '?' step during the hiarchy creation, this hierarchy:\n    // [3, {a: [b, {c: ?}]}] will have this corresponding stack:\n    // (bottom) [a, c] (top)\n    private _propertyNameStack: string[] = [];\n\n    // Object containing the entire hiearchy.\n    private _jsonObject: Record<string, any> | any[] | null = null;\n  }\n\n  export namespace Writer {\n    export enum State {\n      None,\n      Object,\n      Array,\n      Property,\n      PropertyName,\n      String,\n    }\n\n    export class StateElement {\n      public type: SimpleJson.Writer.State = SimpleJson.Writer.State.None;\n      public childCount: number = 0;\n\n      constructor(type: SimpleJson.Writer.State) {\n        this.type = type;\n      }\n    }\n  }\n}\n","import { CallStack } from \"./CallStack\";\nimport { Choice } from \"./Choice\";\nimport { JsonSerialisation } from \"./JsonSerialisation\";\nimport { InkObject } from \"./Object\";\nimport { SimpleJson } from \"./SimpleJson\";\nimport { Story } from \"./Story\";\nimport { throwNullException } from \"./NullException\";\n\nexport class Flow {\n  public name: string;\n  public callStack: CallStack;\n  public outputStream: InkObject[];\n  public currentChoices: Choice[];\n\n  constructor(name: String, story: Story);\n  constructor(name: String, story: Story, jObject: Record<string, any>);\n  constructor() {\n    let name = arguments[0] as string;\n    let story = arguments[1] as Story;\n\n    this.name = name;\n    this.callStack = new CallStack(story);\n\n    if (arguments[2]) {\n      let jObject = arguments[2] as Record<string, any>;\n\n      this.callStack.SetJsonToken(jObject[\"callstack\"], story);\n      this.outputStream = JsonSerialisation.JArrayToRuntimeObjList(\n        jObject[\"outputStream\"]\n      );\n      this.currentChoices = JsonSerialisation.JArrayToRuntimeObjList(\n        jObject[\"currentChoices\"]\n      ) as Choice[];\n\n      let jChoiceThreadsObj = jObject[\"choiceThreads\"];\n      if (typeof jChoiceThreadsObj !== \"undefined\") {\n        this.LoadFlowChoiceThreads(jChoiceThreadsObj, story);\n      }\n    } else {\n      this.outputStream = [];\n      this.currentChoices = [];\n    }\n  }\n\n  public WriteJson(writer: SimpleJson.Writer) {\n    writer.WriteObjectStart();\n\n    writer.WriteProperty(\"callstack\", (w) => this.callStack.WriteJson(w));\n    writer.WriteProperty(\"outputStream\", (w) =>\n      JsonSerialisation.WriteListRuntimeObjs(w, this.outputStream)\n    );\n\n    let hasChoiceThreads = false;\n    for (let c of this.currentChoices) {\n      if (c.threadAtGeneration === null)\n        return throwNullException(\"c.threadAtGeneration\");\n\n      c.originalThreadIndex = c.threadAtGeneration.threadIndex;\n\n      if (this.callStack.ThreadWithIndex(c.originalThreadIndex) === null) {\n        if (!hasChoiceThreads) {\n          hasChoiceThreads = true;\n          writer.WritePropertyStart(\"choiceThreads\");\n          writer.WriteObjectStart();\n        }\n\n        writer.WritePropertyStart(c.originalThreadIndex);\n        c.threadAtGeneration.WriteJson(writer);\n        writer.WritePropertyEnd();\n      }\n    }\n\n    if (hasChoiceThreads) {\n      writer.WriteObjectEnd();\n      writer.WritePropertyEnd();\n    }\n\n    writer.WriteProperty(\"currentChoices\", (w) => {\n      w.WriteArrayStart();\n      for (let c of this.currentChoices) {\n        JsonSerialisation.WriteChoice(w, c);\n      }\n      w.WriteArrayEnd();\n    });\n\n    writer.WriteObjectEnd();\n  }\n\n  public LoadFlowChoiceThreads(\n    jChoiceThreads: Record<string, any>,\n    story: Story\n  ) {\n    for (let choice of this.currentChoices) {\n      let foundActiveThread = this.callStack.ThreadWithIndex(\n        choice.originalThreadIndex\n      );\n      if (foundActiveThread !== null) {\n        choice.threadAtGeneration = foundActiveThread.Copy();\n      } else {\n        let jSavedChoiceThread =\n          jChoiceThreads[`${choice.originalThreadIndex}`];\n        choice.threadAtGeneration = new CallStack.Thread(\n          jSavedChoiceThread,\n          story\n        );\n      }\n    }\n  }\n}\n","import { CallStack } from \"./CallStack\";\nimport { VariablesState } from \"./VariablesState\";\nimport { ValueType, Value, StringValue, ListValue } from \"./Value\";\nimport { PushPopType } from \"./PushPop\";\nimport { Tag } from \"./Tag\";\nimport { Glue } from \"./Glue\";\nimport { Path } from \"./Path\";\nimport { ControlCommand } from \"./ControlCommand\";\nimport { StringBuilder } from \"./StringBuilder\";\nimport { JsonSerialisation } from \"./JsonSerialisation\";\nimport { PRNG } from \"./PRNG\";\nimport { Void } from \"./Void\";\nimport { Pointer } from \"./Pointer\";\nimport { tryGetValueFromMap } from \"./TryGetResult\";\nimport { Choice } from \"./Choice\";\nimport { asOrNull, asOrThrows, nullIfUndefined } from \"./TypeAssertion\";\nimport { Debug } from \"./Debug\";\nimport { Container } from \"./Container\";\nimport { InkObject } from \"./Object\";\nimport { throwNullException } from \"./NullException\";\nimport { Story } from \"./Story\";\nimport { StatePatch } from \"./StatePatch\";\nimport { SimpleJson } from \"./SimpleJson\";\nimport { Flow } from \"./Flow\";\nimport { InkList } from \"./InkList\";\n\nexport class StoryState {\n  // Backward compatible changes since v8:\n  // v10: dynamic tags\n  // v9:  multi-flows\n  public readonly kInkSaveStateVersion = 10;\n  public readonly kMinCompatibleLoadVersion = 8;\n\n  public onDidLoadState: (() => void) | null = null;\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  public ToJson(indented: boolean = false) {\n    let writer = new SimpleJson.Writer();\n    this.WriteJson(writer);\n    return writer.toString();\n  }\n  public toJson(indented: boolean = false) {\n    return this.ToJson(indented);\n  }\n\n  public LoadJson(json: string) {\n    let jObject = SimpleJson.TextToDictionary(json);\n    this.LoadJsonObj(jObject);\n    if (this.onDidLoadState !== null) this.onDidLoadState();\n  }\n\n  public VisitCountAtPathString(pathString: string) {\n    let visitCountOut;\n\n    if (this._patch !== null) {\n      let container = this.story.ContentAtPath(new Path(pathString)).container;\n      if (container === null)\n        throw new Error(\"Content at path not found: \" + pathString);\n\n      visitCountOut = this._patch.TryGetVisitCount(container, 0);\n      if (visitCountOut.exists) return visitCountOut.result;\n    }\n\n    visitCountOut = tryGetValueFromMap(this._visitCounts, pathString, null);\n    if (visitCountOut.exists) return visitCountOut.result;\n\n    return 0;\n  }\n\n  public VisitCountForContainer(container: Container | null): number {\n    if (container === null) {\n      return throwNullException(\"container\");\n    }\n    if (!container.visitsShouldBeCounted) {\n      this.story.Error(\n        \"Read count for target (\" +\n          container.name +\n          \" - on \" +\n          container.debugMetadata +\n          \") unknown. The story may need to be compiled with countAllVisits flag (-c).\"\n      );\n      return 0;\n    }\n\n    if (this._patch !== null) {\n      let count = this._patch.TryGetVisitCount(container, 0);\n      if (count.exists) {\n        return count.result!;\n      }\n    }\n\n    let containerPathStr = container.path.toString();\n    let count2 = tryGetValueFromMap(this._visitCounts, containerPathStr, null);\n    if (count2.exists) {\n      return count2.result!;\n    }\n\n    return 0;\n  }\n\n  public IncrementVisitCountForContainer(container: Container) {\n    if (this._patch !== null) {\n      let currCount = this.VisitCountForContainer(container);\n      currCount++;\n      this._patch.SetVisitCount(container, currCount);\n      return;\n    }\n\n    let containerPathStr = container.path.toString();\n    let count = tryGetValueFromMap(this._visitCounts, containerPathStr, null);\n    if (count.exists) {\n      this._visitCounts.set(containerPathStr, count.result! + 1);\n    } else {\n      this._visitCounts.set(containerPathStr, 1);\n    }\n  }\n\n  public RecordTurnIndexVisitToContainer(container: Container) {\n    if (this._patch !== null) {\n      this._patch.SetTurnIndex(container, this.currentTurnIndex);\n      return;\n    }\n\n    let containerPathStr = container.path.toString();\n    this._turnIndices.set(containerPathStr, this.currentTurnIndex);\n  }\n\n  public TurnsSinceForContainer(container: Container) {\n    if (!container.turnIndexShouldBeCounted) {\n      this.story.Error(\n        \"TURNS_SINCE() for target (\" +\n          container.name +\n          \" - on \" +\n          container.debugMetadata +\n          \") unknown. The story may need to be compiled with countAllVisits flag (-c).\"\n      );\n    }\n\n    if (this._patch !== null) {\n      let index = this._patch.TryGetTurnIndex(container, 0);\n      if (index.exists) {\n        return this.currentTurnIndex - index.result!;\n      }\n    }\n\n    let containerPathStr = container.path.toString();\n    let index2 = tryGetValueFromMap(this._turnIndices, containerPathStr, 0);\n    if (index2.exists) {\n      return this.currentTurnIndex - index2.result!;\n    } else {\n      return -1;\n    }\n  }\n\n  get callstackDepth() {\n    return this.callStack.depth;\n  }\n\n  get outputStream() {\n    return this._currentFlow.outputStream;\n  }\n\n  get currentChoices() {\n    // If we can continue generating text content rather than choices,\n    // then we reflect the choice list as being empty, since choices\n    // should always come at the end.\n    if (this.canContinue) return [];\n    return this._currentFlow.currentChoices;\n  }\n\n  get generatedChoices() {\n    return this._currentFlow.currentChoices;\n  }\n\n  get currentErrors() {\n    return this._currentErrors;\n  }\n  private _currentErrors: string[] | null = null;\n\n  get currentWarnings() {\n    return this._currentWarnings;\n  }\n  private _currentWarnings: string[] | null = null;\n\n  get variablesState() {\n    return this._variablesState;\n  }\n  set variablesState(value) {\n    this._variablesState = value;\n  }\n  private _variablesState: VariablesState;\n\n  get callStack() {\n    return this._currentFlow.callStack;\n  }\n\n  get evaluationStack() {\n    return this._evaluationStack;\n  }\n  private _evaluationStack: InkObject[];\n\n  public divertedPointer: Pointer = Pointer.Null;\n\n  get currentTurnIndex() {\n    return this._currentTurnIndex;\n  }\n  set currentTurnIndex(value) {\n    this._currentTurnIndex = value;\n  }\n  private _currentTurnIndex: number = 0;\n\n  public storySeed: number = 0;\n  public previousRandom: number = 0;\n  public didSafeExit: boolean = false;\n\n  public story: Story;\n\n  get currentPathString() {\n    let pointer = this.currentPointer;\n    if (pointer.isNull) {\n      return null;\n    } else {\n      if (pointer.path === null) {\n        return throwNullException(\"pointer.path\");\n      }\n      return pointer.path.toString();\n    }\n  }\n\n  get currentPointer() {\n    return this.callStack.currentElement.currentPointer.copy();\n  }\n\n  set currentPointer(value) {\n    this.callStack.currentElement.currentPointer = value.copy();\n  }\n\n  get previousPointer() {\n    return this.callStack.currentThread.previousPointer.copy();\n  }\n\n  set previousPointer(value) {\n    this.callStack.currentThread.previousPointer = value.copy();\n  }\n\n  get canContinue() {\n    return !this.currentPointer.isNull && !this.hasError;\n  }\n\n  get hasError() {\n    return this.currentErrors != null && this.currentErrors.length > 0;\n  }\n\n  get hasWarning() {\n    return this.currentWarnings != null && this.currentWarnings.length > 0;\n  }\n\n  get currentText() {\n    if (this._outputStreamTextDirty) {\n      let sb = new StringBuilder();\n\n      let inTag: boolean = false;\n\n      for (let outputObj of this.outputStream) {\n        // var textContent = outputObj as StringValue;\n        let textContent = asOrNull(outputObj, StringValue);\n        if (!inTag && textContent !== null) {\n          sb.Append(textContent.value);\n        } else {\n          let controlCommand = asOrNull(outputObj, ControlCommand);\n          if (controlCommand !== null) {\n            if (\n              controlCommand.commandType == ControlCommand.CommandType.BeginTag\n            ) {\n              inTag = true;\n            } else if (\n              controlCommand.commandType == ControlCommand.CommandType.EndTag\n            ) {\n              inTag = false;\n            }\n          }\n        }\n      }\n\n      this._currentText = this.CleanOutputWhitespace(sb.toString());\n      this._outputStreamTextDirty = false;\n    }\n\n    return this._currentText;\n  }\n  private _currentText: string | null = null;\n\n  public CleanOutputWhitespace(str: string) {\n    let sb = new StringBuilder();\n\n    let currentWhitespaceStart = -1;\n    let startOfLine = 0;\n\n    for (let i = 0; i < str.length; i++) {\n      let c = str.charAt(i);\n\n      let isInlineWhitespace = c == \" \" || c == \"\\t\";\n\n      if (isInlineWhitespace && currentWhitespaceStart == -1)\n        currentWhitespaceStart = i;\n\n      if (!isInlineWhitespace) {\n        if (\n          c != \"\\n\" &&\n          currentWhitespaceStart > 0 &&\n          currentWhitespaceStart != startOfLine\n        ) {\n          sb.Append(\" \");\n        }\n        currentWhitespaceStart = -1;\n      }\n\n      if (c == \"\\n\") startOfLine = i + 1;\n\n      if (!isInlineWhitespace) sb.Append(c);\n    }\n\n    return sb.toString();\n  }\n\n  get currentTags() {\n    if (this._outputStreamTagsDirty) {\n      this._currentTags = [];\n      let inTag: boolean = false;\n      let sb = new StringBuilder();\n\n      for (let outputObj of this.outputStream) {\n        let controlCommand = asOrNull(outputObj, ControlCommand);\n        if (controlCommand != null) {\n          if (\n            controlCommand.commandType == ControlCommand.CommandType.BeginTag\n          ) {\n            if (inTag && sb.Length > 0) {\n              let txt = this.CleanOutputWhitespace(sb.toString());\n              this._currentTags.push(txt);\n              sb.Clear();\n            }\n            inTag = true;\n          } else if (\n            controlCommand.commandType == ControlCommand.CommandType.EndTag\n          ) {\n            if (sb.Length > 0) {\n              let txt = this.CleanOutputWhitespace(sb.toString());\n              this._currentTags.push(txt);\n              sb.Clear();\n            }\n            inTag = false;\n          }\n        } else if (inTag) {\n          let strVal = asOrNull(outputObj, StringValue);\n          if (strVal !== null) {\n            sb.Append(strVal.value);\n          }\n        } else {\n          let tag = asOrNull(outputObj, Tag);\n          if (tag != null && tag.text != null && tag.text.length > 0) {\n            this._currentTags.push(tag.text); // tag.text has whitespae already cleaned\n          }\n        }\n      }\n\n      if (sb.Length > 0) {\n        let txt = this.CleanOutputWhitespace(sb.toString());\n        this._currentTags.push(txt);\n        sb.Clear();\n      }\n\n      this._outputStreamTagsDirty = false;\n    }\n\n    return this._currentTags;\n  }\n  private _currentTags: string[] | null = null;\n\n  get currentFlowName() {\n    return this._currentFlow.name;\n  }\n\n  get currentFlowIsDefaultFlow() {\n    return this._currentFlow.name == this.kDefaultFlowName;\n  }\n\n  get aliveFlowNames() {\n    if (this._aliveFlowNamesDirty) {\n      this._aliveFlowNames = [];\n\n      if (this._namedFlows != null) {\n        for (let flowName of this._namedFlows.keys()) {\n          if (flowName != this.kDefaultFlowName) {\n            this._aliveFlowNames.push(flowName);\n          }\n        }\n      }\n\n      this._aliveFlowNamesDirty = false;\n    }\n\n    return this._aliveFlowNames;\n  }\n\n  get inExpressionEvaluation() {\n    return this.callStack.currentElement.inExpressionEvaluation;\n  }\n  set inExpressionEvaluation(value) {\n    this.callStack.currentElement.inExpressionEvaluation = value;\n  }\n\n  constructor(story: Story) {\n    this.story = story;\n\n    this._currentFlow = new Flow(this.kDefaultFlowName, story);\n    this.OutputStreamDirty();\n\n    this._aliveFlowNamesDirty = true;\n    this._evaluationStack = [];\n\n    this._variablesState = new VariablesState(\n      this.callStack,\n      story.listDefinitions\n    );\n\n    this._visitCounts = new Map();\n    this._turnIndices = new Map();\n    this.currentTurnIndex = -1;\n\n    let timeSeed = new Date().getTime();\n    this.storySeed = new PRNG(timeSeed).next() % 100;\n    this.previousRandom = 0;\n\n    this.GoToStart();\n  }\n\n  public GoToStart() {\n    this.callStack.currentElement.currentPointer = Pointer.StartOf(\n      this.story.mainContentContainer\n    );\n  }\n\n  public SwitchFlow_Internal(flowName: string | null) {\n    if (flowName === null)\n      throw new Error(\"Must pass a non-null string to Story.SwitchFlow\");\n\n    if (this._namedFlows === null) {\n      this._namedFlows = new Map();\n      this._namedFlows.set(this.kDefaultFlowName, this._currentFlow);\n    }\n\n    if (flowName === this._currentFlow.name) {\n      return;\n    }\n\n    let flow: Flow;\n    let content = tryGetValueFromMap(this._namedFlows, flowName, null);\n    if (content.exists) {\n      flow = content.result!;\n    } else {\n      flow = new Flow(flowName, this.story);\n      this._namedFlows.set(flowName, flow);\n      this._aliveFlowNamesDirty = true;\n    }\n\n    this._currentFlow = flow;\n    this.variablesState.callStack = this._currentFlow.callStack;\n\n    this.OutputStreamDirty();\n  }\n\n  public SwitchToDefaultFlow_Internal() {\n    if (this._namedFlows === null) return;\n    this.SwitchFlow_Internal(this.kDefaultFlowName);\n  }\n\n  public RemoveFlow_Internal(flowName: string | null) {\n    if (flowName === null)\n      throw new Error(\"Must pass a non-null string to Story.DestroyFlow\");\n    if (flowName === this.kDefaultFlowName)\n      throw new Error(\"Cannot destroy default flow\");\n\n    if (this._currentFlow.name === flowName) {\n      this.SwitchToDefaultFlow_Internal();\n    }\n\n    if (this._namedFlows === null)\n      return throwNullException(\"this._namedFlows\");\n    this._namedFlows.delete(flowName);\n    this._aliveFlowNamesDirty = true;\n  }\n\n  public CopyAndStartPatching() {\n    let copy = new StoryState(this.story);\n\n    copy._patch = new StatePatch(this._patch);\n\n    copy._currentFlow.name = this._currentFlow.name;\n    copy._currentFlow.callStack = new CallStack(this._currentFlow.callStack);\n    copy._currentFlow.currentChoices.push(...this._currentFlow.currentChoices);\n    copy._currentFlow.outputStream.push(...this._currentFlow.outputStream);\n    copy.OutputStreamDirty();\n\n    if (this._namedFlows !== null) {\n      copy._namedFlows = new Map();\n      for (let [namedFlowKey, namedFlowValue] of this._namedFlows) {\n        copy._namedFlows.set(namedFlowKey, namedFlowValue);\n        copy._aliveFlowNamesDirty = true;\n      }\n      copy._namedFlows.set(this._currentFlow.name, copy._currentFlow);\n    }\n\n    if (this.hasError) {\n      copy._currentErrors = [];\n      copy._currentErrors.push(...(this.currentErrors || []));\n    }\n\n    if (this.hasWarning) {\n      copy._currentWarnings = [];\n      copy._currentWarnings.push(...(this.currentWarnings || []));\n    }\n\n    copy.variablesState = this.variablesState;\n    copy.variablesState.callStack = copy.callStack;\n    copy.variablesState.patch = copy._patch;\n\n    copy.evaluationStack.push(...this.evaluationStack);\n\n    if (!this.divertedPointer.isNull)\n      copy.divertedPointer = this.divertedPointer.copy();\n\n    copy.previousPointer = this.previousPointer.copy();\n\n    copy._visitCounts = this._visitCounts;\n    copy._turnIndices = this._turnIndices;\n\n    copy.currentTurnIndex = this.currentTurnIndex;\n    copy.storySeed = this.storySeed;\n    copy.previousRandom = this.previousRandom;\n\n    copy.didSafeExit = this.didSafeExit;\n\n    return copy;\n  }\n\n  public RestoreAfterPatch() {\n    this.variablesState.callStack = this.callStack;\n    this.variablesState.patch = this._patch;\n  }\n\n  public ApplyAnyPatch() {\n    if (this._patch === null) return;\n\n    this.variablesState.ApplyPatch();\n\n    for (let [key, value] of this._patch.visitCounts)\n      this.ApplyCountChanges(key, value, true);\n\n    for (let [key, value] of this._patch.turnIndices)\n      this.ApplyCountChanges(key, value, false);\n\n    this._patch = null;\n  }\n\n  public ApplyCountChanges(\n    container: Container,\n    newCount: number,\n    isVisit: boolean\n  ) {\n    let counts = isVisit ? this._visitCounts : this._turnIndices;\n    counts.set(container.path.toString(), newCount);\n  }\n\n  public WriteJson(writer: SimpleJson.Writer) {\n    writer.WriteObjectStart();\n\n    writer.WritePropertyStart(\"flows\");\n    writer.WriteObjectStart();\n\n    // NOTE: Never pass `WriteJson` directly as an argument to `WriteProperty`.\n    // Call it inside a function to make sure `this` is correctly bound\n    // and passed down the call hierarchy.\n\n    if (this._namedFlows !== null) {\n      for (let [namedFlowKey, namedFlowValue] of this._namedFlows) {\n        writer.WriteProperty(namedFlowKey, (w) => namedFlowValue.WriteJson(w));\n      }\n    } else {\n      writer.WriteProperty(this._currentFlow.name, (w) =>\n        this._currentFlow.WriteJson(w)\n      );\n    }\n\n    writer.WriteObjectEnd();\n    writer.WritePropertyEnd();\n\n    writer.WriteProperty(\"currentFlowName\", this._currentFlow.name);\n\n    writer.WriteProperty(\"variablesState\", (w) =>\n      this.variablesState.WriteJson(w)\n    );\n\n    writer.WriteProperty(\"evalStack\", (w) =>\n      JsonSerialisation.WriteListRuntimeObjs(w, this.evaluationStack)\n    );\n\n    if (!this.divertedPointer.isNull) {\n      if (this.divertedPointer.path === null) {\n        return throwNullException(\"divertedPointer\");\n      }\n      writer.WriteProperty(\n        \"currentDivertTarget\",\n        this.divertedPointer.path.componentsString\n      );\n    }\n\n    writer.WriteProperty(\"visitCounts\", (w) =>\n      JsonSerialisation.WriteIntDictionary(w, this._visitCounts)\n    );\n    writer.WriteProperty(\"turnIndices\", (w) =>\n      JsonSerialisation.WriteIntDictionary(w, this._turnIndices)\n    );\n\n    writer.WriteIntProperty(\"turnIdx\", this.currentTurnIndex);\n    writer.WriteIntProperty(\"storySeed\", this.storySeed);\n    writer.WriteIntProperty(\"previousRandom\", this.previousRandom);\n\n    writer.WriteIntProperty(\"inkSaveVersion\", this.kInkSaveStateVersion);\n\n    writer.WriteIntProperty(\"inkFormatVersion\", Story.inkVersionCurrent);\n\n    writer.WriteObjectEnd();\n  }\n\n  public LoadJsonObj(value: Record<string, any>) {\n    let jObject = value;\n\n    let jSaveVersion = jObject[\"inkSaveVersion\"];\n    if (jSaveVersion == null) {\n      throw new Error(\"ink save format incorrect, can't load.\");\n    } else if (parseInt(jSaveVersion) < this.kMinCompatibleLoadVersion) {\n      throw new Error(\n        \"Ink save format isn't compatible with the current version (saw '\" +\n          jSaveVersion +\n          \"', but minimum is \" +\n          this.kMinCompatibleLoadVersion +\n          \"), so can't load.\"\n      );\n    }\n\n    let flowsObj = jObject[\"flows\"];\n    if (flowsObj != null) {\n      let flowsObjDict = flowsObj as Record<string, any>;\n\n      // Single default flow\n      if (Object.keys(flowsObjDict).length === 1) {\n        this._namedFlows = null;\n      } else if (this._namedFlows === null) {\n        this._namedFlows = new Map();\n      } else {\n        this._namedFlows.clear();\n      }\n\n      let flowsObjDictEntries = Object.entries(flowsObjDict);\n      for (let [namedFlowObjKey, namedFlowObjValue] of flowsObjDictEntries) {\n        let name = namedFlowObjKey;\n        let flowObj = namedFlowObjValue as Record<string, any>;\n\n        let flow = new Flow(name, this.story, flowObj);\n\n        if (Object.keys(flowsObjDict).length === 1) {\n          this._currentFlow = new Flow(name, this.story, flowObj);\n        } else {\n          if (this._namedFlows === null)\n            return throwNullException(\"this._namedFlows\");\n          this._namedFlows.set(name, flow);\n        }\n      }\n\n      if (this._namedFlows != null && this._namedFlows.size > 1) {\n        let currFlowName = jObject[\"currentFlowName\"] as string;\n        // Adding a bang at the end, because we're trusting the save, as\n        // done in upstream.  If the save is corrupted, the execution\n        // is undefined.\n        this._currentFlow = this._namedFlows.get(currFlowName)!;\n      }\n    } else {\n      this._namedFlows = null;\n      this._currentFlow.name = this.kDefaultFlowName;\n      this._currentFlow.callStack.SetJsonToken(\n        jObject[\"callstackThreads\"] as Record<string, any>,\n        this.story\n      );\n      this._currentFlow.outputStream = JsonSerialisation.JArrayToRuntimeObjList(\n        jObject[\"outputStream\"] as any[]\n      );\n      this._currentFlow.currentChoices =\n        JsonSerialisation.JArrayToRuntimeObjList(\n          jObject[\"currentChoices\"] as any[]\n        ) as Choice[];\n\n      let jChoiceThreadsObj = jObject[\"choiceThreads\"];\n      this._currentFlow.LoadFlowChoiceThreads(jChoiceThreadsObj, this.story);\n    }\n\n    this.OutputStreamDirty();\n    this._aliveFlowNamesDirty = true;\n\n    this.variablesState.SetJsonToken(jObject[\"variablesState\"]);\n    this.variablesState.callStack = this._currentFlow.callStack;\n\n    this._evaluationStack = JsonSerialisation.JArrayToRuntimeObjList(\n      jObject[\"evalStack\"]\n    );\n\n    let currentDivertTargetPath = jObject[\"currentDivertTarget\"];\n    if (currentDivertTargetPath != null) {\n      let divertPath = new Path(currentDivertTargetPath.toString());\n      this.divertedPointer = this.story.PointerAtPath(divertPath);\n    }\n\n    this._visitCounts = JsonSerialisation.JObjectToIntDictionary(\n      jObject[\"visitCounts\"]\n    );\n    this._turnIndices = JsonSerialisation.JObjectToIntDictionary(\n      jObject[\"turnIndices\"]\n    );\n    this.currentTurnIndex = parseInt(jObject[\"turnIdx\"]);\n    this.storySeed = parseInt(jObject[\"storySeed\"]);\n    this.previousRandom = parseInt(jObject[\"previousRandom\"]);\n  }\n\n  public ResetErrors() {\n    this._currentErrors = null;\n    this._currentWarnings = null;\n  }\n  public ResetOutput(objs: InkObject[] | null = null) {\n    this.outputStream.length = 0;\n    if (objs !== null) this.outputStream.push(...objs);\n    this.OutputStreamDirty();\n  }\n\n  public PushToOutputStream(obj: InkObject | null) {\n    // var text = obj as StringValue;\n    let text = asOrNull(obj, StringValue);\n    if (text !== null) {\n      let listText = this.TrySplittingHeadTailWhitespace(text);\n      if (listText !== null) {\n        for (let textObj of listText) {\n          this.PushToOutputStreamIndividual(textObj);\n        }\n        this.OutputStreamDirty();\n        return;\n      }\n    }\n\n    this.PushToOutputStreamIndividual(obj);\n    this.OutputStreamDirty();\n  }\n\n  public PopFromOutputStream(count: number) {\n    this.outputStream.splice(this.outputStream.length - count, count);\n    this.OutputStreamDirty();\n  }\n\n  public TrySplittingHeadTailWhitespace(single: StringValue) {\n    let str = single.value;\n    if (str === null) {\n      return throwNullException(\"single.value\");\n    }\n\n    let headFirstNewlineIdx = -1;\n    let headLastNewlineIdx = -1;\n    for (let i = 0; i < str.length; i++) {\n      let c = str[i];\n      if (c == \"\\n\") {\n        if (headFirstNewlineIdx == -1) headFirstNewlineIdx = i;\n        headLastNewlineIdx = i;\n      } else if (c == \" \" || c == \"\\t\") continue;\n      else break;\n    }\n\n    let tailLastNewlineIdx = -1;\n    let tailFirstNewlineIdx = -1;\n    for (let i = str.length - 1; i >= 0; i--) {\n      let c = str[i];\n      if (c == \"\\n\") {\n        if (tailLastNewlineIdx == -1) tailLastNewlineIdx = i;\n        tailFirstNewlineIdx = i;\n      } else if (c == \" \" || c == \"\\t\") continue;\n      else break;\n    }\n\n    // No splitting to be done?\n    if (headFirstNewlineIdx == -1 && tailLastNewlineIdx == -1) return null;\n\n    let listTexts: StringValue[] = [];\n    let innerStrStart = 0;\n    let innerStrEnd = str.length;\n\n    if (headFirstNewlineIdx != -1) {\n      if (headFirstNewlineIdx > 0) {\n        let leadingSpaces = new StringValue(\n          str.substring(0, headFirstNewlineIdx)\n        );\n        listTexts.push(leadingSpaces);\n      }\n      listTexts.push(new StringValue(\"\\n\"));\n      innerStrStart = headLastNewlineIdx + 1;\n    }\n\n    if (tailLastNewlineIdx != -1) {\n      innerStrEnd = tailFirstNewlineIdx;\n    }\n\n    if (innerStrEnd > innerStrStart) {\n      let innerStrText = str.substring(innerStrStart, innerStrEnd);\n      listTexts.push(new StringValue(innerStrText));\n    }\n\n    if (tailLastNewlineIdx != -1 && tailFirstNewlineIdx > headLastNewlineIdx) {\n      listTexts.push(new StringValue(\"\\n\"));\n      if (tailLastNewlineIdx < str.length - 1) {\n        let numSpaces = str.length - tailLastNewlineIdx - 1;\n        let trailingSpaces = new StringValue(\n          str.substring(\n            tailLastNewlineIdx + 1,\n            tailLastNewlineIdx + 1 + numSpaces\n          )\n        );\n        listTexts.push(trailingSpaces);\n      }\n    }\n\n    return listTexts;\n  }\n\n  public PushToOutputStreamIndividual(obj: InkObject | null) {\n    let glue = asOrNull(obj, Glue);\n    let text = asOrNull(obj, StringValue);\n\n    let includeInOutput = true;\n\n    if (glue) {\n      this.TrimNewlinesFromOutputStream();\n      includeInOutput = true;\n    } else if (text) {\n      let functionTrimIndex = -1;\n      let currEl = this.callStack.currentElement;\n      if (currEl.type == PushPopType.Function) {\n        functionTrimIndex = currEl.functionStartInOutputStream;\n      }\n\n      let glueTrimIndex = -1;\n      for (let i = this.outputStream.length - 1; i >= 0; i--) {\n        let o = this.outputStream[i];\n        let c = o instanceof ControlCommand ? o : null;\n        let g = o instanceof Glue ? o : null;\n\n        if (g != null) {\n          glueTrimIndex = i;\n          break;\n        } else if (\n          c != null &&\n          c.commandType == ControlCommand.CommandType.BeginString\n        ) {\n          if (i >= functionTrimIndex) {\n            functionTrimIndex = -1;\n          }\n          break;\n        }\n      }\n\n      let trimIndex = -1;\n      if (glueTrimIndex != -1 && functionTrimIndex != -1)\n        trimIndex = Math.min(functionTrimIndex, glueTrimIndex);\n      else if (glueTrimIndex != -1) trimIndex = glueTrimIndex;\n      else trimIndex = functionTrimIndex;\n\n      if (trimIndex != -1) {\n        if (text.isNewline) {\n          includeInOutput = false;\n        } else if (text.isNonWhitespace) {\n          if (glueTrimIndex > -1) this.RemoveExistingGlue();\n\n          if (functionTrimIndex > -1) {\n            let callStackElements = this.callStack.elements;\n            for (let i = callStackElements.length - 1; i >= 0; i--) {\n              let el = callStackElements[i];\n              if (el.type == PushPopType.Function) {\n                el.functionStartInOutputStream = -1;\n              } else {\n                break;\n              }\n            }\n          }\n        }\n      } else if (text.isNewline) {\n        if (this.outputStreamEndsInNewline || !this.outputStreamContainsContent)\n          includeInOutput = false;\n      }\n    }\n\n    if (includeInOutput) {\n      if (obj === null) {\n        return throwNullException(\"obj\");\n      }\n      this.outputStream.push(obj);\n      this.OutputStreamDirty();\n    }\n  }\n\n  public TrimNewlinesFromOutputStream() {\n    let removeWhitespaceFrom = -1;\n\n    let i = this.outputStream.length - 1;\n    while (i >= 0) {\n      let obj = this.outputStream[i];\n      let cmd = asOrNull(obj, ControlCommand);\n      let txt = asOrNull(obj, StringValue);\n\n      if (cmd != null || (txt != null && txt.isNonWhitespace)) {\n        break;\n      } else if (txt != null && txt.isNewline) {\n        removeWhitespaceFrom = i;\n      }\n      i--;\n    }\n\n    // Remove the whitespace\n    if (removeWhitespaceFrom >= 0) {\n      i = removeWhitespaceFrom;\n      while (i < this.outputStream.length) {\n        let text = asOrNull(this.outputStream[i], StringValue);\n        if (text) {\n          this.outputStream.splice(i, 1);\n        } else {\n          i++;\n        }\n      }\n    }\n\n    this.OutputStreamDirty();\n  }\n\n  public RemoveExistingGlue() {\n    for (let i = this.outputStream.length - 1; i >= 0; i--) {\n      let c = this.outputStream[i];\n      if (c instanceof Glue) {\n        this.outputStream.splice(i, 1);\n      } else if (c instanceof ControlCommand) {\n        break;\n      }\n    }\n\n    this.OutputStreamDirty();\n  }\n\n  get outputStreamEndsInNewline() {\n    if (this.outputStream.length > 0) {\n      for (let i = this.outputStream.length - 1; i >= 0; i--) {\n        let obj = this.outputStream[i];\n        if (obj instanceof ControlCommand) break;\n        let text = this.outputStream[i];\n        if (text instanceof StringValue) {\n          if (text.isNewline) return true;\n          else if (text.isNonWhitespace) break;\n        }\n      }\n    }\n\n    return false;\n  }\n\n  get outputStreamContainsContent() {\n    for (let content of this.outputStream) {\n      if (content instanceof StringValue) return true;\n    }\n    return false;\n  }\n\n  get inStringEvaluation() {\n    for (let i = this.outputStream.length - 1; i >= 0; i--) {\n      let cmd = asOrNull(this.outputStream[i], ControlCommand);\n      if (\n        cmd instanceof ControlCommand &&\n        cmd.commandType == ControlCommand.CommandType.BeginString\n      ) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  public PushEvaluationStack(obj: InkObject | null) {\n    // var listValue = obj as ListValue;\n    let listValue = asOrNull(obj, ListValue);\n    if (listValue) {\n      // Update origin when list is has something to indicate the list origin\n      let rawList = listValue.value;\n      if (rawList === null) {\n        return throwNullException(\"rawList\");\n      }\n\n      if (rawList.originNames != null) {\n        if (!rawList.origins) rawList.origins = [];\n        rawList.origins.length = 0;\n\n        for (let n of rawList.originNames) {\n          if (this.story.listDefinitions === null)\n            return throwNullException(\"StoryState.story.listDefinitions\");\n          let def = this.story.listDefinitions.TryListGetDefinition(n, null);\n          if (def.result === null)\n            return throwNullException(\"StoryState def.result\");\n          if (rawList.origins.indexOf(def.result) < 0)\n            rawList.origins.push(def.result);\n        }\n      }\n    }\n\n    if (obj === null) {\n      return throwNullException(\"obj\");\n    }\n    this.evaluationStack.push(obj);\n  }\n\n  public PopEvaluationStack(): InkObject;\n  public PopEvaluationStack(numberOfObjects: number): InkObject[];\n  public PopEvaluationStack(numberOfObjects?: number) {\n    if (typeof numberOfObjects === \"undefined\") {\n      let obj = this.evaluationStack.pop();\n      return nullIfUndefined(obj);\n    } else {\n      if (numberOfObjects > this.evaluationStack.length) {\n        throw new Error(\"trying to pop too many objects\");\n      }\n\n      let popped = this.evaluationStack.splice(\n        this.evaluationStack.length - numberOfObjects,\n        numberOfObjects\n      );\n      return nullIfUndefined(popped);\n    }\n  }\n\n  public PeekEvaluationStack() {\n    return this.evaluationStack[this.evaluationStack.length - 1];\n  }\n\n  public ForceEnd() {\n    this.callStack.Reset();\n\n    this._currentFlow.currentChoices.length = 0;\n\n    this.currentPointer = Pointer.Null;\n    this.previousPointer = Pointer.Null;\n\n    this.didSafeExit = true;\n  }\n\n  public TrimWhitespaceFromFunctionEnd() {\n    Debug.Assert(this.callStack.currentElement.type == PushPopType.Function);\n    let functionStartPoint =\n      this.callStack.currentElement.functionStartInOutputStream;\n\n    if (functionStartPoint == -1) {\n      functionStartPoint = 0;\n    }\n\n    for (let i = this.outputStream.length - 1; i >= functionStartPoint; i--) {\n      let obj = this.outputStream[i];\n      let txt = asOrNull(obj, StringValue);\n      let cmd = asOrNull(obj, ControlCommand);\n\n      if (txt == null) continue;\n      if (cmd) break;\n\n      if (txt.isNewline || txt.isInlineWhitespace) {\n        this.outputStream.splice(i, 1);\n        this.OutputStreamDirty();\n      } else {\n        break;\n      }\n    }\n  }\n\n  public PopCallStack(popType: PushPopType | null = null) {\n    if (this.callStack.currentElement.type == PushPopType.Function)\n      this.TrimWhitespaceFromFunctionEnd();\n\n    this.callStack.Pop(popType);\n  }\n\n  public SetChosenPath(path: Path, incrementingTurnIndex: boolean) {\n    // Changing direction, assume we need to clear current set of choices\n    this._currentFlow.currentChoices.length = 0;\n\n    let newPointer = this.story.PointerAtPath(path);\n    if (!newPointer.isNull && newPointer.index == -1) newPointer.index = 0;\n\n    this.currentPointer = newPointer;\n\n    if (incrementingTurnIndex) {\n      this.currentTurnIndex++;\n    }\n  }\n\n  public StartFunctionEvaluationFromGame(\n    funcContainer: Container,\n    args: any[]\n  ) {\n    this.callStack.Push(\n      PushPopType.FunctionEvaluationFromGame,\n      this.evaluationStack.length\n    );\n    this.callStack.currentElement.currentPointer =\n      Pointer.StartOf(funcContainer);\n\n    this.PassArgumentsToEvaluationStack(args);\n  }\n\n  public PassArgumentsToEvaluationStack(args: any[] | null) {\n    if (args !== null) {\n      for (let i = 0; i < args.length; i++) {\n        if (\n          !(\n            typeof args[i] === \"number\" ||\n            typeof args[i] === \"string\" ||\n            typeof args[i] === \"boolean\" ||\n            args[i] instanceof InkList\n          )\n        ) {\n          throw new Error(\n            \"ink arguments when calling EvaluateFunction / ChoosePathStringWithParameters must be\" +\n              \"number, string, bool or InkList. Argument was \" +\n              (nullIfUndefined(args[i]) === null\n                ? \"null\"\n                : args[i].constructor.name)\n          );\n        }\n\n        this.PushEvaluationStack(Value.Create(args[i]));\n      }\n    }\n  }\n\n  public TryExitFunctionEvaluationFromGame() {\n    if (\n      this.callStack.currentElement.type ==\n      PushPopType.FunctionEvaluationFromGame\n    ) {\n      this.currentPointer = Pointer.Null;\n      this.didSafeExit = true;\n      return true;\n    }\n\n    return false;\n  }\n\n  public CompleteFunctionEvaluationFromGame() {\n    if (\n      this.callStack.currentElement.type !=\n      PushPopType.FunctionEvaluationFromGame\n    ) {\n      throw new Error(\n        \"Expected external function evaluation to be complete. Stack trace: \" +\n          this.callStack.callStackTrace\n      );\n    }\n\n    let originalEvaluationStackHeight =\n      this.callStack.currentElement.evaluationStackHeightWhenPushed;\n\n    let returnedObj: InkObject | null = null;\n    while (this.evaluationStack.length > originalEvaluationStackHeight) {\n      let poppedObj = this.PopEvaluationStack();\n      if (returnedObj === null) returnedObj = poppedObj;\n    }\n\n    this.PopCallStack(PushPopType.FunctionEvaluationFromGame);\n\n    if (returnedObj) {\n      if (returnedObj instanceof Void) return null;\n\n      // Some kind of value, if not void\n      // var returnVal = returnedObj as Runtime.Value;\n      let returnVal = asOrThrows(returnedObj, Value);\n\n      // DivertTargets get returned as the string of components\n      // (rather than a Path, which isn't public)\n      if (returnVal.valueType == ValueType.DivertTarget) {\n        return returnVal.valueObject.toString();\n      }\n\n      // Other types can just have their exact object type:\n      // int, float, string. VariablePointers get returned as strings.\n      return returnVal.valueObject;\n    }\n\n    return null;\n  }\n\n  public AddError(message: string, isWarning: boolean) {\n    if (!isWarning) {\n      if (this._currentErrors == null) this._currentErrors = [];\n      this._currentErrors.push(message);\n    } else {\n      if (this._currentWarnings == null) this._currentWarnings = [];\n      this._currentWarnings.push(message);\n    }\n  }\n\n  public OutputStreamDirty() {\n    this._outputStreamTextDirty = true;\n    this._outputStreamTagsDirty = true;\n  }\n\n  private _visitCounts: Map<string, number>;\n  private _turnIndices: Map<string, number>;\n\n  private _outputStreamTextDirty = true;\n  private _outputStreamTagsDirty = true;\n\n  private _patch: StatePatch | null = null;\n\n  private _currentFlow: Flow;\n  private _aliveFlowNames: string[] | null = null;\n  private _namedFlows: Map<string, Flow> | null = null;\n  private readonly kDefaultFlowName = \"DEFAULT_FLOW\";\n  private _aliveFlowNamesDirty: boolean = true;\n}\n","// This is simple replacement of the Stopwatch class from the .NET Framework.\n// The original class can count time with much more accuracy than the Javascript version.\n// It might be worth considering using `window.performance` in the browser\n// or `process.hrtime()` in node.\nexport class Stopwatch {\n  private startTime: number | undefined;\n\n  constructor() {\n    this.startTime = undefined;\n  }\n\n  get ElapsedMilliseconds(): number {\n    if (typeof this.startTime === \"undefined\") {\n      return 0;\n    }\n    return new Date().getTime() - this.startTime;\n  }\n\n  public Start() {\n    this.startTime = new Date().getTime();\n  }\n  public Stop() {\n    this.startTime = undefined;\n  }\n}\n","import { Container } from \"./Container\";\nimport { InkObject } from \"./Object\";\nimport { JsonSerialisation } from \"./JsonSerialisation\";\nimport { StoryState } from \"./StoryState\";\nimport { ControlCommand } from \"./ControlCommand\";\nimport { PushPopType } from \"./PushPop\";\nimport { ChoicePoint } from \"./ChoicePoint\";\nimport { Choice } from \"./Choice\";\nimport { Divert } from \"./Divert\";\nimport {\n  Value,\n  StringValue,\n  IntValue,\n  DivertTargetValue,\n  VariablePointerValue,\n  ListValue,\n} from \"./Value\";\nimport { Path } from \"./Path\";\nimport { Void } from \"./Void\";\nimport { Tag } from \"./Tag\";\nimport { VariableAssignment } from \"./VariableAssignment\";\nimport { VariableReference } from \"./VariableReference\";\nimport { NativeFunctionCall } from \"./NativeFunctionCall\";\nimport { StoryException } from \"./StoryException\";\nimport { PRNG } from \"./PRNG\";\nimport { StringBuilder } from \"./StringBuilder\";\nimport { ListDefinitionsOrigin } from \"./ListDefinitionsOrigin\";\nimport { ListDefinition } from \"./ListDefinition\";\nimport { Stopwatch } from \"./StopWatch\";\nimport { Pointer } from \"./Pointer\";\nimport { InkList, InkListItem, KeyValuePair } from \"./InkList\";\nimport { asOrNull, asOrThrows } from \"./TypeAssertion\";\nimport { DebugMetadata } from \"./DebugMetadata\";\nimport { throwNullException } from \"./NullException\";\nimport { SimpleJson } from \"./SimpleJson\";\nimport { ErrorHandler, ErrorType } from \"./Error\";\n\nexport { InkList } from \"./InkList\";\n\nif (!Number.isInteger) {\n  Number.isInteger = function isInteger(nVal: any) {\n    return (\n      typeof nVal === \"number\" &&\n      isFinite(nVal) &&\n      nVal > -9007199254740992 &&\n      nVal < 9007199254740992 &&\n      Math.floor(nVal) === nVal\n    );\n  };\n}\n\nexport class Story extends InkObject {\n  public static inkVersionCurrent = 21;\n\n  public inkVersionMinimumCompatible = 18;\n\n  get currentChoices() {\n    let choices: Choice[] = [];\n\n    if (this._state === null) {\n      return throwNullException(\"this._state\");\n    }\n    for (let c of this._state.currentChoices) {\n      if (!c.isInvisibleDefault) {\n        c.index = choices.length;\n        choices.push(c);\n      }\n    }\n\n    return choices;\n  }\n\n  get currentText() {\n    this.IfAsyncWeCant(\"call currentText since it's a work in progress\");\n    return this.state.currentText;\n  }\n\n  get currentTags() {\n    this.IfAsyncWeCant(\"call currentTags since it's a work in progress\");\n    return this.state.currentTags;\n  }\n\n  get currentErrors() {\n    return this.state.currentErrors;\n  }\n\n  get currentWarnings() {\n    return this.state.currentWarnings;\n  }\n\n  get currentFlowName() {\n    return this.state.currentFlowName;\n  }\n\n  get currentFlowIsDefaultFlow() {\n    return this.state.currentFlowIsDefaultFlow;\n  }\n\n  get aliveFlowNames() {\n    return this.state.aliveFlowNames;\n  }\n\n  get hasError() {\n    return this.state.hasError;\n  }\n\n  get hasWarning() {\n    return this.state.hasWarning;\n  }\n\n  get variablesState() {\n    return this.state.variablesState;\n  }\n\n  get listDefinitions() {\n    return this._listDefinitions;\n  }\n\n  get state() {\n    return this._state;\n  }\n\n  public onError: ErrorHandler | null = null;\n\n  public onDidContinue: (() => void) | null = null;\n\n  public onMakeChoice: ((arg1: Choice) => void) | null = null;\n\n  public onEvaluateFunction: ((arg1: string, arg2: any[]) => void) | null =\n    null;\n\n  public onCompleteEvaluateFunction:\n    | ((arg1: string, arg2: any[], arg3: string, arg4: any) => void)\n    | null = null;\n\n  public onChoosePathString: ((arg1: string, arg2: any[]) => void) | null =\n    null;\n\n  // TODO: Implement Profiler\n  public StartProfiling() {\n    /* */\n  }\n  public EndProfiling() {\n    /* */\n  }\n\n  constructor(contentContainer: Container, lists: ListDefinition[] | null);\n  constructor(jsonString: string);\n  constructor(json: Record<string, any>);\n  constructor() {\n    super();\n\n    // Discrimination between constructors\n    let contentContainer: Container;\n    let lists: ListDefinition[] | null = null;\n    let json: Record<string, any> | null = null;\n\n    if (arguments[0] instanceof Container) {\n      contentContainer = arguments[0] as Container;\n\n      if (typeof arguments[1] !== \"undefined\") {\n        lists = arguments[1] as ListDefinition[];\n      }\n\n      // ------ Story (Container contentContainer, List<Runtime.ListDefinition> lists = null)\n      this._mainContentContainer = contentContainer;\n      // ------\n    } else {\n      if (typeof arguments[0] === \"string\") {\n        let jsonString = arguments[0] as string;\n        json = SimpleJson.TextToDictionary(jsonString);\n      } else {\n        json = arguments[0] as Record<string, any>;\n      }\n    }\n\n    // ------ Story (Container contentContainer, List<Runtime.ListDefinition> lists = null)\n    if (lists != null) this._listDefinitions = new ListDefinitionsOrigin(lists);\n\n    this._externals = new Map();\n    // ------\n\n    // ------ Story(string jsonString) : this((Container)null)\n    if (json !== null) {\n      let rootObject: Record<string, any> = json;\n\n      let versionObj = rootObject[\"inkVersion\"];\n      if (versionObj == null)\n        throw new Error(\n          \"ink version number not found. Are you sure it's a valid .ink.json file?\"\n        );\n\n      let formatFromFile = parseInt(versionObj);\n      if (formatFromFile > Story.inkVersionCurrent) {\n        throw new Error(\n          \"Version of ink used to build story was newer than the current version of the engine\"\n        );\n      } else if (formatFromFile < this.inkVersionMinimumCompatible) {\n        throw new Error(\n          \"Version of ink used to build story is too old to be loaded by this version of the engine\"\n        );\n      } else if (formatFromFile != Story.inkVersionCurrent) {\n        console.warn(\n          \"WARNING: Version of ink used to build story doesn't match current version of engine. Non-critical, but recommend synchronising.\"\n        );\n      }\n\n      let rootToken = rootObject[\"root\"];\n      if (rootToken == null)\n        throw new Error(\n          \"Root node for ink not found. Are you sure it's a valid .ink.json file?\"\n        );\n\n      let listDefsObj;\n      if ((listDefsObj = rootObject[\"listDefs\"])) {\n        this._listDefinitions =\n          JsonSerialisation.JTokenToListDefinitions(listDefsObj);\n      }\n\n      this._mainContentContainer = asOrThrows(\n        JsonSerialisation.JTokenToRuntimeObject(rootToken),\n        Container\n      );\n\n      this.ResetState();\n    }\n    // ------\n  }\n\n  // Merge together `public string ToJson()` and `void ToJson(SimpleJson.Writer writer)`.\n  // Will only return a value if writer was not provided.\n  public ToJson(writer?: SimpleJson.Writer): string | void {\n    let shouldReturn = false;\n\n    if (!writer) {\n      shouldReturn = true;\n      writer = new SimpleJson.Writer();\n    }\n\n    writer.WriteObjectStart();\n\n    writer.WriteIntProperty(\"inkVersion\", Story.inkVersionCurrent);\n\n    writer.WriteProperty(\"root\", (w) =>\n      JsonSerialisation.WriteRuntimeContainer(w, this._mainContentContainer)\n    );\n\n    if (this._listDefinitions != null) {\n      writer.WritePropertyStart(\"listDefs\");\n      writer.WriteObjectStart();\n\n      for (let def of this._listDefinitions.lists) {\n        writer.WritePropertyStart(def.name);\n        writer.WriteObjectStart();\n\n        for (let [key, value] of def.items) {\n          let item = InkListItem.fromSerializedKey(key);\n          let val = value;\n          writer.WriteIntProperty(item.itemName, val);\n        }\n\n        writer.WriteObjectEnd();\n        writer.WritePropertyEnd();\n      }\n\n      writer.WriteObjectEnd();\n      writer.WritePropertyEnd();\n    }\n\n    writer.WriteObjectEnd();\n\n    if (shouldReturn) return writer.toString();\n  }\n\n  public ResetState() {\n    this.IfAsyncWeCant(\"ResetState\");\n\n    this._state = new StoryState(this);\n    this._state.variablesState.ObserveVariableChange(\n      this.VariableStateDidChangeEvent.bind(this)\n    );\n\n    this.ResetGlobals();\n  }\n\n  public ResetErrors() {\n    if (this._state === null) {\n      return throwNullException(\"this._state\");\n    }\n    this._state.ResetErrors();\n  }\n\n  public ResetCallstack() {\n    this.IfAsyncWeCant(\"ResetCallstack\");\n    if (this._state === null) {\n      return throwNullException(\"this._state\");\n    }\n    this._state.ForceEnd();\n  }\n\n  public ResetGlobals() {\n    if (this._mainContentContainer.namedContent.get(\"global decl\")) {\n      let originalPointer = this.state.currentPointer.copy();\n\n      this.ChoosePath(new Path(\"global decl\"), false);\n\n      this.ContinueInternal();\n\n      this.state.currentPointer = originalPointer;\n    }\n\n    this.state.variablesState.SnapshotDefaultGlobals();\n  }\n\n  public SwitchFlow(flowName: string) {\n    this.IfAsyncWeCant(\"switch flow\");\n    if (this._asyncSaving) {\n      throw new Error(\n        \"Story is already in background saving mode, can't switch flow to \" +\n          flowName\n      );\n    }\n\n    this.state.SwitchFlow_Internal(flowName);\n  }\n\n  public RemoveFlow(flowName: string) {\n    this.state.RemoveFlow_Internal(flowName);\n  }\n\n  public SwitchToDefaultFlow() {\n    this.state.SwitchToDefaultFlow_Internal();\n  }\n\n  public Continue() {\n    this.ContinueAsync(0);\n    return this.currentText;\n  }\n\n  get canContinue() {\n    return this.state.canContinue;\n  }\n\n  get asyncContinueComplete() {\n    return !this._asyncContinueActive;\n  }\n\n  public ContinueAsync(millisecsLimitAsync: number) {\n    if (!this._hasValidatedExternals) this.ValidateExternalBindings();\n\n    this.ContinueInternal(millisecsLimitAsync);\n  }\n\n  public ContinueInternal(millisecsLimitAsync = 0) {\n    if (this._profiler != null) this._profiler.PreContinue();\n\n    let isAsyncTimeLimited = millisecsLimitAsync > 0;\n    this._recursiveContinueCount++;\n\n    if (!this._asyncContinueActive) {\n      this._asyncContinueActive = isAsyncTimeLimited;\n\n      if (!this.canContinue) {\n        throw new Error(\n          \"Can't continue - should check canContinue before calling Continue\"\n        );\n      }\n\n      this._state.didSafeExit = false;\n      this._state.ResetOutput();\n\n      if (this._recursiveContinueCount == 1)\n        this._state.variablesState.batchObservingVariableChanges = true;\n    }\n\n    let durationStopwatch = new Stopwatch();\n    durationStopwatch.Start();\n\n    let outputStreamEndsInNewline = false;\n    this._sawLookaheadUnsafeFunctionAfterNewline = false;\n    do {\n      try {\n        outputStreamEndsInNewline = this.ContinueSingleStep();\n      } catch (e) {\n        if (!(e instanceof StoryException)) throw e;\n\n        this.AddError(e.message, undefined, e.useEndLineNumber);\n        break;\n      }\n\n      if (outputStreamEndsInNewline) break;\n\n      if (\n        this._asyncContinueActive &&\n        durationStopwatch.ElapsedMilliseconds > millisecsLimitAsync\n      ) {\n        break;\n      }\n    } while (this.canContinue);\n\n    durationStopwatch.Stop();\n\n    if (outputStreamEndsInNewline || !this.canContinue) {\n      if (this._stateSnapshotAtLastNewline !== null) {\n        this.RestoreStateSnapshot();\n      }\n\n      if (!this.canContinue) {\n        if (this.state.callStack.canPopThread)\n          this.AddError(\n            \"Thread available to pop, threads should always be flat by the end of evaluation?\"\n          );\n\n        if (\n          this.state.generatedChoices.length == 0 &&\n          !this.state.didSafeExit &&\n          this._temporaryEvaluationContainer == null\n        ) {\n          if (this.state.callStack.CanPop(PushPopType.Tunnel))\n            this.AddError(\n              \"unexpectedly reached end of content. Do you need a '->->' to return from a tunnel?\"\n            );\n          else if (this.state.callStack.CanPop(PushPopType.Function))\n            this.AddError(\n              \"unexpectedly reached end of content. Do you need a '~ return'?\"\n            );\n          else if (!this.state.callStack.canPop)\n            this.AddError(\n              \"ran out of content. Do you need a '-> DONE' or '-> END'?\"\n            );\n          else\n            this.AddError(\n              \"unexpectedly reached end of content for unknown reason. Please debug compiler!\"\n            );\n        }\n      }\n\n      this.state.didSafeExit = false;\n      this._sawLookaheadUnsafeFunctionAfterNewline = false;\n\n      if (this._recursiveContinueCount == 1)\n        this._state.variablesState.batchObservingVariableChanges = false;\n\n      this._asyncContinueActive = false;\n      if (this.onDidContinue !== null) this.onDidContinue();\n    }\n\n    this._recursiveContinueCount--;\n\n    if (this._profiler != null) this._profiler.PostContinue();\n\n    // In the following code, we're masking a lot of non-null assertion,\n    // because testing for against `hasError` or `hasWarning` makes sure\n    // the arrays are present and contain at least one element.\n    if (this.state.hasError || this.state.hasWarning) {\n      if (this.onError !== null) {\n        if (this.state.hasError) {\n          for (let err of this.state.currentErrors!) {\n            this.onError(err, ErrorType.Error);\n          }\n        }\n        if (this.state.hasWarning) {\n          for (let err of this.state.currentWarnings!) {\n            this.onError(err, ErrorType.Warning);\n          }\n        }\n        this.ResetErrors();\n      } else {\n        let sb = new StringBuilder();\n        sb.Append(\"Ink had \");\n        if (this.state.hasError) {\n          sb.Append(`${this.state.currentErrors!.length}`);\n          sb.Append(\n            this.state.currentErrors!.length == 1 ? \" error\" : \"errors\"\n          );\n          if (this.state.hasWarning) sb.Append(\" and \");\n        }\n        if (this.state.hasWarning) {\n          sb.Append(`${this.state.currentWarnings!.length}`);\n          sb.Append(\n            this.state.currentWarnings!.length == 1 ? \" warning\" : \"warnings\"\n          );\n          if (this.state.hasWarning) sb.Append(\" and \");\n        }\n        sb.Append(\n          \". It is strongly suggested that you assign an error handler to story.onError. The first issue was: \"\n        );\n        sb.Append(\n          this.state.hasError\n            ? this.state.currentErrors![0]\n            : this.state.currentWarnings![0]\n        );\n\n        throw new StoryException(sb.toString());\n      }\n    }\n  }\n\n  public ContinueSingleStep() {\n    if (this._profiler != null) this._profiler.PreStep();\n\n    this.Step();\n\n    if (this._profiler != null) this._profiler.PostStep();\n\n    if (!this.canContinue && !this.state.callStack.elementIsEvaluateFromGame) {\n      this.TryFollowDefaultInvisibleChoice();\n    }\n\n    if (this._profiler != null) this._profiler.PreSnapshot();\n\n    if (!this.state.inStringEvaluation) {\n      if (this._stateSnapshotAtLastNewline !== null) {\n        if (this._stateSnapshotAtLastNewline.currentTags === null) {\n          return throwNullException(\"this._stateAtLastNewline.currentTags\");\n        }\n        if (this.state.currentTags === null) {\n          return throwNullException(\"this.state.currentTags\");\n        }\n\n        let change = this.CalculateNewlineOutputStateChange(\n          this._stateSnapshotAtLastNewline.currentText,\n          this.state.currentText,\n          this._stateSnapshotAtLastNewline.currentTags.length,\n          this.state.currentTags.length\n        );\n\n        if (\n          change == Story.OutputStateChange.ExtendedBeyondNewline ||\n          this._sawLookaheadUnsafeFunctionAfterNewline\n        ) {\n          this.RestoreStateSnapshot();\n\n          return true;\n        } else if (change == Story.OutputStateChange.NewlineRemoved) {\n          this.DiscardSnapshot();\n        }\n      }\n\n      if (this.state.outputStreamEndsInNewline) {\n        if (this.canContinue) {\n          if (this._stateSnapshotAtLastNewline == null) this.StateSnapshot();\n        } else {\n          this.DiscardSnapshot();\n        }\n      }\n    }\n\n    if (this._profiler != null) this._profiler.PostSnapshot();\n\n    return false;\n  }\n\n  public CalculateNewlineOutputStateChange(\n    prevText: string | null,\n    currText: string | null,\n    prevTagCount: number,\n    currTagCount: number\n  ) {\n    if (prevText === null) {\n      return throwNullException(\"prevText\");\n    }\n    if (currText === null) {\n      return throwNullException(\"currText\");\n    }\n\n    let newlineStillExists =\n      currText.length >= prevText.length &&\n      prevText.length > 0 &&\n      currText.charAt(prevText.length - 1) == \"\\n\";\n    if (\n      prevTagCount == currTagCount &&\n      prevText.length == currText.length &&\n      newlineStillExists\n    )\n      return Story.OutputStateChange.NoChange;\n\n    if (!newlineStillExists) {\n      return Story.OutputStateChange.NewlineRemoved;\n    }\n\n    if (currTagCount > prevTagCount)\n      return Story.OutputStateChange.ExtendedBeyondNewline;\n\n    for (let i = prevText.length; i < currText.length; i++) {\n      let c = currText.charAt(i);\n      if (c != \" \" && c != \"\\t\") {\n        return Story.OutputStateChange.ExtendedBeyondNewline;\n      }\n    }\n\n    return Story.OutputStateChange.NoChange;\n  }\n\n  public ContinueMaximally() {\n    this.IfAsyncWeCant(\"ContinueMaximally\");\n\n    let sb = new StringBuilder();\n\n    while (this.canContinue) {\n      sb.Append(this.Continue());\n    }\n\n    return sb.toString();\n  }\n\n  public ContentAtPath(path: Path) {\n    return this.mainContentContainer.ContentAtPath(path);\n  }\n\n  public KnotContainerWithName(name: string) {\n    let namedContainer = this.mainContentContainer.namedContent.get(name);\n    if (namedContainer instanceof Container) return namedContainer;\n    else return null;\n  }\n\n  public PointerAtPath(path: Path) {\n    if (path.length == 0) return Pointer.Null;\n\n    let p = new Pointer();\n\n    let pathLengthToUse = path.length;\n\n    let result = null;\n    if (path.lastComponent === null) {\n      return throwNullException(\"path.lastComponent\");\n    }\n\n    if (path.lastComponent.isIndex) {\n      pathLengthToUse = path.length - 1;\n      result = this.mainContentContainer.ContentAtPath(\n        path,\n        undefined,\n        pathLengthToUse\n      );\n      p.container = result.container;\n      p.index = path.lastComponent.index;\n    } else {\n      result = this.mainContentContainer.ContentAtPath(path);\n      p.container = result.container;\n      p.index = -1;\n    }\n\n    if (\n      result.obj == null ||\n      (result.obj == this.mainContentContainer && pathLengthToUse > 0)\n    ) {\n      this.Error(\n        \"Failed to find content at path '\" +\n          path +\n          \"', and no approximation of it was possible.\"\n      );\n    } else if (result.approximate)\n      this.Warning(\n        \"Failed to find content at path '\" +\n          path +\n          \"', so it was approximated to: '\" +\n          result.obj.path +\n          \"'.\"\n      );\n\n    return p;\n  }\n\n  public StateSnapshot() {\n    this._stateSnapshotAtLastNewline = this._state;\n    this._state = this._state.CopyAndStartPatching();\n  }\n\n  public RestoreStateSnapshot() {\n    if (this._stateSnapshotAtLastNewline === null) {\n      throwNullException(\"_stateSnapshotAtLastNewline\");\n    }\n    this._stateSnapshotAtLastNewline.RestoreAfterPatch();\n\n    this._state = this._stateSnapshotAtLastNewline;\n    this._stateSnapshotAtLastNewline = null;\n\n    if (!this._asyncSaving) {\n      this._state.ApplyAnyPatch();\n    }\n  }\n\n  public DiscardSnapshot() {\n    if (!this._asyncSaving) this._state.ApplyAnyPatch();\n\n    this._stateSnapshotAtLastNewline = null;\n  }\n\n  public CopyStateForBackgroundThreadSave() {\n    this.IfAsyncWeCant(\"start saving on a background thread\");\n\n    if (this._asyncSaving)\n      throw new Error(\n        \"Story is already in background saving mode, can't call CopyStateForBackgroundThreadSave again!\"\n      );\n\n    let stateToSave = this._state;\n    this._state = this._state.CopyAndStartPatching();\n    this._asyncSaving = true;\n    return stateToSave;\n  }\n\n  public BackgroundSaveComplete() {\n    if (this._stateSnapshotAtLastNewline === null) {\n      this._state.ApplyAnyPatch();\n    }\n\n    this._asyncSaving = false;\n  }\n\n  public Step() {\n    let shouldAddToStream = true;\n\n    let pointer = this.state.currentPointer.copy();\n    if (pointer.isNull) {\n      return;\n    }\n\n    // Container containerToEnter = pointer.Resolve () as Container;\n    let containerToEnter = asOrNull(pointer.Resolve(), Container);\n\n    while (containerToEnter) {\n      this.VisitContainer(containerToEnter, true);\n\n      // No content? the most we can do is step past it\n      if (containerToEnter.content.length == 0) {\n        break;\n      }\n\n      pointer = Pointer.StartOf(containerToEnter);\n      // containerToEnter = pointer.Resolve() as Container;\n      containerToEnter = asOrNull(pointer.Resolve(), Container);\n    }\n\n    this.state.currentPointer = pointer.copy();\n\n    if (this._profiler != null) this._profiler.Step(this.state.callStack);\n\n    // Is the current content object:\n    //  - Normal content\n    //  - Or a logic/flow statement - if so, do it\n    // Stop flow if we hit a stack pop when we're unable to pop (e.g. return/done statement in knot\n    // that was diverted to rather than called as a function)\n    let currentContentObj = pointer.Resolve();\n    let isLogicOrFlowControl =\n      this.PerformLogicAndFlowControl(currentContentObj);\n\n    // Has flow been forced to end by flow control above?\n    if (this.state.currentPointer.isNull) {\n      return;\n    }\n\n    if (isLogicOrFlowControl) {\n      shouldAddToStream = false;\n    }\n\n    // Choice with condition?\n    // var choicePoint = currentContentObj as ChoicePoint;\n    let choicePoint = asOrNull(currentContentObj, ChoicePoint);\n    if (choicePoint) {\n      let choice = this.ProcessChoice(choicePoint);\n      if (choice) {\n        this.state.generatedChoices.push(choice);\n      }\n\n      currentContentObj = null;\n      shouldAddToStream = false;\n    }\n\n    // If the container has no content, then it will be\n    // the \"content\" itself, but we skip over it.\n    if (currentContentObj instanceof Container) {\n      shouldAddToStream = false;\n    }\n\n    // Content to add to evaluation stack or the output stream\n    if (shouldAddToStream) {\n      // If we're pushing a variable pointer onto the evaluation stack, ensure that it's specific\n      // to our current (possibly temporary) context index. And make a copy of the pointer\n      // so that we're not editing the original runtime object.\n      // var varPointer = currentContentObj as VariablePointerValue;\n      let varPointer = asOrNull(currentContentObj, VariablePointerValue);\n      if (varPointer && varPointer.contextIndex == -1) {\n        // Create new object so we're not overwriting the story's own data\n        let contextIdx = this.state.callStack.ContextForVariableNamed(\n          varPointer.variableName\n        );\n        currentContentObj = new VariablePointerValue(\n          varPointer.variableName,\n          contextIdx\n        );\n      }\n\n      // Expression evaluation content\n      if (this.state.inExpressionEvaluation) {\n        this.state.PushEvaluationStack(currentContentObj);\n      }\n      // Output stream content (i.e. not expression evaluation)\n      else {\n        this.state.PushToOutputStream(currentContentObj);\n      }\n    }\n\n    // Increment the content pointer, following diverts if necessary\n    this.NextContent();\n\n    // Starting a thread should be done after the increment to the content pointer,\n    // so that when returning from the thread, it returns to the content after this instruction.\n    // var controlCmd = currentContentObj as ;\n    let controlCmd = asOrNull(currentContentObj, ControlCommand);\n    if (\n      controlCmd &&\n      controlCmd.commandType == ControlCommand.CommandType.StartThread\n    ) {\n      this.state.callStack.PushThread();\n    }\n  }\n\n  public VisitContainer(container: Container, atStart: boolean) {\n    if (!container.countingAtStartOnly || atStart) {\n      if (container.visitsShouldBeCounted)\n        this.state.IncrementVisitCountForContainer(container);\n\n      if (container.turnIndexShouldBeCounted)\n        this.state.RecordTurnIndexVisitToContainer(container);\n    }\n  }\n\n  private _prevContainers: Container[] = [];\n  public VisitChangedContainersDueToDivert() {\n    let previousPointer = this.state.previousPointer.copy();\n    let pointer = this.state.currentPointer.copy();\n\n    if (pointer.isNull || pointer.index == -1) return;\n\n    this._prevContainers.length = 0;\n    if (!previousPointer.isNull) {\n      // Container prevAncestor = previousPointer.Resolve() as Container ?? previousPointer.container as Container;\n      let resolvedPreviousAncestor = previousPointer.Resolve();\n      let prevAncestor =\n        asOrNull(resolvedPreviousAncestor, Container) ||\n        asOrNull(previousPointer.container, Container);\n      while (prevAncestor) {\n        this._prevContainers.push(prevAncestor);\n        // prevAncestor = prevAncestor.parent as Container;\n        prevAncestor = asOrNull(prevAncestor.parent, Container);\n      }\n    }\n\n    let currentChildOfContainer = pointer.Resolve();\n\n    if (currentChildOfContainer == null) return;\n\n    // Container currentContainerAncestor = currentChildOfContainer.parent as Container;\n    let currentContainerAncestor = asOrNull(\n      currentChildOfContainer.parent,\n      Container\n    );\n    let allChildrenEnteredAtStart = true;\n    while (\n      currentContainerAncestor &&\n      (this._prevContainers.indexOf(currentContainerAncestor) < 0 ||\n        currentContainerAncestor.countingAtStartOnly)\n    ) {\n      // Check whether this ancestor container is being entered at the start,\n      // by checking whether the child object is the first.\n      let enteringAtStart =\n        currentContainerAncestor.content.length > 0 &&\n        currentChildOfContainer == currentContainerAncestor.content[0] &&\n        allChildrenEnteredAtStart;\n\n      if (!enteringAtStart) allChildrenEnteredAtStart = false;\n\n      // Mark a visit to this container\n      this.VisitContainer(currentContainerAncestor, enteringAtStart);\n\n      currentChildOfContainer = currentContainerAncestor;\n      // currentContainerAncestor = currentContainerAncestor.parent as Container;\n      currentContainerAncestor = asOrNull(\n        currentContainerAncestor.parent,\n        Container\n      );\n    }\n  }\n\n  public PopChoiceStringAndTags(tags: string[]) {\n    let choiceOnlyStrVal = asOrThrows(\n      this.state.PopEvaluationStack(),\n      StringValue\n    );\n\n    while (\n      this.state.evaluationStack.length > 0 &&\n      asOrNull(this.state.PeekEvaluationStack(), Tag) != null\n    ) {\n      let tag = asOrNull(this.state.PopEvaluationStack(), Tag);\n      if (tag) tags.push(tag.text);\n    }\n    return choiceOnlyStrVal.value;\n  }\n\n  public ProcessChoice(choicePoint: ChoicePoint) {\n    let showChoice = true;\n\n    // Don't create choice if choice point doesn't pass conditional\n    if (choicePoint.hasCondition) {\n      let conditionValue = this.state.PopEvaluationStack();\n      if (!this.IsTruthy(conditionValue)) {\n        showChoice = false;\n      }\n    }\n\n    let startText = \"\";\n    let choiceOnlyText = \"\";\n    let tags: string[] = [];\n\n    if (choicePoint.hasChoiceOnlyContent) {\n      choiceOnlyText = this.PopChoiceStringAndTags(tags) || \"\";\n    }\n\n    if (choicePoint.hasStartContent) {\n      startText = this.PopChoiceStringAndTags(tags) || \"\";\n    }\n\n    // Don't create choice if player has already read this content\n    if (choicePoint.onceOnly) {\n      let visitCount = this.state.VisitCountForContainer(\n        choicePoint.choiceTarget\n      );\n      if (visitCount > 0) {\n        showChoice = false;\n      }\n    }\n\n    // We go through the full process of creating the choice above so\n    // that we consume the content for it, since otherwise it'll\n    // be shown on the output stream.\n    if (!showChoice) {\n      return null;\n    }\n\n    let choice = new Choice();\n    choice.targetPath = choicePoint.pathOnChoice;\n    choice.sourcePath = choicePoint.path.toString();\n    choice.isInvisibleDefault = choicePoint.isInvisibleDefault;\n    choice.threadAtGeneration = this.state.callStack.ForkThread();\n    choice.tags = tags.reverse(); //C# is a stack\n    choice.text = (startText + choiceOnlyText).replace(/^[ \\t]+|[ \\t]+$/g, \"\");\n\n    return choice;\n  }\n\n  public IsTruthy(obj: InkObject) {\n    let truthy = false;\n    if (obj instanceof Value) {\n      let val = obj;\n\n      if (val instanceof DivertTargetValue) {\n        let divTarget = val;\n        this.Error(\n          \"Shouldn't use a divert target (to \" +\n            divTarget.targetPath +\n            \") as a conditional value. Did you intend a function call 'likeThis()' or a read count check 'likeThis'? (no arrows)\"\n        );\n        return false;\n      }\n\n      return val.isTruthy;\n    }\n    return truthy;\n  }\n\n  public PerformLogicAndFlowControl(contentObj: InkObject | null) {\n    if (contentObj == null) {\n      return false;\n    }\n\n    // Divert\n    if (contentObj instanceof Divert) {\n      let currentDivert = contentObj;\n\n      if (currentDivert.isConditional) {\n        let conditionValue = this.state.PopEvaluationStack();\n\n        // False conditional? Cancel divert\n        if (!this.IsTruthy(conditionValue)) return true;\n      }\n\n      if (currentDivert.hasVariableTarget) {\n        let varName = currentDivert.variableDivertName;\n\n        let varContents =\n          this.state.variablesState.GetVariableWithName(varName);\n\n        if (varContents == null) {\n          this.Error(\n            \"Tried to divert using a target from a variable that could not be found (\" +\n              varName +\n              \")\"\n          );\n        } else if (!(varContents instanceof DivertTargetValue)) {\n          // var intContent = varContents as IntValue;\n          let intContent = asOrNull(varContents, IntValue);\n\n          let errorMessage =\n            \"Tried to divert to a target from a variable, but the variable (\" +\n            varName +\n            \") didn't contain a divert target, it \";\n          if (intContent instanceof IntValue && intContent.value == 0) {\n            errorMessage += \"was empty/null (the value 0).\";\n          } else {\n            errorMessage += \"contained '\" + varContents + \"'.\";\n          }\n\n          this.Error(errorMessage);\n        }\n\n        let target = asOrThrows(varContents, DivertTargetValue);\n        this.state.divertedPointer = this.PointerAtPath(target.targetPath);\n      } else if (currentDivert.isExternal) {\n        this.CallExternalFunction(\n          currentDivert.targetPathString,\n          currentDivert.externalArgs\n        );\n        return true;\n      } else {\n        this.state.divertedPointer = currentDivert.targetPointer.copy();\n      }\n\n      if (currentDivert.pushesToStack) {\n        this.state.callStack.Push(\n          currentDivert.stackPushType,\n          undefined,\n          this.state.outputStream.length\n        );\n      }\n\n      if (this.state.divertedPointer.isNull && !currentDivert.isExternal) {\n        if (\n          currentDivert &&\n          currentDivert.debugMetadata &&\n          currentDivert.debugMetadata.sourceName != null\n        ) {\n          this.Error(\n            \"Divert target doesn't exist: \" +\n              currentDivert.debugMetadata.sourceName\n          );\n        } else {\n          this.Error(\"Divert resolution failed: \" + currentDivert);\n        }\n      }\n\n      return true;\n    }\n\n    // Start/end an expression evaluation? Or print out the result?\n    else if (contentObj instanceof ControlCommand) {\n      let evalCommand = contentObj;\n\n      switch (evalCommand.commandType) {\n        case ControlCommand.CommandType.EvalStart:\n          this.Assert(\n            this.state.inExpressionEvaluation === false,\n            \"Already in expression evaluation?\"\n          );\n          this.state.inExpressionEvaluation = true;\n          break;\n\n        case ControlCommand.CommandType.EvalEnd:\n          this.Assert(\n            this.state.inExpressionEvaluation === true,\n            \"Not in expression evaluation mode\"\n          );\n          this.state.inExpressionEvaluation = false;\n          break;\n\n        case ControlCommand.CommandType.EvalOutput:\n          // If the expression turned out to be empty, there may not be anything on the stack\n          if (this.state.evaluationStack.length > 0) {\n            let output = this.state.PopEvaluationStack();\n\n            // Functions may evaluate to Void, in which case we skip output\n            if (!(output instanceof Void)) {\n              // TODO: Should we really always blanket convert to string?\n              // It would be okay to have numbers in the output stream the\n              // only problem is when exporting text for viewing, it skips over numbers etc.\n              let text = new StringValue(output.toString());\n\n              this.state.PushToOutputStream(text);\n            }\n          }\n          break;\n\n        case ControlCommand.CommandType.NoOp:\n          break;\n\n        case ControlCommand.CommandType.Duplicate:\n          this.state.PushEvaluationStack(this.state.PeekEvaluationStack());\n          break;\n\n        case ControlCommand.CommandType.PopEvaluatedValue:\n          this.state.PopEvaluationStack();\n          break;\n\n        case ControlCommand.CommandType.PopFunction:\n        case ControlCommand.CommandType.PopTunnel:\n          let popType =\n            evalCommand.commandType == ControlCommand.CommandType.PopFunction\n              ? PushPopType.Function\n              : PushPopType.Tunnel;\n\n          let overrideTunnelReturnTarget: DivertTargetValue | null = null;\n          if (popType == PushPopType.Tunnel) {\n            let popped = this.state.PopEvaluationStack();\n            // overrideTunnelReturnTarget = popped as DivertTargetValue;\n            overrideTunnelReturnTarget = asOrNull(popped, DivertTargetValue);\n            if (overrideTunnelReturnTarget === null) {\n              this.Assert(\n                popped instanceof Void,\n                \"Expected void if ->-> doesn't override target\"\n              );\n            }\n          }\n\n          if (this.state.TryExitFunctionEvaluationFromGame()) {\n            break;\n          } else if (\n            this.state.callStack.currentElement.type != popType ||\n            !this.state.callStack.canPop\n          ) {\n            let names: Map<PushPopType, string> = new Map();\n            names.set(\n              PushPopType.Function,\n              \"function return statement (~ return)\"\n            );\n            names.set(PushPopType.Tunnel, \"tunnel onwards statement (->->)\");\n\n            let expected = names.get(this.state.callStack.currentElement.type);\n            if (!this.state.callStack.canPop) {\n              expected = \"end of flow (-> END or choice)\";\n            }\n\n            let errorMsg =\n              \"Found \" + names.get(popType) + \", when expected \" + expected;\n\n            this.Error(errorMsg);\n          } else {\n            this.state.PopCallStack();\n\n            if (overrideTunnelReturnTarget)\n              this.state.divertedPointer = this.PointerAtPath(\n                overrideTunnelReturnTarget.targetPath\n              );\n          }\n          break;\n\n        case ControlCommand.CommandType.BeginString:\n          this.state.PushToOutputStream(evalCommand);\n\n          this.Assert(\n            this.state.inExpressionEvaluation === true,\n            \"Expected to be in an expression when evaluating a string\"\n          );\n          this.state.inExpressionEvaluation = false;\n          break;\n\n        // Leave it to story.currentText and story.currentTags to sort out the text from the tags\n        // This is mostly because we can't always rely on the existence of EndTag, and we don't want\n        // to try and flatten dynamic tags to strings every time \\n is pushed to output\n        case ControlCommand.CommandType.BeginTag:\n          this.state.PushToOutputStream(evalCommand);\n          break;\n\n        // EndTag has 2 modes:\n        //  - When in string evaluation (for choices)\n        //  - Normal\n        //\n        // The only way you could have an EndTag in the middle of\n        // string evaluation is if we're currently generating text for a\n        // choice, such as:\n        //\n        //   + choice # tag\n        //\n        // In the above case, the ink will be run twice:\n        //  - First, to generate the choice text. String evaluation\n        //    will be on, and the final string will be pushed to the\n        //    evaluation stack, ready to be popped to make a Choice\n        //    object.\n        //  - Second, when ink generates text after choosing the choice.\n        //    On this ocassion, it's not in string evaluation mode.\n        //\n        // On the writing side, we disallow manually putting tags within\n        // strings like this:\n        //\n        //   {\"hello # world\"}\n        //\n        // So we know that the tag must be being generated as part of\n        // choice content. Therefore, when the tag has been generated,\n        // we push it onto the evaluation stack in the exact same way\n        // as the string for the choice content.\n        case ControlCommand.CommandType.EndTag: {\n          if (this.state.inStringEvaluation) {\n            let contentStackForTag: InkObject[] = [];\n            let outputCountConsumed = 0;\n            for (let i = this.state.outputStream.length - 1; i >= 0; --i) {\n              let obj = this.state.outputStream[i];\n              outputCountConsumed++;\n\n              // var command = obj as ControlCommand;\n              let command = asOrNull(obj, ControlCommand);\n              if (command != null) {\n                if (\n                  command.commandType == ControlCommand.CommandType.BeginTag\n                ) {\n                  break;\n                } else {\n                  this.Error(\n                    \"Unexpected ControlCommand while extracting tag from choice\"\n                  );\n                  break;\n                }\n              }\n              if (obj instanceof StringValue) {\n                contentStackForTag.push(obj);\n              }\n            }\n\n            // Consume the content that was produced for this string\n            this.state.PopFromOutputStream(outputCountConsumed);\n            // Build string out of the content we collected\n            let sb = new StringBuilder();\n            for (let strVal of contentStackForTag.reverse()) {\n              sb.Append(strVal.toString());\n            }\n            let choiceTag = new Tag(\n              this.state.CleanOutputWhitespace(sb.toString())\n            );\n            // Pushing to the evaluation stack means it gets picked up\n            // when a Choice is generated from the next Choice Point.\n            this.state.PushEvaluationStack(choiceTag);\n          } else {\n            // Otherwise! Simply push EndTag, so that in the output stream we\n            // have a structure of: [BeginTag, \"the tag content\", EndTag]\n            this.state.PushToOutputStream(evalCommand);\n          }\n          break;\n        }\n\n        case ControlCommand.CommandType.EndString: {\n          let contentStackForString: InkObject[] = [];\n          let contentToRetain: InkObject[] = [];\n\n          let outputCountConsumed = 0;\n          for (let i = this.state.outputStream.length - 1; i >= 0; --i) {\n            let obj = this.state.outputStream[i];\n\n            outputCountConsumed++;\n\n            // var command = obj as ControlCommand;\n            let command = asOrNull(obj, ControlCommand);\n            if (\n              command &&\n              command.commandType == ControlCommand.CommandType.BeginString\n            ) {\n              break;\n            }\n            if (obj instanceof Tag) {\n              contentToRetain.push(obj);\n            }\n            if (obj instanceof StringValue) {\n              contentStackForString.push(obj);\n            }\n          }\n\n          // Consume the content that was produced for this string\n          this.state.PopFromOutputStream(outputCountConsumed);\n\n          // Rescue the tags that we want actually to keep on the output stack\n          // rather than consume as part of the string we're building.\n          // At the time of writing, this only applies to Tag objects generated\n          // by choices, which are pushed to the stack during string generation.\n          for (let rescuedTag of contentToRetain)\n            this.state.PushToOutputStream(rescuedTag);\n\n          // The C# version uses a Stack for contentStackForString, but we're\n          // using a simple array, so we need to reverse it before using it\n          contentStackForString = contentStackForString.reverse();\n\n          // Build string out of the content we collected\n          let sb = new StringBuilder();\n          for (let c of contentStackForString) {\n            sb.Append(c.toString());\n          }\n\n          // Return to expression evaluation (from content mode)\n          this.state.inExpressionEvaluation = true;\n          this.state.PushEvaluationStack(new StringValue(sb.toString()));\n          break;\n        }\n\n        case ControlCommand.CommandType.ChoiceCount:\n          let choiceCount = this.state.generatedChoices.length;\n          this.state.PushEvaluationStack(new IntValue(choiceCount));\n          break;\n\n        case ControlCommand.CommandType.Turns:\n          this.state.PushEvaluationStack(\n            new IntValue(this.state.currentTurnIndex + 1)\n          );\n          break;\n\n        case ControlCommand.CommandType.TurnsSince:\n        case ControlCommand.CommandType.ReadCount:\n          let target = this.state.PopEvaluationStack();\n          if (!(target instanceof DivertTargetValue)) {\n            let extraNote = \"\";\n            if (target instanceof IntValue)\n              extraNote =\n                \". Did you accidentally pass a read count ('knot_name') instead of a target ('-> knot_name')?\";\n            this.Error(\n              \"TURNS_SINCE / READ_COUNT expected a divert target (knot, stitch, label name), but saw \" +\n                target +\n                extraNote\n            );\n            break;\n          }\n\n          // var divertTarget = target as DivertTargetValue;\n          let divertTarget = asOrThrows(target, DivertTargetValue);\n          // var container = ContentAtPath (divertTarget.targetPath).correctObj as Container;\n          let container = asOrNull(\n            this.ContentAtPath(divertTarget.targetPath).correctObj,\n            Container\n          );\n\n          let eitherCount;\n          if (container != null) {\n            if (\n              evalCommand.commandType == ControlCommand.CommandType.TurnsSince\n            )\n              eitherCount = this.state.TurnsSinceForContainer(container);\n            else eitherCount = this.state.VisitCountForContainer(container);\n          } else {\n            if (\n              evalCommand.commandType == ControlCommand.CommandType.TurnsSince\n            )\n              eitherCount = -1;\n            else eitherCount = 0;\n\n            this.Warning(\n              \"Failed to find container for \" +\n                evalCommand.toString() +\n                \" lookup at \" +\n                divertTarget.targetPath.toString()\n            );\n          }\n\n          this.state.PushEvaluationStack(new IntValue(eitherCount));\n          break;\n\n        case ControlCommand.CommandType.Random: {\n          let maxInt = asOrNull(this.state.PopEvaluationStack(), IntValue);\n          let minInt = asOrNull(this.state.PopEvaluationStack(), IntValue);\n\n          if (minInt == null || minInt instanceof IntValue === false)\n            return this.Error(\n              \"Invalid value for minimum parameter of RANDOM(min, max)\"\n            );\n\n          if (maxInt == null || maxInt instanceof IntValue === false)\n            return this.Error(\n              \"Invalid value for maximum parameter of RANDOM(min, max)\"\n            );\n\n          // Originally a primitive type, but here, can be null.\n          // TODO: Replace by default value?\n          if (maxInt.value === null) {\n            return throwNullException(\"maxInt.value\");\n          }\n          if (minInt.value === null) {\n            return throwNullException(\"minInt.value\");\n          }\n\n          // This code is differs a bit from the reference implementation, since\n          // JavaScript has no true integers. Hence integer arithmetics and\n          // interger overflows don't apply here. A loss of precision can\n          // happen with big numbers however.\n          //\n          // The case where 'randomRange' is lower than zero is handled below,\n          // so there's no need to test against Number.MIN_SAFE_INTEGER.\n          let randomRange = maxInt.value - minInt.value + 1;\n          if (!isFinite(randomRange) || randomRange > Number.MAX_SAFE_INTEGER) {\n            randomRange = Number.MAX_SAFE_INTEGER;\n            this.Error(\n              \"RANDOM was called with a range that exceeds the size that ink numbers can use.\"\n            );\n          }\n          if (randomRange <= 0)\n            this.Error(\n              \"RANDOM was called with minimum as \" +\n                minInt.value +\n                \" and maximum as \" +\n                maxInt.value +\n                \". The maximum must be larger\"\n            );\n\n          let resultSeed = this.state.storySeed + this.state.previousRandom;\n          let random = new PRNG(resultSeed);\n\n          let nextRandom = random.next();\n          let chosenValue = (nextRandom % randomRange) + minInt.value;\n          this.state.PushEvaluationStack(new IntValue(chosenValue));\n\n          // Next random number (rather than keeping the Random object around)\n          this.state.previousRandom = nextRandom;\n          break;\n        }\n\n        case ControlCommand.CommandType.SeedRandom:\n          let seed = asOrNull(this.state.PopEvaluationStack(), IntValue);\n          if (seed == null || seed instanceof IntValue === false)\n            return this.Error(\"Invalid value passed to SEED_RANDOM\");\n\n          // Originally a primitive type, but here, can be null.\n          // TODO: Replace by default value?\n          if (seed.value === null) {\n            return throwNullException(\"minInt.value\");\n          }\n\n          this.state.storySeed = seed.value;\n          this.state.previousRandom = 0;\n\n          this.state.PushEvaluationStack(new Void());\n          break;\n\n        case ControlCommand.CommandType.VisitIndex:\n          let count =\n            this.state.VisitCountForContainer(\n              this.state.currentPointer.container\n            ) - 1; // index not count\n          this.state.PushEvaluationStack(new IntValue(count));\n          break;\n\n        case ControlCommand.CommandType.SequenceShuffleIndex:\n          let shuffleIndex = this.NextSequenceShuffleIndex();\n          this.state.PushEvaluationStack(new IntValue(shuffleIndex));\n          break;\n\n        case ControlCommand.CommandType.StartThread:\n          // Handled in main step function\n          break;\n\n        case ControlCommand.CommandType.Done:\n          // We may exist in the context of the initial\n          // act of creating the thread, or in the context of\n          // evaluating the content.\n          if (this.state.callStack.canPopThread) {\n            this.state.callStack.PopThread();\n          }\n\n          // In normal flow - allow safe exit without warning\n          else {\n            this.state.didSafeExit = true;\n\n            // Stop flow in current thread\n            this.state.currentPointer = Pointer.Null;\n          }\n\n          break;\n\n        // Force flow to end completely\n        case ControlCommand.CommandType.End:\n          this.state.ForceEnd();\n          break;\n\n        case ControlCommand.CommandType.ListFromInt:\n          // var intVal = state.PopEvaluationStack () as IntValue;\n          let intVal = asOrNull(this.state.PopEvaluationStack(), IntValue);\n          // var listNameVal = state.PopEvaluationStack () as StringValue;\n          let listNameVal = asOrThrows(\n            this.state.PopEvaluationStack(),\n            StringValue\n          );\n\n          if (intVal === null) {\n            throw new StoryException(\n              \"Passed non-integer when creating a list element from a numerical value.\"\n            );\n          }\n\n          let generatedListValue = null;\n\n          if (this.listDefinitions === null) {\n            return throwNullException(\"this.listDefinitions\");\n          }\n          let foundListDef = this.listDefinitions.TryListGetDefinition(\n            listNameVal.value,\n            null\n          );\n          if (foundListDef.exists) {\n            // Originally a primitive type, but here, can be null.\n            // TODO: Replace by default value?\n            if (intVal.value === null) {\n              return throwNullException(\"minInt.value\");\n            }\n\n            let foundItem = foundListDef.result!.TryGetItemWithValue(\n              intVal.value,\n              InkListItem.Null\n            );\n            if (foundItem.exists) {\n              generatedListValue = new ListValue(\n                foundItem.result!,\n                intVal.value\n              );\n            }\n          } else {\n            throw new StoryException(\n              \"Failed to find LIST called \" + listNameVal.value\n            );\n          }\n\n          if (generatedListValue == null) generatedListValue = new ListValue();\n\n          this.state.PushEvaluationStack(generatedListValue);\n          break;\n\n        case ControlCommand.CommandType.ListRange:\n          let max = asOrNull(this.state.PopEvaluationStack(), Value);\n          let min = asOrNull(this.state.PopEvaluationStack(), Value);\n\n          // var targetList = state.PopEvaluationStack () as ListValue;\n          let targetList = asOrNull(this.state.PopEvaluationStack(), ListValue);\n\n          if (targetList === null || min === null || max === null)\n            throw new StoryException(\n              \"Expected list, minimum and maximum for LIST_RANGE\"\n            );\n\n          if (targetList.value === null) {\n            return throwNullException(\"targetList.value\");\n          }\n          let result = targetList.value.ListWithSubRange(\n            min.valueObject,\n            max.valueObject\n          );\n\n          this.state.PushEvaluationStack(new ListValue(result));\n          break;\n\n        case ControlCommand.CommandType.ListRandom: {\n          let listVal = this.state.PopEvaluationStack() as ListValue;\n          if (listVal === null)\n            throw new StoryException(\"Expected list for LIST_RANDOM\");\n\n          let list = listVal.value;\n\n          let newList: InkList | null = null;\n\n          if (list === null) {\n            throw throwNullException(\"list\");\n          }\n          if (list.Count == 0) {\n            newList = new InkList();\n          } else {\n            // Generate a random index for the element to take\n            let resultSeed = this.state.storySeed + this.state.previousRandom;\n            let random = new PRNG(resultSeed);\n\n            let nextRandom = random.next();\n            let listItemIndex = nextRandom % list.Count;\n\n            // This bit is a little different from the original\n            // C# code, since iterators do not work in the same way.\n            // First, we iterate listItemIndex - 1 times, calling next().\n            // The listItemIndex-th time is made outside of the loop,\n            // in order to retrieve the value.\n            let listEnumerator = list.entries();\n            for (let i = 0; i <= listItemIndex - 1; i++) {\n              listEnumerator.next();\n            }\n            let value = listEnumerator.next().value;\n            let randomItem: KeyValuePair<InkListItem, number> = {\n              Key: InkListItem.fromSerializedKey(value[0]),\n              Value: value[1],\n            };\n\n            // Origin list is simply the origin of the one element\n            if (randomItem.Key.originName === null) {\n              return throwNullException(\"randomItem.Key.originName\");\n            }\n            newList = new InkList(randomItem.Key.originName, this);\n            newList.Add(randomItem.Key, randomItem.Value);\n\n            this.state.previousRandom = nextRandom;\n          }\n\n          this.state.PushEvaluationStack(new ListValue(newList));\n          break;\n        }\n\n        default:\n          this.Error(\"unhandled ControlCommand: \" + evalCommand);\n          break;\n      }\n\n      return true;\n    }\n\n    // Variable assignment\n    else if (contentObj instanceof VariableAssignment) {\n      let varAss = contentObj;\n      let assignedVal = this.state.PopEvaluationStack();\n\n      this.state.variablesState.Assign(varAss, assignedVal);\n\n      return true;\n    }\n\n    // Variable reference\n    else if (contentObj instanceof VariableReference) {\n      let varRef = contentObj;\n      let foundValue = null;\n\n      // Explicit read count value\n      if (varRef.pathForCount != null) {\n        let container = varRef.containerForCount;\n        let count = this.state.VisitCountForContainer(container);\n        foundValue = new IntValue(count);\n      }\n\n      // Normal variable reference\n      else {\n        foundValue = this.state.variablesState.GetVariableWithName(varRef.name);\n\n        if (foundValue == null) {\n          this.Warning(\n            \"Variable not found: '\" +\n              varRef.name +\n              \"'. Using default value of 0 (false). This can happen with temporary variables if the declaration hasn't yet been hit. Globals are always given a default value on load if a value doesn't exist in the save state.\"\n          );\n          foundValue = new IntValue(0);\n        }\n      }\n\n      this.state.PushEvaluationStack(foundValue);\n\n      return true;\n    }\n\n    // Native function call\n    else if (contentObj instanceof NativeFunctionCall) {\n      let func = contentObj;\n      let funcParams = this.state.PopEvaluationStack(func.numberOfParameters);\n      let result = func.Call(funcParams);\n      this.state.PushEvaluationStack(result);\n      return true;\n    }\n\n    // No control content, must be ordinary content\n    return false;\n  }\n\n  public ChoosePathString(\n    path: string,\n    resetCallstack = true,\n    args: any[] = []\n  ) {\n    this.IfAsyncWeCant(\"call ChoosePathString right now\");\n    if (this.onChoosePathString !== null) this.onChoosePathString(path, args);\n\n    if (resetCallstack) {\n      this.ResetCallstack();\n    } else {\n      if (this.state.callStack.currentElement.type == PushPopType.Function) {\n        let funcDetail = \"\";\n        let container =\n          this.state.callStack.currentElement.currentPointer.container;\n        if (container != null) {\n          funcDetail = \"(\" + container.path.toString() + \") \";\n        }\n        throw new Error(\n          \"Story was running a function \" +\n            funcDetail +\n            \"when you called ChoosePathString(\" +\n            path +\n            \") - this is almost certainly not not what you want! Full stack trace: \\n\" +\n            this.state.callStack.callStackTrace\n        );\n      }\n    }\n\n    this.state.PassArgumentsToEvaluationStack(args);\n    this.ChoosePath(new Path(path));\n  }\n\n  public IfAsyncWeCant(activityStr: string) {\n    if (this._asyncContinueActive)\n      throw new Error(\n        \"Can't \" +\n          activityStr +\n          \". Story is in the middle of a ContinueAsync(). Make more ContinueAsync() calls or a single Continue() call beforehand.\"\n      );\n  }\n\n  public ChoosePath(p: Path, incrementingTurnIndex: boolean = true) {\n    this.state.SetChosenPath(p, incrementingTurnIndex);\n\n    // Take a note of newly visited containers for read counts etc\n    this.VisitChangedContainersDueToDivert();\n  }\n\n  public ChooseChoiceIndex(choiceIdx: number) {\n    choiceIdx = choiceIdx;\n    let choices = this.currentChoices;\n    this.Assert(\n      choiceIdx >= 0 && choiceIdx < choices.length,\n      \"choice out of range\"\n    );\n\n    let choiceToChoose = choices[choiceIdx];\n    if (this.onMakeChoice !== null) this.onMakeChoice(choiceToChoose);\n\n    if (choiceToChoose.threadAtGeneration === null) {\n      return throwNullException(\"choiceToChoose.threadAtGeneration\");\n    }\n    if (choiceToChoose.targetPath === null) {\n      return throwNullException(\"choiceToChoose.targetPath\");\n    }\n\n    this.state.callStack.currentThread = choiceToChoose.threadAtGeneration;\n\n    this.ChoosePath(choiceToChoose.targetPath);\n  }\n\n  public HasFunction(functionName: string) {\n    try {\n      return this.KnotContainerWithName(functionName) != null;\n    } catch (e) {\n      return false;\n    }\n  }\n\n  public EvaluateFunction(\n    functionName: string,\n    args: any[] = [],\n    returnTextOutput: boolean = false\n  ): Story.EvaluateFunctionTextOutput | any {\n    // EvaluateFunction behaves slightly differently than the C# version.\n    // In C#, you can pass a (second) parameter `out textOutput` to get the\n    // text outputted by the function. This is not possible in js. Instead,\n    // we maintain the regular signature (functionName, args), plus an\n    // optional third parameter returnTextOutput. If set to true, we will\n    // return both the textOutput and the returned value, as an object.\n\n    if (this.onEvaluateFunction !== null)\n      this.onEvaluateFunction(functionName, args);\n\n    this.IfAsyncWeCant(\"evaluate a function\");\n\n    if (functionName == null) {\n      throw new Error(\"Function is null\");\n    } else if (functionName == \"\" || functionName.trim() == \"\") {\n      throw new Error(\"Function is empty or white space.\");\n    }\n\n    let funcContainer = this.KnotContainerWithName(functionName);\n    if (funcContainer == null) {\n      throw new Error(\"Function doesn't exist: '\" + functionName + \"'\");\n    }\n\n    let outputStreamBefore: InkObject[] = [];\n    outputStreamBefore.push(...this.state.outputStream);\n    this._state.ResetOutput();\n\n    this.state.StartFunctionEvaluationFromGame(funcContainer, args);\n\n    // Evaluate the function, and collect the string output\n    let stringOutput = new StringBuilder();\n    while (this.canContinue) {\n      stringOutput.Append(this.Continue());\n    }\n    let textOutput = stringOutput.toString();\n\n    this._state.ResetOutput(outputStreamBefore);\n\n    let result = this.state.CompleteFunctionEvaluationFromGame();\n    if (this.onCompleteEvaluateFunction != null)\n      this.onCompleteEvaluateFunction(functionName, args, textOutput, result);\n\n    return returnTextOutput ? { returned: result, output: textOutput } : result;\n  }\n\n  public EvaluateExpression(exprContainer: Container) {\n    let startCallStackHeight = this.state.callStack.elements.length;\n\n    this.state.callStack.Push(PushPopType.Tunnel);\n\n    this._temporaryEvaluationContainer = exprContainer;\n\n    this.state.GoToStart();\n\n    let evalStackHeight = this.state.evaluationStack.length;\n\n    this.Continue();\n\n    this._temporaryEvaluationContainer = null;\n\n    // Should have fallen off the end of the Container, which should\n    // have auto-popped, but just in case we didn't for some reason,\n    // manually pop to restore the state (including currentPath).\n    if (this.state.callStack.elements.length > startCallStackHeight) {\n      this.state.PopCallStack();\n    }\n\n    let endStackHeight = this.state.evaluationStack.length;\n    if (endStackHeight > evalStackHeight) {\n      return this.state.PopEvaluationStack();\n    } else {\n      return null;\n    }\n  }\n\n  public allowExternalFunctionFallbacks: boolean = false;\n\n  public CallExternalFunction(\n    funcName: string | null,\n    numberOfArguments: number\n  ) {\n    if (funcName === null) {\n      return throwNullException(\"funcName\");\n    }\n    let funcDef = this._externals.get(funcName);\n    let fallbackFunctionContainer = null;\n\n    let foundExternal = typeof funcDef !== \"undefined\";\n\n    if (\n      foundExternal &&\n      !funcDef!.lookAheadSafe &&\n      this._stateSnapshotAtLastNewline !== null\n    ) {\n      this._sawLookaheadUnsafeFunctionAfterNewline = true;\n      return;\n    }\n\n    if (!foundExternal) {\n      if (this.allowExternalFunctionFallbacks) {\n        fallbackFunctionContainer = this.KnotContainerWithName(funcName);\n        this.Assert(\n          fallbackFunctionContainer !== null,\n          \"Trying to call EXTERNAL function '\" +\n            funcName +\n            \"' which has not been bound, and fallback ink function could not be found.\"\n        );\n\n        // Divert direct into fallback function and we're done\n        this.state.callStack.Push(\n          PushPopType.Function,\n          undefined,\n          this.state.outputStream.length\n        );\n        this.state.divertedPointer = Pointer.StartOf(fallbackFunctionContainer);\n        return;\n      } else {\n        this.Assert(\n          false,\n          \"Trying to call EXTERNAL function '\" +\n            funcName +\n            \"' which has not been bound (and ink fallbacks disabled).\"\n        );\n      }\n    }\n\n    // Pop arguments\n    let args: any[] = [];\n    for (let i = 0; i < numberOfArguments; ++i) {\n      // var poppedObj = state.PopEvaluationStack () as Value;\n      let poppedObj = asOrThrows(this.state.PopEvaluationStack(), Value);\n      let valueObj = poppedObj.valueObject;\n      args.push(valueObj);\n    }\n\n    // Reverse arguments from the order they were popped,\n    // so they're the right way round again.\n    args.reverse();\n\n    // Run the function!\n    let funcResult = funcDef!.function(args);\n\n    // Convert return value (if any) to the a type that the ink engine can use\n    let returnObj = null;\n    if (funcResult != null) {\n      returnObj = Value.Create(funcResult);\n      this.Assert(\n        returnObj !== null,\n        \"Could not create ink value from returned object of type \" +\n          typeof funcResult\n      );\n    } else {\n      returnObj = new Void();\n    }\n\n    this.state.PushEvaluationStack(returnObj);\n  }\n\n  public BindExternalFunctionGeneral(\n    funcName: string,\n    func: Story.ExternalFunction,\n    lookaheadSafe: boolean = true\n  ) {\n    this.IfAsyncWeCant(\"bind an external function\");\n    this.Assert(\n      !this._externals.has(funcName),\n      \"Function '\" + funcName + \"' has already been bound.\"\n    );\n    this._externals.set(funcName, {\n      function: func,\n      lookAheadSafe: lookaheadSafe,\n    });\n  }\n\n  public TryCoerce(value: any) {\n    // We're skipping type coercition in this implementation. First of, js\n    // is loosely typed, so it's not that important. Secondly, there is no\n    // clean way (AFAIK) for the user to describe what type of parameters\n    // they expect.\n    return value;\n  }\n\n  public BindExternalFunction(\n    funcName: string,\n    func: Story.ExternalFunction,\n    lookaheadSafe: boolean = false\n  ) {\n    this.Assert(func != null, \"Can't bind a null function\");\n\n    this.BindExternalFunctionGeneral(\n      funcName,\n      (args: any) => {\n        this.Assert(\n          args.length >= func.length,\n          \"External function expected \" + func.length + \" arguments\"\n        );\n\n        let coercedArgs = [];\n        for (let i = 0, l = args.length; i < l; i++) {\n          coercedArgs[i] = this.TryCoerce(args[i]);\n        }\n        return func.apply(null, coercedArgs);\n      },\n      lookaheadSafe\n    );\n  }\n\n  public UnbindExternalFunction(funcName: string) {\n    this.IfAsyncWeCant(\"unbind an external a function\");\n    this.Assert(\n      this._externals.has(funcName),\n      \"Function '\" + funcName + \"' has not been bound.\"\n    );\n    this._externals.delete(funcName);\n  }\n\n  public ValidateExternalBindings(): void;\n  public ValidateExternalBindings(\n    c: Container | null,\n    missingExternals: Set<string>\n  ): void;\n  public ValidateExternalBindings(\n    o: InkObject | null,\n    missingExternals: Set<string>\n  ): void;\n  public ValidateExternalBindings() {\n    let c: Container | null = null;\n    let o: InkObject | null = null;\n    let missingExternals: Set<string> = arguments[1] || new Set();\n\n    if (arguments[0] instanceof Container) {\n      c = arguments[0];\n    }\n\n    if (arguments[0] instanceof InkObject) {\n      o = arguments[0];\n    }\n\n    if (c === null && o === null) {\n      this.ValidateExternalBindings(\n        this._mainContentContainer,\n        missingExternals\n      );\n      this._hasValidatedExternals = true;\n\n      // No problem! Validation complete\n      if (missingExternals.size == 0) {\n        this._hasValidatedExternals = true;\n      } else {\n        let message = \"Error: Missing function binding for external\";\n        message += missingExternals.size > 1 ? \"s\" : \"\";\n        message += \": '\";\n        message += Array.from(missingExternals).join(\"', '\");\n        message += \"' \";\n        message += this.allowExternalFunctionFallbacks\n          ? \", and no fallback ink function found.\"\n          : \" (ink fallbacks disabled)\";\n\n        this.Error(message);\n      }\n    } else if (c != null) {\n      for (let innerContent of c.content) {\n        let container = innerContent as Container;\n        if (container == null || !container.hasValidName)\n          this.ValidateExternalBindings(innerContent, missingExternals);\n      }\n      for (let [, value] of c.namedContent) {\n        this.ValidateExternalBindings(\n          asOrNull(value, InkObject),\n          missingExternals\n        );\n      }\n    } else if (o != null) {\n      let divert = asOrNull(o, Divert);\n      if (divert && divert.isExternal) {\n        let name = divert.targetPathString;\n        if (name === null) {\n          return throwNullException(\"name\");\n        }\n        if (!this._externals.has(name)) {\n          if (this.allowExternalFunctionFallbacks) {\n            let fallbackFound =\n              this.mainContentContainer.namedContent.has(name);\n            if (!fallbackFound) {\n              missingExternals.add(name);\n            }\n          } else {\n            missingExternals.add(name);\n          }\n        }\n      }\n    }\n  }\n\n  public ObserveVariable(\n    variableName: string,\n    observer: Story.VariableObserver\n  ) {\n    this.IfAsyncWeCant(\"observe a new variable\");\n\n    if (this._variableObservers === null) this._variableObservers = new Map();\n\n    if (!this.state.variablesState.GlobalVariableExistsWithName(variableName))\n      throw new Error(\n        \"Cannot observe variable '\" +\n          variableName +\n          \"' because it wasn't declared in the ink story.\"\n      );\n\n    if (this._variableObservers.has(variableName)) {\n      this._variableObservers.get(variableName)!.push(observer);\n    } else {\n      this._variableObservers.set(variableName, [observer]);\n    }\n  }\n\n  public ObserveVariables(\n    variableNames: string[],\n    observers: Story.VariableObserver[]\n  ) {\n    for (let i = 0, l = variableNames.length; i < l; i++) {\n      this.ObserveVariable(variableNames[i], observers[i]);\n    }\n  }\n\n  public RemoveVariableObserver(\n    observer?: Story.VariableObserver,\n    specificVariableName?: string\n  ) {\n    // A couple of things to know about this method:\n    //\n    // 1. Since `RemoveVariableObserver` is exposed to the JavaScript world,\n    //    optionality is marked as `undefined` rather than `null`.\n    //    To keep things simple, null-checks are performed using regular\n    //    equality operators, where undefined == null.\n    //\n    // 2. Since C# delegates are translated to arrays of functions,\n    //    -= becomes a call to splice and null-checks are replaced by\n    //    emptiness-checks.\n    //\n    this.IfAsyncWeCant(\"remove a variable observer\");\n\n    if (this._variableObservers === null) return;\n\n    if (specificVariableName != null) {\n      if (this._variableObservers.has(specificVariableName)) {\n        if (observer != null) {\n          let variableObservers =\n            this._variableObservers.get(specificVariableName);\n          if (variableObservers != null) {\n            variableObservers.splice(variableObservers.indexOf(observer), 1);\n            if (variableObservers.length === 0) {\n              this._variableObservers.delete(specificVariableName);\n            }\n          }\n        } else {\n          this._variableObservers.delete(specificVariableName);\n        }\n      }\n    } else if (observer != null) {\n      let keys = this._variableObservers.keys();\n      for (let varName of keys) {\n        let variableObservers = this._variableObservers.get(varName);\n        if (variableObservers != null) {\n          variableObservers.splice(variableObservers.indexOf(observer), 1);\n          if (variableObservers.length === 0) {\n            this._variableObservers.delete(varName);\n          }\n        }\n      }\n    }\n  }\n\n  public VariableStateDidChangeEvent(\n    variableName: string,\n    newValueObj: InkObject\n  ) {\n    if (this._variableObservers === null) return;\n\n    let observers = this._variableObservers.get(variableName);\n    if (typeof observers !== \"undefined\") {\n      if (!(newValueObj instanceof Value)) {\n        throw new Error(\n          \"Tried to get the value of a variable that isn't a standard type\"\n        );\n      }\n      // var val = newValueObj as Value;\n      let val = asOrThrows(newValueObj, Value);\n\n      for (let observer of observers) {\n        observer(variableName, val.valueObject);\n      }\n    }\n  }\n\n  get globalTags() {\n    return this.TagsAtStartOfFlowContainerWithPathString(\"\");\n  }\n\n  public TagsForContentAtPath(path: string) {\n    return this.TagsAtStartOfFlowContainerWithPathString(path);\n  }\n\n  public TagsAtStartOfFlowContainerWithPathString(pathString: string) {\n    let path = new Path(pathString);\n\n    let flowContainer = this.ContentAtPath(path).container;\n    if (flowContainer === null) {\n      return throwNullException(\"flowContainer\");\n    }\n    while (true) {\n      let firstContent: InkObject = flowContainer.content[0];\n      if (firstContent instanceof Container) flowContainer = firstContent;\n      else break;\n    }\n\n    let inTag = false;\n    let tags: string[] | null = null;\n\n    for (let c of flowContainer.content) {\n      // var tag = c as Runtime.Tag;\n      let command = asOrNull(c, ControlCommand);\n\n      if (command != null) {\n        if (command.commandType == ControlCommand.CommandType.BeginTag) {\n          inTag = true;\n        } else if (command.commandType == ControlCommand.CommandType.EndTag) {\n          inTag = false;\n        }\n      } else if (inTag) {\n        let str = asOrNull(c, StringValue);\n        if (str !== null) {\n          if (tags === null) tags = [];\n          if (str.value !== null) tags.push(str.value);\n        } else {\n          this.Error(\n            \"Tag contained non-text content. Only plain text is allowed when using globalTags or TagsAtContentPath. If you want to evaluate dynamic content, you need to use story.Continue().\"\n          );\n        }\n      } else {\n        break;\n      }\n    }\n\n    return tags;\n  }\n\n  public BuildStringOfHierarchy() {\n    let sb = new StringBuilder();\n\n    this.mainContentContainer.BuildStringOfHierarchy(\n      sb,\n      0,\n      this.state.currentPointer.Resolve()\n    );\n\n    return sb.toString();\n  }\n\n  public BuildStringOfContainer(container: Container) {\n    let sb = new StringBuilder();\n    container.BuildStringOfHierarchy(\n      sb,\n      0,\n      this.state.currentPointer.Resolve()\n    );\n    return sb.toString();\n  }\n\n  public NextContent() {\n    this.state.previousPointer = this.state.currentPointer.copy();\n\n    if (!this.state.divertedPointer.isNull) {\n      this.state.currentPointer = this.state.divertedPointer.copy();\n      this.state.divertedPointer = Pointer.Null;\n\n      this.VisitChangedContainersDueToDivert();\n\n      if (!this.state.currentPointer.isNull) {\n        return;\n      }\n    }\n\n    let successfulPointerIncrement = this.IncrementContentPointer();\n\n    if (!successfulPointerIncrement) {\n      let didPop = false;\n\n      if (this.state.callStack.CanPop(PushPopType.Function)) {\n        this.state.PopCallStack(PushPopType.Function);\n\n        if (this.state.inExpressionEvaluation) {\n          this.state.PushEvaluationStack(new Void());\n        }\n\n        didPop = true;\n      } else if (this.state.callStack.canPopThread) {\n        this.state.callStack.PopThread();\n\n        didPop = true;\n      } else {\n        this.state.TryExitFunctionEvaluationFromGame();\n      }\n\n      if (didPop && !this.state.currentPointer.isNull) {\n        this.NextContent();\n      }\n    }\n  }\n\n  public IncrementContentPointer() {\n    let successfulIncrement = true;\n\n    let pointer = this.state.callStack.currentElement.currentPointer.copy();\n    pointer.index++;\n\n    if (pointer.container === null) {\n      return throwNullException(\"pointer.container\");\n    }\n    while (pointer.index >= pointer.container.content.length) {\n      successfulIncrement = false;\n\n      // Container nextAncestor = pointer.container.parent as Container;\n      let nextAncestor = asOrNull(pointer.container.parent, Container);\n      if (nextAncestor instanceof Container === false) {\n        break;\n      }\n\n      let indexInAncestor = nextAncestor!.content.indexOf(pointer.container);\n      if (indexInAncestor == -1) {\n        break;\n      }\n\n      pointer = new Pointer(nextAncestor, indexInAncestor);\n\n      pointer.index++;\n\n      successfulIncrement = true;\n      if (pointer.container === null) {\n        return throwNullException(\"pointer.container\");\n      }\n    }\n\n    if (!successfulIncrement) pointer = Pointer.Null;\n\n    this.state.callStack.currentElement.currentPointer = pointer.copy();\n\n    return successfulIncrement;\n  }\n\n  public TryFollowDefaultInvisibleChoice() {\n    let allChoices = this._state.currentChoices;\n\n    let invisibleChoices = allChoices.filter((c) => c.isInvisibleDefault);\n\n    if (\n      invisibleChoices.length == 0 ||\n      allChoices.length > invisibleChoices.length\n    )\n      return false;\n\n    let choice = invisibleChoices[0];\n\n    if (choice.targetPath === null) {\n      return throwNullException(\"choice.targetPath\");\n    }\n\n    if (choice.threadAtGeneration === null) {\n      return throwNullException(\"choice.threadAtGeneration\");\n    }\n\n    this.state.callStack.currentThread = choice.threadAtGeneration;\n\n    if (this._stateSnapshotAtLastNewline !== null) {\n      this.state.callStack.currentThread = this.state.callStack.ForkThread();\n    }\n\n    this.ChoosePath(choice.targetPath, false);\n\n    return true;\n  }\n\n  public NextSequenceShuffleIndex() {\n    // var numElementsIntVal = state.PopEvaluationStack () as IntValue;\n    let numElementsIntVal = asOrNull(this.state.PopEvaluationStack(), IntValue);\n    if (!(numElementsIntVal instanceof IntValue)) {\n      this.Error(\"expected number of elements in sequence for shuffle index\");\n      return 0;\n    }\n\n    let seqContainer = this.state.currentPointer.container;\n    if (seqContainer === null) {\n      return throwNullException(\"seqContainer\");\n    }\n\n    // Originally a primitive type, but here, can be null.\n    // TODO: Replace by default value?\n    if (numElementsIntVal.value === null) {\n      return throwNullException(\"numElementsIntVal.value\");\n    }\n    let numElements = numElementsIntVal.value;\n\n    // var seqCountVal = state.PopEvaluationStack () as IntValue;\n    let seqCountVal = asOrThrows(this.state.PopEvaluationStack(), IntValue);\n    let seqCount = seqCountVal.value;\n\n    // Originally a primitive type, but here, can be null.\n    // TODO: Replace by default value?\n    if (seqCount === null) {\n      return throwNullException(\"seqCount\");\n    }\n\n    let loopIndex = seqCount / numElements;\n    let iterationIndex = seqCount % numElements;\n\n    let seqPathStr = seqContainer.path.toString();\n    let sequenceHash = 0;\n    for (let i = 0, l = seqPathStr.length; i < l; i++) {\n      sequenceHash += seqPathStr.charCodeAt(i) || 0;\n    }\n    let randomSeed = sequenceHash + loopIndex + this.state.storySeed;\n    let random = new PRNG(Math.floor(randomSeed));\n\n    let unpickedIndices = [];\n    for (let i = 0; i < numElements; ++i) {\n      unpickedIndices.push(i);\n    }\n\n    for (let i = 0; i <= iterationIndex; ++i) {\n      let chosen = random.next() % unpickedIndices.length;\n      let chosenIndex = unpickedIndices[chosen];\n      unpickedIndices.splice(chosen, 1);\n\n      if (i == iterationIndex) {\n        return chosenIndex;\n      }\n    }\n\n    throw new Error(\"Should never reach here\");\n  }\n\n  public Error(message: string, useEndLineNumber = false): never {\n    let e = new StoryException(message);\n    e.useEndLineNumber = useEndLineNumber;\n    throw e;\n  }\n\n  public Warning(message: string) {\n    this.AddError(message, true);\n  }\n\n  public AddError(\n    message: string,\n    isWarning = false,\n    useEndLineNumber = false\n  ) {\n    let dm = this.currentDebugMetadata;\n\n    let errorTypeStr = isWarning ? \"WARNING\" : \"ERROR\";\n\n    if (dm != null) {\n      let lineNum = useEndLineNumber ? dm.endLineNumber : dm.startLineNumber;\n      message =\n        \"RUNTIME \" +\n        errorTypeStr +\n        \": '\" +\n        dm.fileName +\n        \"' line \" +\n        lineNum +\n        \": \" +\n        message;\n    } else if (!this.state.currentPointer.isNull) {\n      message =\n        \"RUNTIME \" +\n        errorTypeStr +\n        \": (\" +\n        this.state.currentPointer +\n        \"): \" +\n        message;\n    } else {\n      message = \"RUNTIME \" + errorTypeStr + \": \" + message;\n    }\n\n    this.state.AddError(message, isWarning);\n\n    // In a broken state don't need to know about any other errors.\n    if (!isWarning) this.state.ForceEnd();\n  }\n\n  public Assert(condition: boolean, message: string | null = null) {\n    if (condition == false) {\n      if (message == null) {\n        message = \"Story assert\";\n      }\n\n      throw new Error(message + \" \" + this.currentDebugMetadata);\n    }\n  }\n\n  get currentDebugMetadata(): DebugMetadata | null {\n    let dm: DebugMetadata | null;\n\n    let pointer = this.state.currentPointer;\n    if (!pointer.isNull && pointer.Resolve() !== null) {\n      dm = pointer.Resolve()!.debugMetadata;\n      if (dm !== null) {\n        return dm;\n      }\n    }\n\n    for (let i = this.state.callStack.elements.length - 1; i >= 0; --i) {\n      pointer = this.state.callStack.elements[i].currentPointer;\n      if (!pointer.isNull && pointer.Resolve() !== null) {\n        dm = pointer.Resolve()!.debugMetadata;\n        if (dm !== null) {\n          return dm;\n        }\n      }\n    }\n\n    for (let i = this.state.outputStream.length - 1; i >= 0; --i) {\n      let outputObj = this.state.outputStream[i];\n      dm = outputObj.debugMetadata;\n      if (dm !== null) {\n        return dm;\n      }\n    }\n\n    return null;\n  }\n\n  get mainContentContainer() {\n    if (this._temporaryEvaluationContainer) {\n      return this._temporaryEvaluationContainer;\n    } else {\n      return this._mainContentContainer;\n    }\n  }\n\n  /**\n   * `_mainContentContainer` is almost guaranteed to be set in the\n   * constructor, unless the json is malformed.\n   */\n  private _mainContentContainer!: Container;\n  private _listDefinitions: ListDefinitionsOrigin | null = null;\n\n  private _externals: Map<string, Story.ExternalFunctionDef>;\n  private _variableObservers: Map<string, Story.VariableObserver[]> | null =\n    null;\n  private _hasValidatedExternals: boolean = false;\n\n  private _temporaryEvaluationContainer: Container | null = null;\n\n  /**\n   * `state` is almost guaranteed to be set in the constructor, unless\n   * using the compiler-specific constructor which will likely not be used in\n   * the real world.\n   */\n  private _state!: StoryState;\n\n  private _asyncContinueActive: boolean = false;\n  private _stateSnapshotAtLastNewline: StoryState | null = null;\n  private _sawLookaheadUnsafeFunctionAfterNewline: boolean = false;\n\n  private _recursiveContinueCount: number = 0;\n\n  private _asyncSaving: boolean = false;\n\n  private _profiler: any | null = null; // TODO: Profiler\n}\n\nexport namespace Story {\n  export enum OutputStateChange {\n    NoChange = 0,\n    ExtendedBeyondNewline = 1,\n    NewlineRemoved = 2,\n  }\n\n  export interface EvaluateFunctionTextOutput {\n    returned: any;\n    output: string;\n  }\n\n  export interface ExternalFunctionDef {\n    function: ExternalFunction;\n    lookAheadSafe: boolean;\n  }\n\n  export type VariableObserver = (variableName: string, newValue: any) => void;\n  export type ExternalFunction = (...args: any) => any;\n}\n"],"names":["Path","constructor","this","_components","_componentsString","_isRelative","arguments","componentsString","Component","head","tail","push","concat","Array","relative","isRelative","componentCount","length","tailComps","slice","self","lastComponent","lastComponentIdx","containsNamedComponent","i","l","isIndex","path","GetComponent","index","PathByAppendingPath","pathToAppend","p","upwardMoves","isParent","join","value","substring","componentStrings","split","str","test","parseInt","toString","Equals","otherPath","PathByAppendingComponent","c","Debug","ValueType","PushPopType","ErrorType","asOrNull","obj","type","unsafeTypeAssertion","asOrThrows","Error","asINamedContentOrNull","hasValidName","name","nullIfUndefined","isEquatable","parentId","indexOrName","static","otherComp","Assert","condition","message","console","warn","trace","AssertType","variable","NullException","throwNullException","InkObject","parent","_debugMetadata","_path","debugMetadata","ownDebugMetadata","DebugLineNumberOfPath","root","rootContentContainer","targetContent","ContentAtPath","dm","startLineNumber","comps","child","container","Container","namedChild","unshift","content","indexOf","ResolvePath","nearestContainer","contentContainer","ConvertPathToRelative","globalPath","ownPath","minPathLength","Math","min","lastSharedPathCompIndex","ownComp","numUpwardsMoves","newPathComps","up","ToParent","down","CompactPathString","globalPathStr","relativePathStr","ancestor","Copy","SetChild","prop","StringBuilder","string","Length","Append","AppendLine","AppendFormat","format","_len","args","_key","replace","match","num","Clear","InkListItem","originName","itemName","nameParts","Null","isNull","fullName","otherItem","copy","serialized","JSON","stringify","key","parse","isLikeInkListItem","inkListItem","item","hasOwnProperty","InkList","Map","super","origins","_originNames","otherList","otherOriginNames","originNames","singleOriginListName","originStory","SetInitialOriginName","listDefinitions","def","TryListGetDefinition","exists","result","singleElement","Add","Key","Value","myListItem","listValue","_a","FindSingleItemListWithName","AddItem","itemOrItemName","origin","intVal","TryGetValueForItem","foundListDef","ContainsItemWithName","itemVal","ValueForItem","ContainsItemNamed","fromSerializedKey","ContainsKey","has","serializedKey","set","Remove","delete","Count","size","originOfMaxItem","maxOriginName","maxItem","every","initialOriginName","SetInitialOriginNames","initialOriginNames","max","minItem","inverse","list","items","all","Union","union","Intersect","intersection","HasIntersection","Without","listToRemove","Contains","what","GreaterThan","GreaterThanOrEquals","LessThan","LessThanOrEquals","MaxAsList","MinAsList","ListWithSubRange","minBound","maxBound","ordered","orderedItems","minValue","maxValue","Number","MAX_SAFE_INTEGER","isInteger","subList","otherInkList","sort","x","y","localeCompare","sb","valueOf","NaN","StoryException","useEndLineNumber","tryGetValueFromMap","map","val","get","AbstractValue","preferredNumberType","Int","IntValue","Float","isNaN","FloatValue","BoolValue","Boolean","StringValue","String","DivertTargetValue","ListValue","Create","valueObject","BadCastException","targetType","valueType","isTruthy","Bool","Cast","newType","_isNewline","_isInlineWhitespace","isNewline","isInlineWhitespace","isNonWhitespace","parsedInt","defaultValue","tryParseInt","parsedFloat","parseFloat","tryParseFloat","DivertTarget","targetPath","VariablePointerValue","variableName","contextIndex","undefined","_contextIndex","VariablePointer","List","listOrSingleItem","singleValue","oldValue","newValue","oldList","newList","SearchResult","approximate","correctObj","searchResult","_content","namedContent","visitsShouldBeCounted","turnIndexShouldBeCounted","countingAtStartOnly","_pathToFirstLeafContent","AddContent","namedOnlyContent","namedOnlyContentDict","inkObject","named","existingNamedOnly","AddToNamedContentOnly","countFlags","flags","CountFlags","Visits","Turns","CountStartOnly","flag","pathToFirstLeafContent","internalPathToFirstLeafContent","components","contentObjOrList","contentList","contentObj","TryAddNamedContent","namedContentObj","partialPathStart","partialPathLength","currentContainer","currentObj","comp","foundObj","ContentWithPathComponent","InsertContent","splice","AddContentsOfContainer","otherContainer","component","foundContent","BuildStringOfHierarchy","indentation","pointedObj","appendIndentation","onlyNamed","Glue","ControlCommand","commandType","_commandType","CommandType","NotSet","EvalStart","EvalOutput","EvalEnd","Duplicate","PopEvaluatedValue","PopFunction","PopTunnel","BeginString","EndString","NoOp","ChoiceCount","TurnsSince","ReadCount","Random","SeedRandom","VisitIndex","SequenceShuffleIndex","StartThread","Done","End","ListFromInt","ListRange","ListRandom","BeginTag","EndTag","Pointer","Resolve","Divert","_targetPath","targetObj","targetPointer","_targetPointer","StartOf","targetPathString","hasVariableTarget","variableDivertName","stackPushType","pushesToStack","isExternal","externalArgs","isConditional","otherDivert","targetStr","Function","ChoicePoint","onceOnly","_pathOnChoice","hasCondition","hasStartContent","hasChoiceOnlyContent","isInvisibleDefault","pathOnChoice","choiceTargetObj","choiceTarget","pathStringOnChoice","VariableReference","containerForCount","pathForCount","pathStringForCount","VariableAssignment","isNewDeclaration","isGlobal","Void","NativeFunctionCall","functionName","GenerateNativeFunctionsIfNecessary","_nativeFunctions","_name","_isPrototype","_prototype","numberOfParameters","_numberOfParameters","Call","parameters","hasList","CallBinaryListOperation","coercedParams","CoerceValuesToSingleType","coercedType","CallType","parametersOfSingleType","param1","valType","val1","paramCount","_operationFuncs","opForTypeObj","val2","opForType","resultVal","CallListIncrementOperation","v1","v2","op","asBooleanOrThrows","listIntParams","listVal","resultInkList","listItemKey","listItemValue","listItem","intOp","targetInt","itemOrigin","incrementedItem","TryGetItemWithValue","parametersIn","specialCaseList","parametersOut","inkObjectVal","castedValue","t","AddIntBinaryOp","Subtract","Multiply","Divide","floor","Mod","AddIntUnaryOp","Negate","Equal","Greater","Less","NotEquals","Not","And","Or","Max","Min","Pow","pow","Floor","Identity","Ceiling","AddFloatBinaryOp","AddFloatUnaryOp","ceil","AddStringBinaryOp","Has","includes","Hasnt","AddListBinaryOp","AddListUnaryOp","Invert","All","ListMin","ListMax","ValueOfList","divertTargetsEqual","d1","d2","divertTargetsNotEqual","AddOpToNativeFunc","AddOpFuncForType","nativeFunc","Tag","tagText","text","Choice","threadAtGeneration","sourcePath","tags","originalThreadIndex","ListDefinition","_items","_itemNameToValues","ContainsItem","ListDefinitionsOrigin","lists","_lists","_allUnambiguousListValueCache","listOfLists","definition","JsonSerialisation","jArray","skipLast","count","jTok","runtimeObj","JTokenToRuntimeObject","writer","dictionary","WriteObjectStart","WritePropertyStart","WriteRuntimeObject","WritePropertyEnd","WriteObjectEnd","WriteArrayStart","WriteArrayEnd","dict","WriteIntProperty","WriteRuntimeContainer","divert","divTypeKey","Tunnel","WriteProperty","choicePoint","boolVal","WriteBool","WriteInt","floatVal","WriteFloat","strVal","Write","WriteStringStart","WriteStringInner","WriteStringEnd","WriteInkList","divTargetVal","varPtrVal","controlCmd","_controlCommandNames","varRef","readCountPath","varAss","tag","choice","WriteChoice","jObject","token","firstChar","CallExistsWithName","CallWithName","isArray","propValue","varPtr","isDivert","divPushType","external","target","readCountVarRef","isVarAss","isGlobalVar","varName","isNewDecl","listContent","rawList","namesAsObjs","nameToVal","JObjectToChoice","JArrayToContainer","toJson","me","removes","space","k","v","some","r","withoutName","hasNameProperty","hasTerminator","namedContainer","WriteNull","JArrayToRuntimeObjList","terminatingObj","namedContentItem","namedSubContainer","jObj","w","WritePropertyNameStart","WritePropertyNameInner","WritePropertyNameEnd","listDefJson","defsObj","allDefs","nameValueKey","nameValue","TOTAL_VALUES","CallStack","elements","callStack","depth","currentElement","cs","_threads","callstack","currentElementIndex","currentThread","canPop","_threadCounter","_startOfRoot","Story","storyContext","Reset","toCopy","otherThread","Thread","Element","SetJsonToken","jThreads","jThreadTok","jThreadObj","thread","WriteJson","WriteObject","PushThread","newThread","threadIndex","ForkThread","forkedThread","PopThread","canPopThread","elementIsEvaluateFromGame","FunctionEvaluationFromGame","Push","externalEvaluationStackHeight","outputStreamLengthWithPushed","element","currentPointer","evaluationStackHeightWhenPushed","functionStartInOutputStream","CanPop","Pop","pop","GetTemporaryVariableWithName","varValue","temporaryVariables","SetTemporaryVariable","declareNew","contextElement","RetainListOriginsForAssignment","ContextForVariableNamed","ThreadWithIndex","filtered","filter","callStackTrace","isCurrent","pointer","inExpressionEvaluation","previousPointer","jThreadCallstack","jElTok","currentContainerPathStr","jElementObj","pushPopType","currentContainerPathStrToken","threadPointerResult","Warning","el","temps","JObjectToDictionaryRuntimeObjs","clear","prevContentObjPath","prevPath","PointerAtPath","e","WriteDictionaryRuntimeObjs","resolvedPointer","VariablesState","variableChangedEvent","callback","variableChangedEventCallbacks","batchObservingVariableChanges","_batchObservingVariableChanges","_changedVariablesForBatchObs","Set","currentValue","_globalVariables","_callStack","$","varContents","patch","TryGetGlobal","_defaultGlobalVariables","SetGlobal","listDefsOrigin","_listDefsOrigin","Proxy","ApplyPatch","namedVarKey","namedVarValue","globals","changedVariables","add","jToken","varValKey","varValValue","loadedToken","tokenInkObject","keyValKey","keyValValue","dontSaveDefaultValues","defaultVal","RuntimeObjectsEqual","obj1","obj2","GetVariableWithName","GetRawVariableWithName","varPointer","ValueAtVariablePointer","TryGetDefaultVariableValue","GlobalVariableExistsWithName","variableValue","Assign","setGlobal","ResolveVariablePointer","existingPointer","SnapshotDefaultGlobals","AddChangedVariable","GetContextIndexOfVariableNamed","doubleRedirectionPointer","ObserveVariableChange","PRNG","seed","next","nextFloat","StatePatch","_globals","_changedVariables","visitCounts","_visitCounts","turnIndices","_turnIndices","TryGetVisitCount","SetVisitCount","SetTurnIndex","TryGetTurnIndex","SimpleJson","Reader","ToDictionary","ToArray","_rootObject","Writer","_currentPropertyName","_currentString","_stateStack","_collectionStack","_propertyNameStack","_jsonObject","inner","StartNewObject","newObject","state","State","Property","currentCollection","currentPropertyName","propertyName","None","StateElement","Object","innerOrContent","WriteFloatProperty","IncrementChildCount","childCount","PropertyName","_addToCurrentObject","error","POSITIVE_INFINITY","NEGATIVE_INFINITY","currEl","Flow","story","outputStream","currentChoices","jChoiceThreadsObj","LoadFlowChoiceThreads","WriteListRuntimeObjs","hasChoiceThreads","jChoiceThreads","foundActiveThread","jSavedChoiceThread","StoryState","ToJson","indented","LoadJson","json","TextToDictionary","LoadJsonObj","onDidLoadState","VisitCountAtPathString","pathString","visitCountOut","_patch","VisitCountForContainer","containerPathStr","count2","IncrementVisitCountForContainer","currCount","RecordTurnIndexVisitToContainer","currentTurnIndex","TurnsSinceForContainer","index2","callstackDepth","_currentFlow","canContinue","generatedChoices","currentErrors","_currentErrors","currentWarnings","_currentWarnings","variablesState","_variablesState","evaluationStack","_evaluationStack","_currentTurnIndex","currentPathString","hasError","hasWarning","currentText","_outputStreamTextDirty","inTag","outputObj","textContent","controlCommand","_currentText","CleanOutputWhitespace","currentWhitespaceStart","startOfLine","charAt","currentTags","_outputStreamTagsDirty","_currentTags","txt","currentFlowName","currentFlowIsDefaultFlow","kDefaultFlowName","aliveFlowNames","_aliveFlowNamesDirty","_aliveFlowNames","_namedFlows","flowName","keys","kInkSaveStateVersion","kMinCompatibleLoadVersion","divertedPointer","storySeed","previousRandom","didSafeExit","OutputStreamDirty","timeSeed","Date","getTime","GoToStart","mainContentContainer","SwitchFlow_Internal","flow","SwitchToDefaultFlow_Internal","RemoveFlow_Internal","CopyAndStartPatching","namedFlowKey","namedFlowValue","RestoreAfterPatch","ApplyAnyPatch","ApplyCountChanges","newCount","isVisit","WriteIntDictionary","inkVersionCurrent","jSaveVersion","flowsObj","flowsObjDict","flowsObjDictEntries","entries","namedFlowObjKey","namedFlowObjValue","flowObj","currFlowName","currentDivertTargetPath","divertPath","JObjectToIntDictionary","ResetErrors","ResetOutput","objs","PushToOutputStream","listText","TrySplittingHeadTailWhitespace","textObj","PushToOutputStreamIndividual","PopFromOutputStream","single","headFirstNewlineIdx","headLastNewlineIdx","tailLastNewlineIdx","tailFirstNewlineIdx","listTexts","innerStrStart","innerStrEnd","leadingSpaces","innerStrText","numSpaces","trailingSpaces","glue","includeInOutput","TrimNewlinesFromOutputStream","functionTrimIndex","glueTrimIndex","o","trimIndex","RemoveExistingGlue","callStackElements","outputStreamEndsInNewline","outputStreamContainsContent","removeWhitespaceFrom","cmd","inStringEvaluation","PushEvaluationStack","n","PopEvaluationStack","numberOfObjects","PeekEvaluationStack","ForceEnd","TrimWhitespaceFromFunctionEnd","functionStartPoint","PopCallStack","popType","SetChosenPath","incrementingTurnIndex","newPointer","StartFunctionEvaluationFromGame","funcContainer","PassArgumentsToEvaluationStack","TryExitFunctionEvaluationFromGame","CompleteFunctionEvaluationFromGame","originalEvaluationStackHeight","returnedObj","poppedObj","returnVal","AddError","isWarning","Stopwatch","startTime","ElapsedMilliseconds","Start","Stop","nVal","isFinite","choices","_state","IfAsyncWeCant","_listDefinitions","StartProfiling","EndProfiling","inkVersionMinimumCompatible","onError","onDidContinue","onMakeChoice","onEvaluateFunction","onCompleteEvaluateFunction","onChoosePathString","_prevContainers","allowExternalFunctionFallbacks","_variableObservers","_hasValidatedExternals","_temporaryEvaluationContainer","_asyncContinueActive","_stateSnapshotAtLastNewline","_sawLookaheadUnsafeFunctionAfterNewline","_recursiveContinueCount","_asyncSaving","_profiler","_mainContentContainer","jsonString","_externals","rootObject","versionObj","formatFromFile","listDefsObj","rootToken","JTokenToListDefinitions","ResetState","shouldReturn","VariableStateDidChangeEvent","bind","ResetGlobals","ResetCallstack","originalPointer","ChoosePath","ContinueInternal","SwitchFlow","RemoveFlow","SwitchToDefaultFlow","Continue","ContinueAsync","asyncContinueComplete","millisecsLimitAsync","ValidateExternalBindings","PreContinue","isAsyncTimeLimited","durationStopwatch","ContinueSingleStep","RestoreStateSnapshot","PostContinue","err","PreStep","Step","PostStep","TryFollowDefaultInvisibleChoice","PreSnapshot","change","CalculateNewlineOutputStateChange","OutputStateChange","ExtendedBeyondNewline","NewlineRemoved","DiscardSnapshot","StateSnapshot","PostSnapshot","prevText","currText","prevTagCount","currTagCount","newlineStillExists","NoChange","ContinueMaximally","KnotContainerWithName","pathLengthToUse","CopyStateForBackgroundThreadSave","stateToSave","BackgroundSaveComplete","shouldAddToStream","containerToEnter","VisitContainer","currentContentObj","isLogicOrFlowControl","PerformLogicAndFlowControl","ProcessChoice","contextIdx","NextContent","atStart","VisitChangedContainersDueToDivert","prevAncestor","currentChildOfContainer","currentContainerAncestor","allChildrenEnteredAtStart","enteringAtStart","PopChoiceStringAndTags","choiceOnlyStrVal","showChoice","conditionValue","IsTruthy","startText","choiceOnlyText","reverse","divTarget","currentDivert","intContent","errorMessage","CallExternalFunction","sourceName","evalCommand","output","overrideTunnelReturnTarget","popped","names","expected","errorMsg","contentStackForTag","outputCountConsumed","command","choiceTag","contentStackForString","contentToRetain","rescuedTag","choiceCount","extraNote","eitherCount","divertTarget","maxInt","minInt","randomRange","resultSeed","nextRandom","chosenValue","shuffleIndex","NextSequenceShuffleIndex","listNameVal","generatedListValue","foundItem","targetList","listItemIndex","listEnumerator","randomItem","assignedVal","foundValue","func","funcParams","ChoosePathString","resetCallstack","funcDetail","activityStr","ChooseChoiceIndex","choiceIdx","choiceToChoose","HasFunction","EvaluateFunction","returnTextOutput","trim","outputStreamBefore","stringOutput","textOutput","returned","EvaluateExpression","exprContainer","startCallStackHeight","evalStackHeight","funcName","numberOfArguments","funcDef","fallbackFunctionContainer","foundExternal","lookAheadSafe","valueObj","funcResult","function","returnObj","BindExternalFunctionGeneral","lookaheadSafe","TryCoerce","BindExternalFunction","coercedArgs","apply","UnbindExternalFunction","missingExternals","from","innerContent","ObserveVariable","observer","ObserveVariables","variableNames","observers","RemoveVariableObserver","specificVariableName","variableObservers","newValueObj","globalTags","TagsAtStartOfFlowContainerWithPathString","TagsForContentAtPath","flowContainer","firstContent","BuildStringOfContainer","IncrementContentPointer","didPop","successfulIncrement","nextAncestor","indexInAncestor","allChoices","invisibleChoices","numElementsIntVal","seqContainer","numElements","seqCount","loopIndex","iterationIndex","seqPathStr","sequenceHash","charCodeAt","randomSeed","random","unpickedIndices","chosen","chosenIndex","currentDebugMetadata","errorTypeStr","lineNum","endLineNumber","fileName"],"mappings":"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"}